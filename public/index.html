<!doctype html>
<html lang="__HTML_LANG__" dir="__HTML_DIR__">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="__META_DESCRIPTION__" />
    <meta name="robots" content="index,follow,max-image-preview:large,max-snippet:-1,max-video-preview:-1" />
    <link rel="canonical" href="__CANONICAL_URL__" />
    __ALT_HREFLANG_LINKS__
    <meta property="og:type" content="website" />
    <meta property="og:site_name" content="ImgConvertCrop" />
    <meta property="og:url" content="__CANONICAL_URL__" />
    <meta property="og:title" content="__OG_TITLE__" />
    <meta property="og:description" content="__OG_DESCRIPTION__" />
    <meta property="og:image" content="https://imgconvertcrop.com/og-image.png" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="__TWITTER_TITLE__" />
    <meta name="twitter:description" content="__TWITTER_DESCRIPTION__" />
    <meta name="twitter:image" content="https://imgconvertcrop.com/og-image.png" />
    <title>__PAGE_TITLE__</title>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4240863320156963"
     crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@upscalerjs/esrgan-thick@1.0.0-beta.16/dist/umd/models/esrgan-thick/src/x2/index.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/upscaler@1.0.0-beta.19/dist/browser/umd/upscaler.min.js"></script>
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "WebSite",
        "name": "ImgConvertCrop",
        "url": "__CANONICAL_URL__",
        "description": "__META_DESCRIPTION__"
      }
    </script>
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "SoftwareApplication",
        "name": "ImgConvertCrop",
        "applicationCategory": "MultimediaApplication",
        "operatingSystem": "Any",
        "url": "__CANONICAL_URL__",
        "offers": {
          "@type": "Offer",
          "price": "0",
          "priceCurrency": "USD"
        },
        "description": "__META_DESCRIPTION__"
      }
    </script>
    <style>
      :root {
        --bg-1: #eef4ff;
        --bg-2: #e6eefc;
        --card: rgba(255, 255, 255, 0.96);
        --ink: #122340;
        --muted: #5e7190;
        --line: #d2deef;
        --brand: #1768ff;
        --brand-2: #0b43b5;
        --ok: #0f7a4e;
        --danger: #c42929;
        --shadow: 0 20px 48px rgba(18, 45, 95, 0.15);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Plus Jakarta Sans", "Avenir Next", "Segoe UI", sans-serif;
        color: var(--ink);
        background:
          radial-gradient(circle at 10% 10%, #ffffff 0%, transparent 46%),
          radial-gradient(circle at 90% 14%, #dce9ff 0%, transparent 36%),
          linear-gradient(180deg, var(--bg-1) 0%, var(--bg-2) 100%);
        min-height: 100vh;
      }

      .page {
        max-width: 1040px;
        margin: 28px auto;
        padding: 0 18px 22px;
      }

      .card {
        background: var(--card);
        border: 1px solid var(--line);
        border-radius: 18px;
        backdrop-filter: blur(12px);
        box-shadow: var(--shadow);
        overflow: hidden;
      }

      .head {
        padding: 22px 22px 14px;
        border-bottom: 1px solid var(--line);
      }

      .head-top {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }

      .brand-chip {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 10px;
        border-radius: 999px;
        font-size: 12px;
        font-weight: 700;
        color: #1f4f9f;
        border: 1px solid #cfe0f6;
        background: #f4f8ff;
        margin-bottom: 10px;
      }

      .locale-picker {
        display: flex;
        align-items: center;
        gap: 8px;
        min-width: 180px;
        flex-wrap: nowrap;
      }

      .locale-picker label {
        margin: 0;
        font-size: 12px;
        white-space: nowrap;
        flex: 0 0 auto;
        writing-mode: horizontal-tb;
      }

      .locale-picker select {
        min-width: 120px;
        padding: 8px 10px;
      }

      h1 {
        margin: 0 0 8px;
        font-size: clamp(1.65rem, 2.1vw, 2rem);
        letter-spacing: -0.02em;
      }

      .subtitle {
        margin: 0;
        color: var(--muted);
        font-size: 0.96rem;
      }

      .quick-flow {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 12px;
      }

      .oss-callout {
        margin-top: 12px;
        padding: 10px 12px;
        border: 1px solid #d5e2f4;
        border-radius: 12px;
        background: #f8fbff;
        color: #2a4f82;
        font-size: 13px;
      }

      .oss-callout a {
        color: #1256c8;
        font-weight: 700;
        text-decoration: none;
      }

      .oss-callout a:hover {
        text-decoration: underline;
      }

      .flow-pill {
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid #d5e2f4;
        background: #f8fbff;
        color: #345987;
        font-size: 12px;
        font-weight: 600;
      }

      .tabs {
        display: flex;
        gap: 8px;
        padding: 12px 14px 10px;
        border-bottom: 1px solid var(--line);
        flex-wrap: nowrap;
        overflow-x: auto;
        background: #f7faff;
      }

      .tab-btn {
        border: 1px solid #cfdbef;
        background: #f2f6ff;
        color: #35547f;
        padding: 9px 16px;
        border-radius: 999px;
        cursor: pointer;
        font-weight: 700;
        font-size: 0.9rem;
        width: auto;
        transition: transform 120ms ease, box-shadow 120ms ease, background-color 120ms ease;
        box-shadow: none;
      }

      .tab-btn.active {
        background: linear-gradient(180deg, #2b7bff 0%, #1768ff 100%);
        border-color: #1768ff;
        color: #ffffff;
        box-shadow: 0 6px 14px rgba(23, 104, 255, 0.28);
      }

      .tab-btn:hover {
        transform: translateY(-1px);
      }

      .panel {
        display: none;
        padding: 18px 18px 22px;
      }

      .panel.active {
        display: block;
      }

      .grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 14px;
      }

      .full {
        grid-column: 1 / -1;
      }

      label {
        display: block;
        margin-bottom: 7px;
        font-size: 12px;
        font-weight: 700;
        text-transform: none;
        letter-spacing: 0.02em;
        color: #2f4467;
      }

      input,
      select,
      button {
        width: 100%;
        border: 1px solid #cfdced;
        border-radius: 12px;
        padding: 11px 12px;
        font-size: 14px;
        background: #fbfdff;
      }

      button {
        background: linear-gradient(180deg, #2b7bff 0%, #1768ff 100%);
        border-color: #1768ff;
        color: #fff;
        cursor: pointer;
        font-weight: 700;
        letter-spacing: 0.01em;
        box-shadow: 0 8px 16px rgba(23, 104, 255, 0.28);
      }

      button.alt {
        background: #f2f6ff;
        border-color: #ccd9f0;
        color: #1b3d74;
        box-shadow: none;
      }

      input:focus,
      select:focus,
      button:focus-visible {
        outline: none;
        border-color: #7aa9ff;
        box-shadow: 0 0 0 3px rgba(23, 104, 255, 0.16);
      }

      button:disabled {
        opacity: 0.7;
        cursor: not-allowed;
      }

      .status {
        margin-top: 14px;
        font-size: 14px;
        color: #2a4570;
        padding: 10px 12px;
        border-radius: 10px;
        background: #f3f8ff;
        border: 1px solid #d8e4f5;
      }
      .status:empty {
        display: none;
      }

      .status.error {
        color: var(--danger);
        background: #fff1f1;
        border-color: #f2c6c6;
      }

      .status.ok {
        color: var(--ok);
        background: #eefaf4;
        border-color: #bde8cf;
      }

      .progress-wrap {
        margin-top: 10px;
      }

      #upscaleProgressWrap {
        position: relative;
      }

      .progress-wrap progress {
        width: 100%;
        height: 12px;
        border-radius: 999px;
      }

      #upscaleProgress {
        appearance: none;
        -webkit-appearance: none;
      }

      #upscaleProgress::-webkit-progress-bar {
        background: #e5ebf5;
        border-radius: 999px;
      }

      #upscaleProgress::-webkit-progress-value {
        border-radius: 999px;
        background-image:
          linear-gradient(
            110deg,
            rgba(255, 255, 255, 0) 0%,
            rgba(255, 255, 255, 0.22) 25%,
            rgba(255, 255, 255, 0.36) 38%,
            rgba(255, 255, 255, 0.22) 51%,
            rgba(255, 255, 255, 0) 72%
          ),
          linear-gradient(90deg, #7f3fb0 0%, #9156c8 55%, #7f3fb0 100%);
        background-size: 220% 100%, 100% 100%;
        background-position: 200% 0, 0 0;
      }

      #upscaleProgress::-moz-progress-bar {
        border-radius: 999px;
        background-image:
          linear-gradient(
            110deg,
            rgba(255, 255, 255, 0) 0%,
            rgba(255, 255, 255, 0.22) 25%,
            rgba(255, 255, 255, 0.36) 38%,
            rgba(255, 255, 255, 0.22) 51%,
            rgba(255, 255, 255, 0) 72%
          ),
          linear-gradient(90deg, #7f3fb0 0%, #9156c8 55%, #7f3fb0 100%);
        background-size: 220% 100%, 100% 100%;
        background-position: 200% 0, 0 0;
      }

      @keyframes upscaleGlowPulse {
        0% {
          filter: brightness(1.03) saturate(1.02);
        }
        50% {
          filter: brightness(1.42) saturate(1.08);
        }
        100% {
          filter: brightness(1.03) saturate(1.02);
        }
      }

      @keyframes upscaleTrackBreathe {
        0% {
          box-shadow: 0 0 0 rgba(127, 63, 176, 0), 0 0 0 rgba(175, 104, 224, 0);
        }
        50% {
          box-shadow: 0 0 20px rgba(127, 63, 176, 0.62), 0 0 9px rgba(175, 104, 224, 0.46);
        }
        100% {
          box-shadow: 0 0 0 rgba(127, 63, 176, 0), 0 0 0 rgba(175, 104, 224, 0);
        }
      }

      @keyframes upscaleFlow {
        0% {
          background-position: 200% 0, 0 0;
        }
        100% {
          background-position: -80% 0, 0 0;
        }
      }

      @keyframes upscaleShineSweep {
        0% {
          transform: translateX(-120%);
          opacity: 0;
        }
        20% {
          opacity: 0.26;
        }
        100% {
          transform: translateX(320%);
          opacity: 0;
        }
      }

      #upscaleProgressWrap.is-busy #upscaleProgress {
        animation: upscaleTrackBreathe 1.35s ease-in-out infinite;
      }

      #upscaleProgressWrap.is-busy #upscaleProgress::-webkit-progress-value {
        animation: upscaleFlow 1.35s linear infinite, upscaleGlowPulse 1.1s ease-in-out infinite;
      }

      #upscaleProgressWrap.is-busy #upscaleProgress::-moz-progress-bar {
        animation: upscaleFlow 1.35s linear infinite, upscaleGlowPulse 1.1s ease-in-out infinite;
      }

      #upscaleProgressWrap.is-busy::after {
        content: '';
        position: absolute;
        left: 0;
        top: 0;
        width: 34%;
        height: 12px;
        border-radius: 999px;
        pointer-events: none;
        background: linear-gradient(90deg, rgba(255, 255, 255, 0) 0%, rgba(228, 194, 255, 0.64) 45%, rgba(255, 255, 255, 0) 100%);
        filter: blur(0.2px);
        animation: upscaleShineSweep 1.5s ease-in-out infinite;
      }

      .progress-label {
        margin-top: 6px;
        font-size: 12px;
        color: var(--muted);
      }

      .crop-shell {
        border: 1px solid var(--line);
        border-radius: 14px;
        background: #f8fbff;
        padding: 12px;
      }

      .crop-canvas-wrap {
        width: 100%;
        overflow: auto;
        -webkit-overflow-scrolling: touch;
        border-radius: 10px;
        background: linear-gradient(135deg, #d7e2f5 0%, #e8effd 100%);
        border: 1px solid #cfdbef;
      }

      #cropCanvas {
        display: block;
        width: 100%;
        max-width: 100%;
        height: auto;
        margin: 0 auto;
        cursor: crosshair;
        touch-action: none;
      }

      .note {
        color: var(--muted);
        font-size: 12px;
        margin-bottom: 0;
      }

      .note-highlight {
        color: #0b43b5;
        font-weight: 700;
        background: #e8f0ff;
        border: 1px solid #c7d9ff;
        border-radius: 8px;
        padding: 8px 10px;
        margin-top: 6px;
      }

      .restore-help {
        border: 1px solid #d6e3f7;
        background: #f7faff;
        border-radius: 10px;
        padding: 10px 12px;
        margin-top: -2px;
      }

      .restore-help-title {
        margin: 0 0 8px;
        font-size: 12px;
        font-weight: 700;
        color: #2b4875;
      }

      .restore-item {
        display: flex;
        align-items: flex-start;
        gap: 8px;
        font-size: 12px;
        color: var(--muted);
        padding: 8px 0;
        border-top: 1px dashed #d9e5f8;
      }

      .restore-item:first-of-type {
        border-top: none;
      }

      .restore-chip {
        flex: 0 0 auto;
        font-weight: 700;
        color: #1c4ea0;
        background: #e5efff;
        border: 1px solid #c8dafd;
        border-radius: 999px;
        padding: 2px 8px;
        line-height: 1.35;
      }

      .restore-text {
        line-height: 1.4;
        padding-top: 2px;
      }

      .confirm-actions {
        display: flex;
        gap: 8px;
        margin-top: 8px;
      }

      .confirm-actions button {
        width: auto;
        min-width: 110px;
      }

      .inline-toggle {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 8px 10px;
        border-radius: 10px;
        background: #f3f7ff;
        border: 1px solid #d8e3f4;
      }

      .inline-toggle input {
        width: auto;
      }

      .hidden {
        display: none;
      }

      .ad-wrap {
        margin: 14px 0 6px;
        border: 1px solid #d9e3f2;
        border-radius: 12px;
        background: #f8fbff;
        padding: 8px;
      }

      .ad-wrap.bottom {
        margin-top: 18px;
      }

      .left-rail-ad {
        position: fixed;
        top: 120px;
        left: 14px;
        width: 190px;
        z-index: 20;
      }

      .right-rail-ad {
        position: fixed;
        top: 120px;
        right: 14px;
        width: 190px;
        z-index: 20;
      }

      .left-rail-ad .ad-wrap {
        margin: 0;
        padding: 10px;
        border-radius: 14px;
        box-shadow: 0 10px 20px rgba(16, 36, 74, 0.12);
      }

      .right-rail-ad .ad-wrap {
        margin: 0;
        padding: 10px;
        border-radius: 14px;
        box-shadow: 0 10px 20px rgba(16, 36, 74, 0.12);
      }

      .tool-card {
        margin-top: 12px;
        padding: 14px;
        border: 1px solid #d8e3f3;
        border-radius: 14px;
        background: linear-gradient(180deg, #fbfdff 0%, #f5f9ff 100%);
      }

      .tool-title {
        margin: 0 0 4px;
        font-size: 15px;
        font-weight: 700;
        color: #223f67;
      }

      .tool-subtitle {
        margin: 0 0 10px;
        color: var(--muted);
        font-size: 12px;
      }

      .seo-copy {
        margin-top: 16px;
        padding: 14px;
        border: 1px solid #d8e3f3;
        border-radius: 14px;
        background: #f9fcff;
      }

      .seo-copy h2 {
        margin: 0 0 8px;
        font-size: 18px;
        color: #1d3f70;
      }

      .seo-copy p {
        margin: 0 0 8px;
        color: #34557f;
        line-height: 1.5;
        font-size: 14px;
      }

      .seo-copy ul {
        margin: 0;
        padding-left: 18px;
        color: #34557f;
        font-size: 14px;
      }

      .keyword-copy {
        margin-top: 12px;
        padding-top: 12px;
        border-top: 1px dashed #d5e2f4;
      }

      .keyword-copy h3 {
        margin: 0 0 8px;
        font-size: 15px;
        color: #244a7f;
      }

      .keyword-copy p {
        margin: 0;
        color: #3d5f8c;
      }

      .related-links {
        margin-top: 12px;
        padding-top: 12px;
        border-top: 1px dashed #d5e2f4;
      }

      .related-links h3 {
        margin: 0 0 8px;
        font-size: 15px;
        color: #244a7f;
      }

      .related-links ul {
        margin: 0;
        padding-left: 18px;
      }

      .related-links a {
        color: #1c59b8;
        text-decoration: none;
      }

      .related-links a:hover {
        text-decoration: underline;
      }

      @media (max-width: 760px) {
        .page {
          margin-top: 20px;
          padding: 0 12px 16px;
        }

        .head {
          padding: 18px 16px 12px;
        }

        .tabs {
          padding: 12px 12px 10px;
        }

        .panel {
          padding: 16px 14px 18px;
        }

        .grid {
          grid-template-columns: 1fr;
        }

        .tabs {
          gap: 10px;
        }

        .tab-btn {
          padding: 10px 16px;
        }

        .crop-shell {
          padding: 10px;
        }

        .inline-toggle {
          padding: 10px 12px;
        }

        #cropCanvas {
          touch-action: none;
        }
      }

      @media (max-width: 1300px) {
        .left-rail-ad {
          display: none;
        }
        .right-rail-ad {
          display: none;
        }
      }
    </style>
  </head>
  <body>
    <aside class="left-rail-ad" aria-label="Advertisement">
      <div class="ad-wrap">
        <ins class="adsbygoogle"
             style="display:block"
             data-ad-client="ca-pub-4240863320156963"
             data-ad-slot="3548309138"
             data-ad-format="auto"
             data-full-width-responsive="true"></ins>
      </div>
    </aside>
    <aside class="right-rail-ad" aria-label="Advertisement">
      <div class="ad-wrap">
        <ins class="adsbygoogle"
             style="display:block"
             data-ad-client="ca-pub-4240863320156963"
             data-ad-slot="2551746648"
             data-ad-format="auto"
             data-full-width-responsive="true"></ins>
      </div>
    </aside>
    <main class="page">
      <section class="card">
        <div class="head">
          <div class="head-top">
            <div class="brand-chip">imgconvertcrop.com</div>
            <div class="locale-picker">
              <label for="languageSelect" data-i18n="lang.label">Language</label>
              <select id="languageSelect">__LANG_OPTIONS_HTML__</select>
            </div>
          </div>
          <h1 id="heroTitle">__HERO_TITLE__</h1>
          <p class="subtitle" id="heroSubtitle">__HERO_SUBTITLE__</p>
          <p class="oss-callout">
            <span data-i18n="oss.prefix">Open source:</span>
            <a href="https://github.com/supdub/image-free-convert" target="_blank" rel="noopener noreferrer" data-i18n="oss.link">GitHub repo</a>
            <span data-i18n="oss.suffix">Deploy your own version.</span>
          </p>
          <div class="quick-flow">
            <span class="flow-pill" data-i18n="flow.upload">1. Upload</span>
            <span class="flow-pill" data-i18n="flow.adjust">2. Adjust</span>
            <span class="flow-pill" data-i18n="flow.download">3. Download</span>
            <span class="flow-pill" data-i18n="flow.privacy">We never save your images</span>
          </div>
        </div>

        <div class="tabs" role="tablist">
          <button type="button" class="tab-btn __CONVERT_TAB_ACTIVE__" data-tab="convert" role="tab" data-i18n="tab.convert">Convert</button>
          <button type="button" class="tab-btn __CROP_TAB_ACTIVE__" data-tab="crop" role="tab" data-i18n="tab.crop">Crop</button>
          <button type="button" class="tab-btn __COMPRESS_TAB_ACTIVE__" data-tab="compress" role="tab" data-i18n="tab.compress">Compress</button>
          <button type="button" class="tab-btn __UPSCALE_TAB_ACTIVE__" data-tab="upscale" role="tab" data-i18n="tab.upscale">Upscale</button>
        </div>

        <section class="panel __CONVERT_PANEL_ACTIVE__" id="panel-convert">
          <div class="tool-card">
            <p class="tool-title" data-i18n="convert.title">Convert Images</p>
            <p class="tool-subtitle" data-i18n="convert.subtitle">Change image format while keeping quality under your control.</p>
          <div class="ad-wrap">
            <ins class="adsbygoogle"
                 style="display:block"
                 data-ad-client="ca-pub-4240863320156963"
                 data-ad-slot="3548309138"
                 data-ad-format="auto"
                 data-full-width-responsive="true"></ins>
          </div>
          <div class="grid">
            <div class="full">
              <label for="convertImage" data-i18n="field.imageFile">Image File</label>
              <input id="convertImage" type="file" accept="image/*" />
            </div>
            <div>
              <label for="convertFormat" data-i18n="field.outputFormat">Output Format</label>
              <select id="convertFormat">
                <option value="jpeg">JPEG</option>
                <option value="png">PNG</option>
                <option value="webp">WEBP</option>
                <option value="avif">AVIF</option>
              </select>
            </div>
            <div>
              <label for="convertQuality" data-i18n="field.quality">Quality (1-100)</label>
              <input id="convertQuality" type="number" min="1" max="100" value="90" />
            </div>
            <div class="full">
              <button type="button" id="convertBtn" data-i18n="btn.convertDownload">Convert and Download</button>
            </div>
          </div>
          <div class="status" id="convertStatus" aria-live="polite"></div>
          <div class="ad-wrap bottom">
            <ins class="adsbygoogle"
                 style="display:block"
                 data-ad-client="ca-pub-4240863320156963"
                 data-ad-slot="3548309138"
                 data-ad-format="auto"
                 data-full-width-responsive="true"></ins>
          </div>
          <section class="seo-copy" aria-label="What this tool does">
            <h2>__SEO_H2__</h2>
            <p>__SEO_P1__</p>
            <p>__SEO_P2__</p>
            <ul>
              <li>__SEO_LI_1__</li>
              <li>__SEO_LI_2__</li>
              <li>__SEO_LI_3__</li>
            </ul>
            <div class="keyword-copy" aria-label="Keyword search intent">
              <h3>__KEYWORD_TITLE__</h3>
              <p>__KEYWORD_TEXT__</p>
            </div>
            <nav class="related-links" aria-label="Related tool pages">
              <h3 data-i18n="seo.relatedPages">Related pages</h3>
              <ul>
                __RELATED_LINKS_HTML__
              </ul>
            </nav>
          </section>
          </div>
        </section>

        <section class="panel __CROP_PANEL_ACTIVE__" id="panel-crop">
          <div class="tool-card">
            <p class="tool-title" data-i18n="crop.title">Crop Images</p>
            <p class="tool-subtitle" data-i18n="crop.subtitle">Use the crop frame to focus only on the area you want, then optionally resize.</p>
          <div class="ad-wrap">
            <ins class="adsbygoogle"
                 style="display:block"
                 data-ad-client="ca-pub-4240863320156963"
                 data-ad-slot="3548309138"
                 data-ad-format="auto"
                 data-full-width-responsive="true"></ins>
          </div>
          <div class="grid">
            <div class="full">
              <label for="cropImage" data-i18n="field.imageFile">Image File</label>
              <input id="cropImage" type="file" accept="image/*" />
            </div>
            <div class="full crop-shell">
              <div class="crop-canvas-wrap">
                <canvas id="cropCanvas" width="860" height="480"></canvas>
              </div>
              <p class="note" data-i18n="crop.instructions">Drag inside the box to move. Drag corners to resize. Use Confirm Crop when ready.</p>
            </div>

            <div>
              <label for="cropFormat" data-i18n="field.outputFormat">Output Format</label>
              <select id="cropFormat">
                <option value="png">PNG</option>
                <option value="jpeg">JPEG</option>
                <option value="webp">WEBP</option>
                <option value="avif">AVIF</option>
              </select>
            </div>
            <div>
              <label for="cropQuality" data-i18n="field.quality">Quality (1-100)</label>
              <input id="cropQuality" type="number" min="1" max="100" value="90" />
            </div>
            <div>
              <label for="cropAspectRatio" data-i18n="crop.aspectRatio">Aspect Ratio</label>
              <select id="cropAspectRatio">
                <option value="free" data-i18n="crop.ratio.free">Free</option>
                <option value="1:1">1:1</option>
                <option value="4:3">4:3</option>
                <option value="3:4">3:4</option>
                <option value="16:9">16:9</option>
                <option value="9:16">9:16</option>
                <option value="3:2">3:2</option>
                <option value="2:3">2:3</option>
              </select>
            </div>

            <div class="full inline-toggle">
              <input id="enableCropResize" type="checkbox" />
              <label for="enableCropResize" style="margin: 0" data-i18n="crop.resizeAfter">Resize after crop</label>
            </div>
            <div class="full note" id="cropResizeExplain" data-i18n="crop.resizeExplain">
              If enabled, the cropped image is scaled down to fit within the width/height you provide. It keeps aspect ratio and will not stretch.
            </div>

            <div id="cropResizeWidthWrap" class="hidden">
              <label for="cropResizeWidth" data-i18n="crop.resizeWidth">Resize Width</label>
              <input id="cropResizeWidth" type="number" min="1" placeholder="e.g. 800" />
            </div>
            <div id="cropResizeHeightWrap" class="hidden">
              <label for="cropResizeHeight" data-i18n="crop.resizeHeight">Resize Height</label>
              <input id="cropResizeHeight" type="number" min="1" placeholder="e.g. 600" />
            </div>

            <div>
              <button type="button" class="alt" id="resetCropBtn" data-i18n="btn.resetBox">Reset Box</button>
            </div>
            <div>
              <button type="button" id="confirmCropBtn" data-i18n="btn.confirmCropDownload">Confirm Crop and Download</button>
            </div>
          </div>
            <div class="status" id="cropStatus" aria-live="polite"></div>
            <div class="ad-wrap bottom">
              <ins class="adsbygoogle"
                   style="display:block"
                   data-ad-client="ca-pub-4240863320156963"
                   data-ad-slot="3548309138"
                   data-ad-format="auto"
                   data-full-width-responsive="true"></ins>
            </div>
          </div>
        </section>

        <section class="panel __COMPRESS_PANEL_ACTIVE__" id="panel-compress">
          <div class="tool-card">
            <p class="tool-title" data-i18n="compress.title">Compress Images</p>
            <p class="tool-subtitle" data-i18n="compress.subtitle">Reduce file size while preserving the same pixel dimensions.</p>
          <div class="ad-wrap">
            <ins class="adsbygoogle"
                 style="display:block"
                 data-ad-client="ca-pub-4240863320156963"
                 data-ad-slot="3548309138"
                 data-ad-format="auto"
                 data-full-width-responsive="true"></ins>
          </div>
          <div class="grid">
            <div class="full">
              <label for="compressImage" data-i18n="field.imageFile">Image File</label>
              <input id="compressImage" type="file" accept="image/*" />
            </div>
            <div>
              <label for="compressFormat" data-i18n="field.outputFormat">Output Format</label>
              <select id="compressFormat">
                <option value="jpeg">JPEG</option>
                <option value="webp">WEBP</option>
                <option value="avif">AVIF</option>
                <option value="png">PNG</option>
              </select>
            </div>
            <div>
              <label for="compressQuality" data-i18n="compress.quality">Compression Quality (1-100)</label>
              <input id="compressQuality" type="number" min="1" max="100" value="70" />
            </div>
            <div class="full">
              <p class="note" data-i18n="compress.note">Compress keeps the same pixel dimensions. It only reduces encoded quality/size.</p>
            </div>
            <div class="full">
              <button type="button" id="compressBtn" data-i18n="btn.compressDownload">Compress and Download</button>
            </div>
          </div>
          <div class="status" id="compressStatus" aria-live="polite"></div>
          <div class="ad-wrap bottom">
            <ins class="adsbygoogle"
                 style="display:block"
                 data-ad-client="ca-pub-4240863320156963"
                 data-ad-slot="3548309138"
                 data-ad-format="auto"
                 data-full-width-responsive="true"></ins>
          </div>
          </div>
        </section>

        <section class="panel __UPSCALE_PANEL_ACTIVE__" id="panel-upscale">
          <div class="tool-card">
            <p class="tool-title" data-i18n="upscale.title">Upscale Images</p>
            <p class="tool-subtitle" data-i18n="upscale.subtitle">AI Enhance upscale that can recover perceived detail, not just stretch pixels.</p>
          <div class="ad-wrap">
            <ins class="adsbygoogle"
                 style="display:block"
                 data-ad-client="ca-pub-4240863320156963"
                 data-ad-slot="3548309138"
                 data-ad-format="auto"
                 data-full-width-responsive="true"></ins>
          </div>
          <div class="grid">
            <div class="full">
              <label for="upscaleImage" data-i18n="field.imageFile">Image File</label>
              <input id="upscaleImage" type="file" accept="image/*" />
            </div>
            <div>
              <label for="upscaleScale" data-i18n="upscale.scale">Scale</label>
              <select id="upscaleScale">
                <option value="2">2x</option>
                <option value="4">4x</option>
              </select>
            </div>
            <div>
              <label for="upscaleFormat" data-i18n="field.outputFormat">Output Format</label>
              <select id="upscaleFormat">
                <option value="png">PNG</option>
                <option value="jpeg">JPEG</option>
                <option value="webp">WEBP</option>
                <option value="avif">AVIF</option>
              </select>
            </div>
            <div>
              <label for="upscaleQuality" data-i18n="upscale.quality">Output Quality (1-100)</label>
              <input id="upscaleQuality" type="number" min="1" max="100" value="100" />
            </div>
            <div>
              <label for="upscaleRestoreMode" data-i18n="upscale.restoreMode">Restore Mode</label>
              <select id="upscaleRestoreMode">
                <option value="balanced" data-i18n="upscale.restore.balanced">Balanced</option>
                <option value="aggressive" data-i18n="upscale.restore.aggressive">Aggressive</option>
                <option value="logo" data-i18n="upscale.restore.logo">Text/Logo</option>
              </select>
            </div>
            <div class="full restore-help">
              <p class="restore-help-title" data-i18n="upscale.restore.helpTitle">Which restore mode should I use?</p>
              <div class="restore-item">
                <span class="restore-chip" data-i18n="upscale.restore.balanced">Balanced</span>
                <span class="restore-text" data-i18n="upscale.restore.help.balanced">Safer default for most photos and mixed content.</span>
              </div>
              <div class="restore-item">
                <span class="restore-chip" data-i18n="upscale.restore.aggressive">Aggressive</span>
                <span class="restore-text" data-i18n="upscale.restore.help.aggressive">Stronger deblock and sharpening, may add halos/noise.</span>
              </div>
              <div class="restore-item">
                <span class="restore-chip" data-i18n="upscale.restore.logo">Text/Logo</span>
                <span class="restore-text" data-i18n="upscale.restore.help.logo">Prioritizes hard edges for logos, icons, and text-like shapes.</span>
              </div>
            </div>
            <div class="full">
              <p class="note" data-i18n="upscale.note">AI Enhance can improve sharpness and texture, but it cannot perfectly recreate missing detail.</p>
              <p class="note" data-i18n="upscale.note2">Very blurry or tiny sources may still look soft. First run downloads a larger ESRGAN model in your browser.</p>
              <p class="note note-highlight" data-i18n="upscale.note3">Expected first-run data: about 31 MB total (model + AI runtime), then cached by browser.</p>
              <p class="note" data-i18n="upscale.note4">4x runs two AI passes, so it is much slower than 2x.</p>
            </div>
            <div class="full progress-wrap" id="upscaleProgressWrap">
              <progress id="upscaleProgress" value="0" max="100"></progress>
              <div class="progress-label" id="upscaleProgressLabel" data-i18n="upscale.progressIdle">Waiting to start AI enhance.</div>
            </div>
            <div class="full hidden note note-highlight" id="upscaleConfirmBox">
              <span id="upscaleConfirmText" data-i18n="upscale.confirmUse">AI Enhance may download about 31 MB on first run and can take time. Continue?</span>
              <div class="confirm-actions">
                <button type="button" id="upscaleConfirmYes" data-i18n="btn.continue">Continue</button>
                <button type="button" class="alt" id="upscaleConfirmNo" data-i18n="btn.cancel">Cancel</button>
              </div>
            </div>
            <div class="full" id="upscaleActionRow">
              <button type="button" id="upscaleBtn" data-i18n="btn.upscaleDownload">Upscale and Download</button>
            </div>
          </div>
          <div class="status" id="upscaleStatus" aria-live="polite"></div>
          <div class="ad-wrap bottom">
            <ins class="adsbygoogle"
                 style="display:block"
                 data-ad-client="ca-pub-4240863320156963"
                 data-ad-slot="3548309138"
                 data-ad-format="auto"
                 data-full-width-responsive="true"></ins>
          </div>
          </div>
        </section>
      </section>
    </main>

    <script>
      window.__PAGE_CONFIG__ = __PAGE_CONFIG_JSON__;

      document.querySelectorAll('.adsbygoogle').forEach(() => {
        try { (adsbygoogle = window.adsbygoogle || []).push({}); } catch (_e) {}
      });

      const pageConfig = window.__PAGE_CONFIG__ || {};
      const locale = pageConfig.locale || 'en';
      const i18n = {
        en: {
          'lang.label': 'Language',
          'flow.upload': '1. Upload',
          'flow.adjust': '2. Adjust',
          'flow.download': '3. Download',
          'flow.privacy': 'We never save your images',
          'tab.convert': 'Convert',
          'tab.crop': 'Crop',
          'tab.compress': 'Compress',
          'tab.upscale': 'Upscale',
          'oss.prefix': 'Open source:',
          'oss.link': 'GitHub repo',
          'oss.suffix': 'Deploy your own version.',
          'convert.title': 'Convert Images',
          'convert.subtitle': 'Change image format while keeping quality under your control.',
          'crop.title': 'Crop Images',
          'crop.subtitle': 'Use the crop frame to focus only on the area you want, then optionally resize.',
          'compress.title': 'Compress Images',
          'compress.subtitle': 'Reduce file size while preserving the same pixel dimensions.',
          'upscale.title': 'Upscale Images',
          'upscale.subtitle': 'AI Enhance upscale that can recover perceived detail, not just stretch pixels.',
          'field.imageFile': 'Image File',
          'field.outputFormat': 'Output Format',
          'field.quality': 'Quality (1-100)',
          'compress.quality': 'Compression Quality (1-100)',
          'upscale.scale': 'Scale',
          'upscale.quality': 'Output Quality (1-100)',
          'upscale.restoreMode': 'Restore Mode',
          'upscale.restore.balanced': 'Balanced',
          'upscale.restore.aggressive': 'Aggressive',
          'upscale.restore.logo': 'Text/Logo',
          'upscale.restore.helpTitle': 'Which restore mode should I use?',
          'upscale.restore.help.balanced': 'Safer default for most photos and mixed content.',
          'upscale.restore.help.aggressive': 'Stronger deblock and sharpening, may add halos/noise.',
          'upscale.restore.help.logo': 'Prioritizes hard edges for logos, icons, and text-like shapes.',
          'btn.convertDownload': 'Convert and Download',
          'btn.resetBox': 'Reset Box',
          'btn.confirmCropDownload': 'Confirm Crop and Download',
          'btn.compressDownload': 'Compress and Download',
          'btn.upscaleDownload': 'Upscale and Download',
          'btn.continue': 'Continue',
          'btn.cancel': 'Cancel',
          'crop.instructions': 'Drag inside the box to move. Drag corners to resize. Use Confirm Crop when ready.',
          'crop.aspectRatio': 'Aspect Ratio',
          'crop.ratio.free': 'Free',
          'crop.resizeAfter': 'Resize after crop',
          'crop.resizeExplain':
            'If enabled, the cropped image is scaled down to fit within the width/height you provide. It keeps aspect ratio and will not stretch.',
          'crop.resizeWidth': 'Resize Width',
          'crop.resizeHeight': 'Resize Height',
          'compress.note': 'Compress keeps the same pixel dimensions. It only reduces encoded quality/size.',
          'upscale.note': 'AI Enhance can improve sharpness and texture, but it cannot perfectly recreate missing detail.',
          'upscale.note2': 'Very blurry or tiny sources may still look soft. First run downloads a larger ESRGAN model in your browser.',
          'upscale.note3': 'Expected first-run data: about 31 MB total (model + AI runtime), then cached by browser.',
          'upscale.note4': '4x runs two AI passes, so it is much slower than 2x.',
          'upscale.progressIdle': 'Waiting to start AI enhance.',
          'upscale.confirmUse': 'AI Enhance may download about 31 MB on first run and can take time. Continue?',
          'hero.convert.title': 'Free Image Converter',
          'hero.convert.subtitle': 'Convert JPG, PNG, WEBP, and AVIF directly in your browser.',
          'hero.crop.title': 'Free Image Cropper',
          'hero.crop.subtitle': 'Drag, resize, and export exact crop areas with optional resize after crop.',
          'hero.compress.title': 'Free Image Compressor',
          'hero.compress.subtitle': 'Reduce image file size while keeping dimensions.',
          'hero.upscale.title': 'Free Image Upscaler',
          'hero.upscale.subtitle': 'AI Enhance runs on your device to upscale at 2x or 4x with practical quality limits.',
          'seo.relatedPages': 'Related pages',
          'status.chooseImage': 'Choose an image first.',
          'status.uploadFirst': 'Upload an image first.',
          'status.converting': 'Converting...',
          'status.compressing': 'Compressing (same dimensions)...',
          'status.upscaling': 'Upscaling image...',
          'status.aiInit': 'Preparing AI engine...',
          'status.aiModelLoad': 'Loading AI model (~31 MB on first run)...',
          'status.aiEnhancingPass': 'AI enhancing pass {pass}/{total}...',
          'status.aiPreprocess': 'Restoring before AI upscale...',
          'status.aiPostprocess': 'Enhancing edges after AI upscale...',
          'status.aiFinalizing': 'Finalizing output and downloading...',
          'status.cropProcessing': 'Processing crop...',
          'status.doneDownload': 'Done. Download started.',
          'status.cancelled': 'Cancelled.',
          'status.cropDone': 'Crop confirmed. Download started.',
          'status.compressDone': 'Compression done. Download started.',
          'status.upscaleDone': 'Upscale done. Download started.',
          'status.previewIos': 'Preview opened. On iPhone tap Share, then Save Image.',
          'status.imageLoaded': 'Image loaded. Adjust crop and confirm.',
          'status.loadFailed': 'Failed to load image.',
          'status.cropReset': 'Crop box reset.',
          'status.cropCanvasPrompt': 'Upload an image to crop',
          'error.notSupported': '{format} export is not supported in this browser.',
          'error.resizeParams': 'Provide resize width and/or height.',
          'error.convertFailed': 'Convert failed.',
          'error.cropFailed': 'Crop failed.',
          'error.compressFailed': 'Compress failed.',
          'error.upscaleFailed': 'Upscale failed.',
          'error.upscaleTooLarge': 'Image is too large for AI Enhance in browser. Keep it under about {maxMp} MP for this scale.',
          'ph.resizeWidth': 'e.g. 800',
          'ph.resizeHeight': 'e.g. 600'
        },
        es: {
          'lang.label': 'Idioma',
          'flow.upload': '1. Subir',
          'flow.adjust': '2. Ajustar',
          'flow.download': '3. Descargar',
          'flow.privacy': 'Nunca guardamos tus imagenes',
          'tab.convert': 'Convertir',
          'tab.crop': 'Recortar',
          'tab.compress': 'Comprimir',
          'tab.upscale': 'Mejorar',
          'oss.prefix': 'Codigo abierto:',
          'oss.link': 'Repositorio en GitHub',
          'oss.suffix': 'Despliega tu propia version.',
          'convert.title': 'Convertir imagenes',
          'convert.subtitle': 'Cambia el formato de imagen con control de calidad.',
          'crop.title': 'Recortar imagenes',
          'crop.subtitle': 'Usa el marco de recorte y, si quieres, cambia el tamano.',
          'compress.title': 'Comprimir imagenes',
          'compress.subtitle': 'Reduce el tamano del archivo manteniendo las dimensiones.',
          'upscale.title': 'Mejorar resolucion',
          'upscale.subtitle': 'Aumenta la resolucion de la imagen en tu dispositivo con un escalado practico.',
          'field.imageFile': 'Archivo de imagen',
          'field.outputFormat': 'Formato de salida',
          'field.quality': 'Calidad (1-100)',
          'compress.quality': 'Calidad de compresion (1-100)',
          'upscale.scale': 'Escala',
          'upscale.quality': 'Calidad de salida (1-100)',
          'upscale.restoreMode': 'Modo de restauracion',
          'upscale.restore.balanced': 'Equilibrado',
          'upscale.restore.aggressive': 'Agresivo',
          'upscale.restore.logo': 'Texto/Logo',
          'upscale.restore.helpTitle': 'Que modo de restauracion debo usar?',
          'upscale.restore.help.balanced': 'Opcion mas segura para fotos y contenido mixto.',
          'upscale.restore.help.aggressive': 'Deblock y enfoque mas fuertes; puede generar halos/ruido.',
          'upscale.restore.help.logo': 'Prioriza bordes duros para logos, iconos y formas de texto.',
          'btn.convertDownload': 'Convertir y descargar',
          'btn.resetBox': 'Restablecer caja',
          'btn.confirmCropDownload': 'Confirmar recorte y descargar',
          'btn.compressDownload': 'Comprimir y descargar',
          'btn.upscaleDownload': 'Mejorar y descargar',
          'btn.continue': 'Continuar',
          'btn.cancel': 'Cancelar',
          'crop.instructions': 'Arrastra dentro para mover. Arrastra esquinas para cambiar tamano.',
          'crop.aspectRatio': 'Relacion de aspecto',
          'crop.ratio.free': 'Libre',
          'crop.resizeAfter': 'Redimensionar despues de recortar',
          'crop.resizeExplain': 'Si lo activas, la imagen recortada se ajusta al ancho/alto indicado sin deformar.',
          'crop.resizeWidth': 'Ancho',
          'crop.resizeHeight': 'Alto',
          'compress.note': 'Comprimir mantiene las mismas dimensiones de pixeles.',
          'upscale.note': 'Para mantener velocidad y estabilidad, salidas muy grandes pueden limitarse automaticamente.',
          'upscale.note2': 'Las imagenes muy borrosas o pequenas pueden seguir viendose suaves. En la primera ejecucion se descarga un modelo ESRGAN mas grande en tu navegador.',
          'upscale.note3': 'Datos esperados en la primera ejecucion: alrededor de 31 MB en total (modelo + runtime de IA), luego queda en cache del navegador.',
          'upscale.note4': '4x ejecuta dos pasadas de IA, por lo que es mucho mas lento que 2x.',
          'hero.convert.title': 'Convertidor de imagenes gratis',
          'hero.convert.subtitle': 'Convierte JPG, PNG, WEBP y AVIF directamente en tu navegador.',
          'hero.crop.title': 'Recortador de imagenes gratis',
          'hero.crop.subtitle': 'Arrastra, redimensiona y exporta recortes exactos con cambio de tamano opcional.',
          'hero.compress.title': 'Compresor de imagenes gratis',
          'hero.compress.subtitle': 'Reduce el tamano del archivo manteniendo las dimensiones.',
          'hero.upscale.title': 'Mejorador de imagenes gratis',
          'hero.upscale.subtitle': 'AI Enhance se ejecuta en tu dispositivo para ampliar a 2x o 4x con limites practicos.',
          'seo.relatedPages': 'Paginas relacionadas',
          'status.chooseImage': 'Elige una imagen primero.',
          'status.uploadFirst': 'Sube una imagen primero.',
          'status.converting': 'Convirtiendo...',
          'status.compressing': 'Comprimiendo (mismas dimensiones)...',
          'status.upscaling': 'Mejorando resolucion...',
          'status.cropProcessing': 'Procesando recorte...',
          'status.doneDownload': 'Listo. Descarga iniciada.',
          'status.cropDone': 'Recorte confirmado. Descarga iniciada.',
          'status.compressDone': 'Compresion lista. Descarga iniciada.',
          'status.upscaleDone': 'Mejora lista. Descarga iniciada.',
          'status.previewIos': 'Vista previa abierta. En iPhone, toca Share y luego Save Image.',
          'status.imageLoaded': 'Imagen cargada. Ajusta y confirma el recorte.',
          'status.loadFailed': 'No se pudo cargar la imagen.',
          'status.cropReset': 'Caja de recorte reiniciada.',
          'status.cropCanvasPrompt': 'Sube una imagen para recortar',
          'error.notSupported': 'La exportacion {format} no es compatible con este navegador.',
          'error.resizeParams': 'Indica ancho y/o alto para redimensionar.',
          'error.convertFailed': 'Fallo al convertir.',
          'error.cropFailed': 'Fallo al recortar.',
          'error.compressFailed': 'Fallo al comprimir.',
          'error.upscaleFailed': 'Fallo al mejorar resolucion.',
          'ph.resizeWidth': 'p. ej. 800',
          'ph.resizeHeight': 'p. ej. 600'
        },
        zh: {
          'lang.label': '语言',
          'flow.upload': '1. 上传',
          'flow.adjust': '2. 调整',
          'flow.download': '3. 下载',
          'flow.privacy': '我们不会保存你的图片',
          'tab.convert': '转换',
          'tab.crop': '裁剪',
          'tab.compress': '压缩',
          'tab.upscale': '放大',
          'oss.prefix': '开源项目：',
          'oss.link': 'GitHub 仓库',
          'oss.suffix': '可部署你自己的版本。',
          'convert.title': '转换图片',
          'convert.subtitle': '在保证质量可控的情况下转换图片格式。',
          'crop.title': '裁剪图片',
          'crop.subtitle': '使用裁剪框选择区域，并可在裁剪后调整尺寸。',
          'compress.title': '压缩图片',
          'compress.subtitle': '在保持像素尺寸不变的前提下减小文件体积。',
          'upscale.title': '放大图片',
          'upscale.subtitle': '在你的设备上提高图片分辨率，采用实用且稳定的放大方式。',
          'field.imageFile': '图片文件',
          'field.outputFormat': '输出格式',
          'field.quality': '质量 (1-100)',
          'compress.quality': '压缩质量 (1-100)',
          'upscale.scale': '放大倍数',
          'upscale.quality': '输出质量 (1-100)',
          'upscale.restoreMode': '修复模式',
          'upscale.restore.balanced': '均衡',
          'upscale.restore.aggressive': '强力',
          'upscale.restore.logo': '文字/Logo',
          'upscale.restore.helpTitle': '该选哪种修复模式？',
          'upscale.restore.help.balanced': '适合大多数照片和混合内容，更稳妥。',
          'upscale.restore.help.aggressive': '更强去块和锐化，可能出现光晕或噪点。',
          'upscale.restore.help.logo': '优先强化硬边，适合 Logo、图标和文字形状。',
          'btn.convertDownload': '转换并下载',
          'btn.resetBox': '重置裁剪框',
          'btn.confirmCropDownload': '确认裁剪并下载',
          'btn.compressDownload': '压缩并下载',
          'btn.upscaleDownload': '放大并下载',
          'btn.continue': '继续',
          'btn.cancel': '取消',
          'crop.instructions': '在框内拖动可移动，拖动角点可调整大小。',
          'crop.aspectRatio': '宽高比',
          'crop.ratio.free': '自由',
          'crop.resizeAfter': '裁剪后调整尺寸',
          'crop.resizeExplain': '启用后，裁剪结果会按你填写的宽高等比缩小，不会拉伸。',
          'crop.resizeWidth': '宽度',
          'crop.resizeHeight': '高度',
          'compress.note': '压缩仅降低编码体积，不改变像素尺寸。',
          'upscale.note': '为保证速度与稳定性，超大输出会自动限制到安全尺寸。',
          'upscale.note2': '源图过小或过模糊时，结果仍可能偏软。首次运行会在浏览器下载更大的 ESRGAN 模型。',
          'upscale.note3': '首次运行预计下载数据：总计约 31 MB（模型 + AI 运行时），之后会被浏览器缓存。',
          'upscale.note4': '4x 会执行两次 AI 处理，因此会比 2x 慢很多。',
          'hero.convert.title': '免费图片转换器',
          'hero.convert.subtitle': '在浏览器中直接转换 JPG、PNG、WEBP、AVIF。',
          'hero.crop.title': '免费图片裁剪器',
          'hero.crop.subtitle': '拖拽并导出精确裁剪区域，支持可选缩放。',
          'hero.compress.title': '免费图片压缩器',
          'hero.compress.subtitle': '在保持尺寸的前提下减小文件体积。',
          'hero.upscale.title': '免费图片放大器',
          'hero.upscale.subtitle': 'AI Enhance 在你的设备上运行，支持 2x/4x 实用放大。',
          'seo.relatedPages': '相关页面',
          'status.chooseImage': '请先选择图片。',
          'status.uploadFirst': '请先上传图片。',
          'status.converting': '正在转换...',
          'status.compressing': '正在压缩（保持尺寸）...',
          'status.upscaling': '正在放大图片...',
          'status.cropProcessing': '正在处理裁剪...',
          'status.doneDownload': '完成，开始下载。',
          'status.cropDone': '裁剪完成，开始下载。',
          'status.compressDone': '压缩完成，开始下载。',
          'status.upscaleDone': '放大完成，开始下载。',
          'status.previewIos': '已打开预览。iPhone 上请点 Share 再点 Save Image。',
          'status.imageLoaded': '图片已加载，请调整后确认裁剪。',
          'status.loadFailed': '图片加载失败。',
          'status.cropReset': '裁剪框已重置。',
          'status.cropCanvasPrompt': '上传一张图片开始裁剪',
          'error.notSupported': '当前浏览器不支持导出 {format}。',
          'error.resizeParams': '请填写缩放宽度和/或高度。',
          'error.convertFailed': '转换失败。',
          'error.cropFailed': '裁剪失败。',
          'error.compressFailed': '压缩失败。',
          'error.upscaleFailed': '放大失败。',
          'ph.resizeWidth': '例如 800',
          'ph.resizeHeight': '例如 600'
        },
        hi: {
          'lang.label': 'भाषा',
          'flow.upload': '1. अपलोड',
          'flow.adjust': '2. एडजस्ट',
          'flow.download': '3. डाउनलोड',
          'flow.privacy': 'हम आपकी इमेज सेव नहीं करते',
          'tab.convert': 'कन्वर्ट',
          'tab.crop': 'क्रॉप',
          'tab.compress': 'कंप्रेस',
          'tab.upscale': 'अपस्केल',
          'oss.prefix': 'ओपन सोर्स:',
          'oss.link': 'GitHub रिपॉजिटरी',
          'oss.suffix': 'अपना वर्जन खुद डिप्लॉय करें।',
          'convert.title': 'इमेज कन्वर्ट करें',
          'convert.subtitle': 'क्वालिटी नियंत्रण के साथ फॉर्मेट बदलें।',
          'crop.title': 'इमेज क्रॉप करें',
          'crop.subtitle': 'क्रॉप बॉक्स से हिस्सा चुनें, फिर जरूरत हो तो रिसाइज़ करें।',
          'compress.title': 'इमेज कंप्रेस करें',
          'compress.subtitle': 'पिक्सेल साइज़ वही रखते हुए फाइल साइज़ कम करें।',
          'upscale.title': 'इमेज अपस्केल करें',
          'upscale.subtitle': 'व्यावहारिक स्केलिंग के साथ अपने डिवाइस पर इमेज रिजॉल्यूशन बढ़ाएं।',
          'field.imageFile': 'इमेज फाइल',
          'field.outputFormat': 'आउटपुट फॉर्मेट',
          'field.quality': 'क्वालिटी (1-100)',
          'compress.quality': 'कंप्रेशन क्वालिटी (1-100)',
          'upscale.scale': 'स्केल',
          'upscale.quality': 'आउटपुट क्वालिटी (1-100)',
          'upscale.restoreMode': 'रिस्टोर मोड',
          'upscale.restore.balanced': 'बैलेंस्ड',
          'upscale.restore.aggressive': 'एग्रेसिव',
          'upscale.restore.logo': 'टेक्स्ट/लोगो',
          'upscale.restore.helpTitle': 'कौन सा रिस्टोर मोड चुनें?',
          'upscale.restore.help.balanced': 'ज्यादातर फोटो और मिश्रित कंटेंट के लिए सुरक्षित डिफ़ॉल्ट।',
          'upscale.restore.help.aggressive': 'ज्यादा डीब्लॉक और शार्पन; हैलो/नॉइज़ आ सकते हैं।',
          'upscale.restore.help.logo': 'लोगो, आइकन और टेक्स्ट जैसी कठोर किनारों को प्राथमिकता देता है।',
          'btn.convertDownload': 'कन्वर्ट और डाउनलोड',
          'btn.resetBox': 'बॉक्स रीसेट करें',
          'btn.confirmCropDownload': 'क्रॉप कन्फर्म और डाउनलोड',
          'btn.compressDownload': 'कंप्रेस और डाउनलोड',
          'btn.upscaleDownload': 'अपस्केल और डाउनलोड',
          'btn.continue': 'जारी रखें',
          'btn.cancel': 'रद्द करें',
          'crop.instructions': 'बॉक्स के अंदर ड्रैग करके मूव करें। कोनों से साइज़ बदलें।',
          'crop.aspectRatio': 'आस्पेक्ट रेशियो',
          'crop.ratio.free': 'फ्री',
          'crop.resizeAfter': 'क्रॉप के बाद रिसाइज़',
          'crop.resizeExplain': 'चालू करने पर, क्रॉप की गई इमेज दी गई चौड़ाई/ऊंचाई में बिना खिंचे फिट होगी।',
          'crop.resizeWidth': 'चौड़ाई',
          'crop.resizeHeight': 'ऊंचाई',
          'compress.note': 'कंप्रेस करने पर पिक्सेल डायमेंशन वही रहते हैं।',
          'upscale.note': 'स्पीड और स्थिरता के लिए बहुत बड़े आउटपुट अपने आप सुरक्षित सीमा तक सीमित हो सकते हैं।',
          'upscale.note2': 'बहुत धुंधली या बहुत छोटी इमेज में परिणाम फिर भी सॉफ्ट रह सकते हैं। पहली बार चलाने पर ब्राउज़र में बड़ा ESRGAN मॉडल डाउनलोड होता है।',
          'upscale.note3': 'पहली बार अनुमानित डेटा उपयोग: कुल लगभग 31 MB (मॉडल + AI रनटाइम), बाद में यह ब्राउज़र में कैश हो जाता है।',
          'upscale.note4': '4x में AI के दो पास चलते हैं, इसलिए यह 2x से काफी धीमा है।',
          'hero.convert.title': 'फ्री इमेज कन्वर्टर',
          'hero.convert.subtitle': 'JPG, PNG, WEBP और AVIF सीधे ब्राउज़र में कन्वर्ट करें।',
          'hero.crop.title': 'फ्री इमेज क्रॉपर',
          'hero.crop.subtitle': 'ड्रैग करें, आकार बदलें और सटीक क्रॉप एरिया एक्सपोर्ट करें।',
          'hero.compress.title': 'फ्री इमेज कंप्रेसर',
          'hero.compress.subtitle': 'डायमेंशन वही रखते हुए फाइल साइज़ घटाएं।',
          'hero.upscale.title': 'फ्री इमेज अपस्केलर',
          'hero.upscale.subtitle': 'AI Enhance आपके डिवाइस पर 2x/4x अपस्केल चलाता है।',
          'seo.relatedPages': 'संबंधित पेज',
          'status.chooseImage': 'पहले एक इमेज चुनें।',
          'status.uploadFirst': 'पहले एक इमेज अपलोड करें।',
          'status.converting': 'कन्वर्ट हो रहा है...',
          'status.compressing': 'कंप्रेस हो रहा है (वही डायमेंशन)...',
          'status.upscaling': 'इमेज अपस्केल हो रही है...',
          'status.cropProcessing': 'क्रॉप प्रोसेस हो रहा है...',
          'status.doneDownload': 'हो गया। डाउनलोड शुरू हुआ।',
          'status.cropDone': 'क्रॉप पूरा। डाउनलोड शुरू हुआ।',
          'status.compressDone': 'कंप्रेशन पूरा। डाउनलोड शुरू हुआ।',
          'status.upscaleDone': 'अपस्केल पूरा। डाउनलोड शुरू हुआ।',
          'status.previewIos': 'प्रिव्यू खुल गया। iPhone पर Share दबाएं, फिर Save Image करें।',
          'status.imageLoaded': 'इमेज लोड हो गई। क्रॉप एडजस्ट करके कन्फर्म करें।',
          'status.loadFailed': 'इमेज लोड नहीं हुई।',
          'status.cropReset': 'क्रॉप बॉक्स रीसेट हो गया।',
          'status.cropCanvasPrompt': 'क्रॉप करने के लिए इमेज अपलोड करें',
          'error.notSupported': 'इस ब्राउज़र में {format} एक्सपोर्ट सपोर्ट नहीं है।',
          'error.resizeParams': 'रिसाइज़ के लिए चौड़ाई और/या ऊंचाई दें।',
          'error.convertFailed': 'कन्वर्ट विफल।',
          'error.cropFailed': 'क्रॉप विफल।',
          'error.compressFailed': 'कंप्रेस विफल।',
          'error.upscaleFailed': 'अपस्केल विफल।',
          'ph.resizeWidth': 'जैसे 800',
          'ph.resizeHeight': 'जैसे 600'
        },
        ja: {
          'lang.label': '言語',
          'flow.upload': '1. アップロード',
          'flow.adjust': '2. 調整',
          'flow.download': '3. ダウンロード',
          'flow.privacy': '画像は保存しません',
          'tab.convert': '変換',
          'tab.crop': '切り抜き',
          'tab.compress': '圧縮',
          'tab.upscale': '拡大',
          'oss.prefix': 'オープンソース:',
          'oss.link': 'GitHub リポジトリ',
          'oss.suffix': '自分の版をデプロイできます。',
          'convert.title': '画像変換',
          'convert.subtitle': '画質を調整しながら画像形式を変換します。',
          'crop.title': '画像切り抜き',
          'crop.subtitle': '切り抜き範囲を選び、必要に応じてリサイズできます。',
          'compress.title': '画像圧縮',
          'compress.subtitle': 'ピクセル寸法を維持したまま容量を削減します。',
          'upscale.title': '画像拡大',
          'upscale.subtitle': 'AI Enhance で拡大時の見た目ディテールを改善します。',
          'field.imageFile': '画像ファイル',
          'field.outputFormat': '出力形式',
          'field.quality': '品質 (1-100)',
          'compress.quality': '圧縮品質 (1-100)',
          'upscale.scale': '倍率',
          'upscale.quality': '出力品質 (1-100)',
          'upscale.restoreMode': '復元モード',
          'upscale.restore.balanced': 'バランス',
          'upscale.restore.aggressive': '強め',
          'upscale.restore.logo': '文字/ロゴ',
          'upscale.restore.helpTitle': 'どの復元モードを使うべきですか？',
          'upscale.restore.help.balanced': '写真や混在コンテンツ向けの安全な標準設定。',
          'upscale.restore.help.aggressive': 'ブロック除去とシャープ化を強めます。ハロー/ノイズが出る場合があります。',
          'upscale.restore.help.logo': 'ロゴ・アイコン・文字の硬い輪郭を優先します。',
          'btn.convertDownload': '変換してダウンロード',
          'btn.resetBox': '枠をリセット',
          'btn.confirmCropDownload': '切り抜いてダウンロード',
          'btn.compressDownload': '圧縮してダウンロード',
          'btn.upscaleDownload': '拡大してダウンロード',
          'btn.continue': '続行',
          'btn.cancel': 'キャンセル',
          'compress.note': '圧縮はピクセル寸法を変えず、容量のみを減らします。',
          'upscale.note': 'AI Enhance は見た目を改善しますが、失われた情報を完全復元することはできません。',
          'upscale.note2': '元画像が非常に小さい/ぼやけている場合、結果も柔らかいままになることがあります。',
          'upscale.note3': '初回ダウンロード目安: 約31MB（モデル + AIランタイム）。以後はブラウザにキャッシュされます。',
          'upscale.note4': '4x は AI を2パス実行するため、2x よりかなり遅くなります。',
          'hero.convert.title': '無料画像コンバーター',
          'hero.convert.subtitle': 'JPG/PNG/WEBP/AVIF をブラウザで変換。',
          'hero.crop.title': '無料画像クロッパー',
          'hero.crop.subtitle': 'ドラッグで正確に切り抜き、必要ならリサイズ。',
          'hero.compress.title': '無料画像圧縮',
          'hero.compress.subtitle': '寸法を維持したまま容量を小さくします。',
          'hero.upscale.title': '無料画像アップスケーラー',
          'hero.upscale.subtitle': 'AI Enhance が端末上で 2x/4x 拡大を実行します。',
          'seo.relatedPages': '関連ページ',
          'status.chooseImage': '先に画像を選択してください。',
          'status.uploadFirst': '先に画像をアップロードしてください。',
          'status.converting': '変換中...',
          'status.compressing': '圧縮中（同じ寸法）...',
          'status.upscaling': '拡大中...',
          'status.cropProcessing': '切り抜き処理中...',
          'status.doneDownload': '完了。ダウンロードを開始しました。',
          'status.cropDone': '切り抜き完了。ダウンロードを開始しました。',
          'status.compressDone': '圧縮完了。ダウンロードを開始しました。',
          'status.upscaleDone': '拡大完了。ダウンロードを開始しました。',
          'status.cancelled': 'キャンセルしました。',
          'status.previewIos': 'プレビューを開きました。iPhone では Share から Save Image を選んでください。',
          'error.notSupported': 'このブラウザでは {format} の出力に対応していません。',
          'error.convertFailed': '変換に失敗しました。',
          'error.cropFailed': '切り抜きに失敗しました。',
          'error.compressFailed': '圧縮に失敗しました。',
          'error.upscaleFailed': '拡大に失敗しました。',
          'ph.resizeWidth': '例 800',
          'ph.resizeHeight': '例 600'
        },
        ko: {
          'lang.label': '언어',
          'flow.upload': '1. 업로드',
          'flow.adjust': '2. 조정',
          'flow.download': '3. 다운로드',
          'flow.privacy': '이미지는 저장하지 않습니다',
          'tab.convert': '변환',
          'tab.crop': '자르기',
          'tab.compress': '압축',
          'tab.upscale': '업스케일',
          'oss.prefix': '오픈소스:',
          'oss.link': 'GitHub 저장소',
          'oss.suffix': '직접 배포할 수 있습니다.',
          'convert.title': '이미지 변환',
          'convert.subtitle': '품질을 조절하며 이미지 형식을 변환합니다.',
          'crop.title': '이미지 자르기',
          'crop.subtitle': '자르기 영역을 선택하고 필요하면 크기를 조정하세요.',
          'compress.title': '이미지 압축',
          'compress.subtitle': '픽셀 크기를 유지한 채 용량을 줄입니다.',
          'upscale.title': '이미지 업스케일',
          'upscale.subtitle': 'AI Enhance로 확대 시 디테일 표현을 개선합니다.',
          'field.imageFile': '이미지 파일',
          'field.outputFormat': '출력 형식',
          'field.quality': '품질 (1-100)',
          'compress.quality': '압축 품질 (1-100)',
          'upscale.scale': '배율',
          'upscale.quality': '출력 품질 (1-100)',
          'upscale.restoreMode': '복원 모드',
          'upscale.restore.balanced': '균형',
          'upscale.restore.aggressive': '강하게',
          'upscale.restore.logo': '텍스트/로고',
          'upscale.restore.helpTitle': '어떤 복원 모드를 써야 하나요?',
          'upscale.restore.help.balanced': '대부분의 사진/혼합 콘텐츠에 안전한 기본값입니다.',
          'upscale.restore.help.aggressive': '블록 제거와 선명화를 강하게 적용합니다. 할로/노이즈가 생길 수 있습니다.',
          'upscale.restore.help.logo': '로고, 아이콘, 텍스트의 또렷한 경계를 우선합니다.',
          'btn.convertDownload': '변환 후 다운로드',
          'btn.resetBox': '박스 초기화',
          'btn.confirmCropDownload': '자르고 다운로드',
          'btn.compressDownload': '압축 후 다운로드',
          'btn.upscaleDownload': '업스케일 후 다운로드',
          'btn.continue': '계속',
          'btn.cancel': '취소',
          'compress.note': '압축은 픽셀 크기를 유지하고 용량만 줄입니다.',
          'upscale.note': 'AI Enhance는 시각적 품질을 개선하지만, 손실된 정보를 완전히 복원하진 못합니다.',
          'upscale.note2': '원본이 매우 작거나 흐리면 결과도 부드럽게 보일 수 있습니다.',
          'upscale.note3': '첫 실행 예상 다운로드: 약 31MB(모델 + AI 런타임), 이후 브라우저에 캐시됩니다.',
          'upscale.note4': '4x는 AI를 2회 실행하므로 2x보다 훨씬 느립니다.',
          'hero.convert.title': '무료 이미지 변환기',
          'hero.convert.subtitle': 'JPG/PNG/WEBP/AVIF를 브라우저에서 바로 변환.',
          'hero.crop.title': '무료 이미지 크롭',
          'hero.crop.subtitle': '드래그로 정확히 자르고 필요 시 리사이즈.',
          'hero.compress.title': '무료 이미지 압축',
          'hero.compress.subtitle': '크기는 유지하고 파일 용량을 줄입니다.',
          'hero.upscale.title': '무료 이미지 업스케일러',
          'hero.upscale.subtitle': 'AI Enhance가 기기에서 2x/4x 업스케일을 실행합니다.',
          'seo.relatedPages': '관련 페이지',
          'status.chooseImage': '먼저 이미지를 선택하세요.',
          'status.uploadFirst': '먼저 이미지를 업로드하세요.',
          'status.converting': '변환 중...',
          'status.compressing': '압축 중(동일 크기)...',
          'status.upscaling': '업스케일 중...',
          'status.cropProcessing': '크롭 처리 중...',
          'status.doneDownload': '완료되었습니다. 다운로드를 시작했습니다.',
          'status.cropDone': '크롭 완료. 다운로드를 시작했습니다.',
          'status.compressDone': '압축 완료. 다운로드를 시작했습니다.',
          'status.upscaleDone': '업스케일 완료. 다운로드를 시작했습니다.',
          'status.cancelled': '취소되었습니다.',
          'status.previewIos': '미리보기가 열렸습니다. iPhone에서는 Share 후 Save Image를 선택하세요.',
          'error.notSupported': '이 브라우저는 {format} 내보내기를 지원하지 않습니다.',
          'error.convertFailed': '변환 실패.',
          'error.cropFailed': '크롭 실패.',
          'error.compressFailed': '압축 실패.',
          'error.upscaleFailed': '업스케일 실패.',
          'ph.resizeWidth': '예: 800',
          'ph.resizeHeight': '예: 600'
        },
        ar: {
          'lang.label': 'اللغة',
          'flow.upload': '1. رفع',
          'flow.adjust': '2. تعديل',
          'flow.download': '3. تنزيل',
          'flow.privacy': 'نحن لا نحفظ صورك',
          'tab.convert': 'تحويل',
          'tab.crop': 'قص',
          'tab.compress': 'ضغط',
          'tab.upscale': 'تكبير',
          'oss.prefix': 'مفتوح المصدر:',
          'oss.link': 'مستودع GitHub',
          'oss.suffix': 'انشر نسختك الخاصة.',
          'convert.title': 'تحويل الصور',
          'convert.subtitle': 'غيّر صيغة الصورة مع التحكم في الجودة.',
          'crop.title': 'قص الصور',
          'crop.subtitle': 'استخدم إطار القص لتحديد الجزء المطلوب ثم غيّر الحجم اختياريًا.',
          'compress.title': 'ضغط الصور',
          'compress.subtitle': 'قلّل حجم الملف مع الحفاظ على نفس الأبعاد.',
          'upscale.title': 'تكبير الصور',
          'upscale.subtitle': 'زِد دقة الصورة على جهازك باستخدام تكبير عملي ومستقر.',
          'field.imageFile': 'ملف الصورة',
          'field.outputFormat': 'صيغة الإخراج',
          'field.quality': 'الجودة (1-100)',
          'compress.quality': 'جودة الضغط (1-100)',
          'upscale.scale': 'مقدار التكبير',
          'upscale.quality': 'جودة الإخراج (1-100)',
          'upscale.restoreMode': 'وضع الاستعادة',
          'upscale.restore.balanced': 'متوازن',
          'upscale.restore.aggressive': 'قوي',
          'upscale.restore.logo': 'نص/شعار',
          'upscale.restore.helpTitle': 'ما وضع الاستعادة المناسب؟',
          'upscale.restore.help.balanced': 'الخيار الأكثر أمانًا لمعظم الصور والمحتوى المختلط.',
          'upscale.restore.help.aggressive': 'إزالة ضغط وحدّة أقوى، وقد تظهر هالات/ضجيج.',
          'upscale.restore.help.logo': 'يركّز على الحواف الصلبة للشعارات والأيقونات وأشكال النص.',
          'btn.convertDownload': 'تحويل وتنزيل',
          'btn.resetBox': 'إعادة ضبط الإطار',
          'btn.confirmCropDownload': 'تأكيد القص والتنزيل',
          'btn.compressDownload': 'ضغط وتنزيل',
          'btn.upscaleDownload': 'تكبير وتنزيل',
          'btn.continue': 'متابعة',
          'btn.cancel': 'إلغاء',
          'crop.instructions': 'اسحب داخل الإطار للتحريك واسحب الزوايا لتغيير الحجم.',
          'crop.aspectRatio': 'نسبة الأبعاد',
          'crop.ratio.free': 'حر',
          'crop.resizeAfter': 'تغيير الحجم بعد القص',
          'crop.resizeExplain': 'عند التفعيل، يتم تصغير الصورة المقصوصة لتناسب العرض/الارتفاع بدون تمدد.',
          'crop.resizeWidth': 'العرض',
          'crop.resizeHeight': 'الارتفاع',
          'compress.note': 'الضغط يحافظ على نفس أبعاد البكسل.',
          'upscale.note': 'للحفاظ على السرعة والاستقرار، قد يتم تقليل المخرجات الكبيرة جدًا تلقائيًا إلى أبعاد آمنة.',
          'upscale.note2': 'قد تبقى الصور الصغيرة جدًا أو الضبابية ناعمة حتى بعد المعالجة. في أول تشغيل يتم تنزيل نموذج ESRGAN أكبر داخل المتصفح.',
          'upscale.note3': 'استهلاك البيانات المتوقع لأول تشغيل: حوالي 31 ميجابايت إجمالًا (النموذج + وقت تشغيل الذكاء الاصطناعي)، ثم يتم حفظه في ذاكرة المتصفح المؤقتة.',
          'upscale.note4': 'وضع 4x يشغّل مرحلتين من الذكاء الاصطناعي، لذلك يكون أبطأ بكثير من 2x.',
          'hero.convert.title': 'محول صور مجاني',
          'hero.convert.subtitle': 'حوّل JPG وPNG وWEBP وAVIF مباشرة داخل المتصفح.',
          'hero.crop.title': 'أداة قص صور مجانية',
          'hero.crop.subtitle': 'اسحب وغيّر الحجم وصدّر منطقة قص دقيقة مع تغيير حجم اختياري.',
          'hero.compress.title': 'ضاغط صور مجاني',
          'hero.compress.subtitle': 'قلّل حجم الملف مع الحفاظ على الأبعاد.',
          'hero.upscale.title': 'مكبر صور مجاني',
          'hero.upscale.subtitle': 'يعمل AI Enhance على جهازك للتكبير 2x أو 4x بحدود عملية.',
          'seo.relatedPages': 'صفحات ذات صلة',
          'status.chooseImage': 'اختر صورة أولاً.',
          'status.uploadFirst': 'ارفع صورة أولاً.',
          'status.converting': 'جارٍ التحويل...',
          'status.compressing': 'جارٍ الضغط (نفس الأبعاد)...',
          'status.upscaling': 'جارٍ تكبير الصورة...',
          'status.cropProcessing': 'جارٍ معالجة القص...',
          'status.doneDownload': 'تم. بدأ التنزيل.',
          'status.cropDone': 'تم القص. بدأ التنزيل.',
          'status.compressDone': 'تم الضغط. بدأ التنزيل.',
          'status.upscaleDone': 'تم التكبير. بدأ التنزيل.',
          'status.previewIos': 'تم فتح المعاينة. في iPhone اضغط Share ثم Save Image.',
          'status.imageLoaded': 'تم تحميل الصورة. عدّل القص ثم أكّد.',
          'status.loadFailed': 'فشل تحميل الصورة.',
          'status.cropReset': 'تمت إعادة ضبط إطار القص.',
          'status.cropCanvasPrompt': 'ارفع صورة للقص',
          'error.notSupported': 'تصدير {format} غير مدعوم في هذا المتصفح.',
          'error.resizeParams': 'أدخل عرضًا و/أو ارتفاعًا لتغيير الحجم.',
          'error.convertFailed': 'فشل التحويل.',
          'error.cropFailed': 'فشل القص.',
          'error.compressFailed': 'فشل الضغط.',
          'error.upscaleFailed': 'فشل التكبير.',
          'ph.resizeWidth': 'مثال 800',
          'ph.resizeHeight': 'مثال 600'
        }
      };

      function t(key, vars) {
        const dict = i18n[locale] || i18n.en;
        let text = dict[key] || i18n.en[key] || key;
        if (vars) {
          Object.entries(vars).forEach(([name, value]) => {
            text = text.replace(`{${name}}`, value);
          });
        }
        return text;
      }

      function applyTranslations() {
        document.querySelectorAll('[data-i18n]').forEach((el) => {
          const key = el.getAttribute('data-i18n');
          el.textContent = t(key);
        });
        document.getElementById('cropResizeWidth').placeholder = t('ph.resizeWidth');
        document.getElementById('cropResizeHeight').placeholder = t('ph.resizeHeight');
      }

      function localePathFor(basePath, targetLocale) {
        const cleanBase = !basePath || basePath === '/' ? '' : basePath;
        return `/${targetLocale}${cleanBase}`;
      }

      function updateHeroForTab(tab) {
        const titleEl = document.getElementById('heroTitle');
        const subtitleEl = document.getElementById('heroSubtitle');
        if (!titleEl || !subtitleEl) return;
        titleEl.textContent = t(`hero.${tab}.title`);
        subtitleEl.textContent = t(`hero.${tab}.subtitle`);
      }

      applyTranslations();

      const languageSelect = document.getElementById('languageSelect');
      languageSelect.addEventListener('change', () => {
        const targetLocale = languageSelect.value;
        const basePath = pageConfig.basePath || '/';
        document.cookie = `lang=${targetLocale}; Path=/; Max-Age=31536000; SameSite=Lax`;
        window.location.href = localePathFor(basePath, targetLocale);
      });

      const tabButtons = Array.from(document.querySelectorAll('.tab-btn'));
      const isCoarsePointer = window.matchMedia && window.matchMedia('(pointer: coarse)').matches;
      const panels = {
        convert: document.getElementById('panel-convert'),
        crop: document.getElementById('panel-crop'),
        compress: document.getElementById('panel-compress'),
        upscale: document.getElementById('panel-upscale')
      };
      const tabToPath = {
        convert: localePathFor('/convert', locale),
        crop: localePathFor('/crop', locale),
        compress: localePathFor('/compress', locale),
        upscale: localePathFor('/upscale', locale)
      };

      function setStatus(el, message, type) {
        el.textContent = message;
        el.className = `status${type ? ` ${type}` : ''}`;
      }

      function toQuality(value, fallback) {
        const n = Number(value);
        if (!Number.isFinite(n)) return fallback;
        return Math.max(0.01, Math.min(1, n / 100));
      }

      function extForFormat(format) {
        return format === 'jpeg' ? 'jpg' : format;
      }

      async function base64ToImage(src) {
        const img = new Image();
        await new Promise((resolve, reject) => {
          img.onload = resolve;
          img.onerror = reject;
          img.src = src;
        });
        return img;
      }

      function canvasToImage(canvas) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = reject;
          img.src = canvas.toDataURL('image/png');
        });
      }

      function drawImageToCanvas(img, width, height) {
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        ctx.drawImage(img, 0, 0, width, height);
        return canvas;
      }

      function drawResampled(canvas, ratio) {
        const srcW = canvas.width;
        const srcH = canvas.height;
        const downW = Math.max(1, Math.round(srcW * ratio));
        const downH = Math.max(1, Math.round(srcH * ratio));
        const down = document.createElement('canvas');
        down.width = downW;
        down.height = downH;
        const dctx = down.getContext('2d');
        dctx.imageSmoothingEnabled = true;
        dctx.imageSmoothingQuality = 'high';
        dctx.drawImage(canvas, 0, 0, downW, downH);

        const out = document.createElement('canvas');
        out.width = srcW;
        out.height = srcH;
        const octx = out.getContext('2d');
        octx.imageSmoothingEnabled = true;
        octx.imageSmoothingQuality = 'high';
        octx.drawImage(down, 0, 0, srcW, srcH);
        return out;
      }

      async function yieldToBrowser() {
        if (typeof requestAnimationFrame === 'function') {
          await new Promise((resolve) => requestAnimationFrame(() => resolve()));
          return;
        }
        await new Promise((resolve) => setTimeout(resolve, 0));
      }

      function estimateBlockiness(canvas) {
        const w = canvas.width;
        const h = canvas.height;
        if (w < 16 || h < 16) return 0;
        const ctx = canvas.getContext('2d');
        const data = ctx.getImageData(0, 0, w, h).data;
        let verticalDiff = 0;
        let verticalCount = 0;
        let horizontalDiff = 0;
        let horizontalCount = 0;
        const step = 2;

        for (let x = 8; x < w; x += 8) {
          for (let y = 0; y < h; y += step) {
            const a = (y * w + (x - 1)) * 4;
            const b = (y * w + x) * 4;
            const ya = data[a] * 0.299 + data[a + 1] * 0.587 + data[a + 2] * 0.114;
            const yb = data[b] * 0.299 + data[b + 1] * 0.587 + data[b + 2] * 0.114;
            verticalDiff += Math.abs(ya - yb);
            verticalCount += 1;
          }
        }

        for (let y = 8; y < h; y += 8) {
          for (let x = 0; x < w; x += step) {
            const a = ((y - 1) * w + x) * 4;
            const b = (y * w + x) * 4;
            const ya = data[a] * 0.299 + data[a + 1] * 0.587 + data[a + 2] * 0.114;
            const yb = data[b] * 0.299 + data[b + 1] * 0.587 + data[b + 2] * 0.114;
            horizontalDiff += Math.abs(ya - yb);
            horizontalCount += 1;
          }
        }

        const v = verticalCount ? verticalDiff / verticalCount : 0;
        const hAvg = horizontalCount ? horizontalDiff / horizontalCount : 0;
        return (v + hAvg) * 0.5;
      }

      async function applySharpenKernel(canvas, amount, options = {}) {
        const w = canvas.width;
        const h = canvas.height;
        const ctx = canvas.getContext('2d');
        const src = ctx.getImageData(0, 0, w, h);
        const dst = ctx.createImageData(w, h);
        const s = src.data;
        const d = dst.data;
        const a = amount;
        const center = 1 + 4 * a;
        const side = -a;
        const chunkRows = Math.max(16, Math.min(96, Number(options.chunkRows) || 48));
        const onProgress = typeof options.onProgress === 'function' ? options.onProgress : null;

        for (let yStart = 0; yStart < h; yStart += chunkRows) {
          const yEnd = Math.min(h, yStart + chunkRows);
          for (let y = yStart; y < yEnd; y += 1) {
            for (let x = 0; x < w; x += 1) {
              const idx = (y * w + x) * 4;
              for (let c = 0; c < 3; c += 1) {
                const upY = Math.max(0, y - 1);
                const dnY = Math.min(h - 1, y + 1);
                const lfX = Math.max(0, x - 1);
                const rtX = Math.min(w - 1, x + 1);
                const centerV = s[idx + c] * center;
                const up = s[(upY * w + x) * 4 + c] * side;
                const down = s[(dnY * w + x) * 4 + c] * side;
                const left = s[(y * w + lfX) * 4 + c] * side;
                const right = s[(y * w + rtX) * 4 + c] * side;
                const out = Math.max(0, Math.min(255, centerV + up + down + left + right));
                d[idx + c] = out;
              }
              d[idx + 3] = s[idx + 3];
            }
          }
          if (onProgress) onProgress(yEnd / h);
          await yieldToBrowser();
        }
        ctx.putImageData(dst, 0, 0);
      }

      async function preprocessForRestore(img, mode, onProgress) {
        const report = typeof onProgress === 'function' ? onProgress : () => {};
        report(0.04);
        const base = drawImageToCanvas(img, img.width, img.height);
        const ctx = base.getContext('2d');
        await yieldToBrowser();

        const blockiness = estimateBlockiness(base);

        // Deblock: slight down/up sampling smooths JPEG block boundaries.
        let ratio = mode === 'aggressive' ? 0.88 : mode === 'logo' ? 0.93 : 0.9;
        if (blockiness > 14) ratio -= 0.02;
        if (blockiness > 22) ratio -= 0.02;
        ratio = Math.max(0.84, Math.min(0.95, ratio));
        const deblocked = drawResampled(base, ratio);
        report(0.38);
        await yieldToBrowser();

        // Denoise lightly using blur on top of deblocked image.
        ctx.clearRect(0, 0, base.width, base.height);
        const blockBoost = blockiness > 22 ? 0.2 : blockiness > 14 ? 0.1 : 0;
        const blur = mode === 'aggressive' ? 0.8 : mode === 'logo' ? 0.3 : 0.5;
        const contrast = mode === 'aggressive' ? 1.04 : mode === 'logo' ? 1.06 : 1.03;
        ctx.filter = `blur(${(blur + blockBoost).toFixed(2)}px) contrast(${contrast})`;
        ctx.drawImage(deblocked, 0, 0);
        ctx.filter = 'none';
        report(0.6);
        await yieldToBrowser();

        // Edge recovery before AI.
        const preSharpen = mode === 'aggressive' ? 0.35 : mode === 'logo' ? 0.5 : 0.22;
        await applySharpenKernel(base, preSharpen, {
          chunkRows: 40,
          onProgress: (p) => report(0.6 + p * 0.4)
        });
        report(1);
        return base;
      }

      async function postprocessAfterRestore(img, mode, onProgress) {
        const report = typeof onProgress === 'function' ? onProgress : () => {};
        const canvas = drawImageToCanvas(img, img.width, img.height);
        const ctx = canvas.getContext('2d');
        const source = drawImageToCanvas(canvas, canvas.width, canvas.height);
        report(0.2);
        await yieldToBrowser();
        ctx.filter = mode === 'aggressive' ? 'contrast(1.05) saturate(1.03)' : mode === 'logo' ? 'contrast(1.12) saturate(1.02)' : 'contrast(1.03) saturate(1.02)';
        ctx.drawImage(source, 0, 0);
        ctx.filter = 'none';
        report(0.45);
        await yieldToBrowser();

        const postSharpen = mode === 'aggressive' ? 0.5 : mode === 'logo' ? 0.75 : 0.32;
        await applySharpenKernel(canvas, postSharpen, {
          chunkRows: 48,
          onProgress: (p) => report(0.45 + p * 0.55)
        });
        report(1);
        return canvas;
      }

      function isIOSLike() {
        const ua = navigator.userAgent || '';
        return /iPad|iPhone|iPod/.test(ua) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
      }

      async function downloadBlob(blob, filename) {
        const url = URL.createObjectURL(blob);
        if (isIOSLike()) {
          const opened = window.open(url, '_blank');
          if (!opened) {
            window.location.href = url;
          }
          setTimeout(() => URL.revokeObjectURL(url), 60000);
          return 'ios-preview';
        }

        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        link.remove();
        URL.revokeObjectURL(url);
        return 'downloaded';
      }

      function canEncode(mimeType) {
        const c = document.createElement('canvas');
        const out = c.toDataURL(mimeType);
        return out.startsWith(`data:${mimeType}`);
      }

      async function fileToImage(file) {
        const url = URL.createObjectURL(file);
        try {
          const img = new Image();
          await new Promise((resolve, reject) => {
            img.onload = resolve;
            img.onerror = reject;
            img.src = url;
          });
          return img;
        } finally {
          URL.revokeObjectURL(url);
        }
      }

      async function renderToBlob(img, mimeType, quality, sx, sy, sw, sh, dw, dh) {
        const canvas = document.createElement('canvas');
        canvas.width = dw;
        canvas.height = dh;
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        ctx.drawImage(img, sx, sy, sw, sh, 0, 0, dw, dh);
        return new Promise((resolve) => canvas.toBlob(resolve, mimeType, quality));
      }

      function setActiveTab(tab, shouldUpdateUrl = false) {
        tabButtons.forEach((b) => b.classList.toggle('active', b.dataset.tab === tab));
        Object.entries(panels).forEach(([name, panel]) => {
          panel.classList.toggle('active', name === tab);
        });
        updateHeroForTab(tab);

        if (shouldUpdateUrl && tabToPath[tab]) {
          history.replaceState(null, '', tabToPath[tab]);
        }
      }

      tabButtons.forEach((btn) => {
        btn.addEventListener('click', () => {
          setActiveTab(btn.dataset.tab, true);
        });
      });

      setActiveTab(pageConfig.activeTab || 'convert', false);

      if (pageConfig.convertFormat) {
        document.getElementById('convertFormat').value = pageConfig.convertFormat;
      }
      if (typeof pageConfig.convertQuality === 'number') {
        document.getElementById('convertQuality').value = String(pageConfig.convertQuality);
      }
      if (pageConfig.compressFormat) {
        document.getElementById('compressFormat').value = pageConfig.compressFormat;
      }
      if (typeof pageConfig.compressQuality === 'number') {
        document.getElementById('compressQuality').value = String(pageConfig.compressQuality);
      }
      if (pageConfig.upscaleFormat) {
        document.getElementById('upscaleFormat').value = pageConfig.upscaleFormat;
      }
      if (typeof pageConfig.upscaleQuality === 'number') {
        document.getElementById('upscaleQuality').value = String(pageConfig.upscaleQuality);
      }
      if (typeof pageConfig.upscaleScale === 'number') {
        document.getElementById('upscaleScale').value = String(pageConfig.upscaleScale);
      }
      if (!['2', '4'].includes(document.getElementById('upscaleScale').value)) {
        document.getElementById('upscaleScale').value = '2';
      }

      // Convert tab
      document.getElementById('convertBtn').addEventListener('click', async () => {
        const fileInput = document.getElementById('convertImage');
        const statusEl = document.getElementById('convertStatus');
        if (!fileInput.files || fileInput.files.length === 0) {
          setStatus(statusEl, t('status.chooseImage'), 'error');
          return;
        }

        const file = fileInput.files[0];
        const format = document.getElementById('convertFormat').value;
        const mimeType = `image/${format}`;

        if (!canEncode(mimeType)) {
          setStatus(statusEl, t('error.notSupported', { format: format.toUpperCase() }), 'error');
          return;
        }

        setStatus(statusEl, t('status.converting'));
        try {
          const quality = toQuality(document.getElementById('convertQuality').value, 0.9);
          const img = await fileToImage(file);
          const blob = await renderToBlob(img, mimeType, quality, 0, 0, img.width, img.height, img.width, img.height);
          if (!blob) throw new Error('Failed to convert image.');
          const base = file.name.replace(/\.[^.]+$/, '') || 'image';
          const mode = await downloadBlob(blob, `${base}-converted.${extForFormat(format)}`);
          setStatus(
            statusEl,
            mode === 'ios-preview' ? t('status.previewIos') : t('status.doneDownload'),
            'ok'
          );
        } catch (err) {
          setStatus(statusEl, err.message || t('error.convertFailed'), 'error');
        }
      });

      // Crop tab
      const cropCanvas = document.getElementById('cropCanvas');
      const cropCtx = cropCanvas.getContext('2d');
      const cropStatus = document.getElementById('cropStatus');
      const cropImageInput = document.getElementById('cropImage');
      const cropCanvasWrap = cropCanvas.parentElement;

      const cropState = {
        img: null,
        aspectRatio: null,
        scale: 1,
        offsetX: 0,
        offsetY: 0,
        box: { x: 80, y: 60, w: 240, h: 180 },
        mode: null,
        handle: null,
        startX: 0,
        startY: 0,
        startBox: null
      };

      function parseAspectRatio(raw) {
        if (!raw || raw === 'free') return null;
        const parts = String(raw).split(':');
        if (parts.length !== 2) return null;
        const w = Number(parts[0]);
        const h = Number(parts[1]);
        if (!Number.isFinite(w) || !Number.isFinite(h) || w <= 0 || h <= 0) return null;
        return w / h;
      }

      function buildDefaultBox(img) {
        return {
          x: img.width * 0.1,
          y: img.height * 0.1,
          w: img.width * 0.8,
          h: img.height * 0.8
        };
      }

      function buildRatioBox(img, ratio) {
        const maxW = img.width * 0.9;
        const maxH = img.height * 0.9;
        let w = maxW;
        let h = w / ratio;
        if (h > maxH) {
          h = maxH;
          w = h * ratio;
        }
        return {
          x: (img.width - w) / 2,
          y: (img.height - h) / 2,
          w,
          h
        };
      }

      function applyCropPreset(preset) {
        if (!preset) return;
        const cropAspectRatio = document.getElementById('cropAspectRatio');
        if (!cropAspectRatio) return;
        if (preset === 'square') {
          cropAspectRatio.value = '1:1';
        } else if (preset === '16:9') {
          cropAspectRatio.value = '16:9';
        }
      }

      function setCropAspectRatio(value, fitToRatio = false) {
        cropState.aspectRatio = parseAspectRatio(value);
        if (!cropState.img) return;
        if (fitToRatio && cropState.aspectRatio) {
          cropState.box = buildRatioBox(cropState.img, cropState.aspectRatio);
          clampBoxToImage();
          drawCropCanvas();
        } else if (fitToRatio && !cropState.aspectRatio) {
          cropState.box = buildDefaultBox(cropState.img);
          clampBoxToImage();
          drawCropCanvas();
        }
      }

      function drawCropCanvas() {
        cropCtx.clearRect(0, 0, cropCanvas.width, cropCanvas.height);
        cropCtx.fillStyle = '#dfe9f8';
        cropCtx.fillRect(0, 0, cropCanvas.width, cropCanvas.height);

        if (!cropState.img) {
          cropCtx.fillStyle = '#4f678a';
          cropCtx.font = '16px Segoe UI';
          cropCtx.fillText(t('status.cropCanvasPrompt'), 24, 34);
          return;
        }

        const img = cropState.img;
        const scale = Math.min(cropCanvas.width / img.width, cropCanvas.height / img.height);
        const drawW = img.width * scale;
        const drawH = img.height * scale;
        const ox = (cropCanvas.width - drawW) / 2;
        const oy = (cropCanvas.height - drawH) / 2;

        cropState.scale = scale;
        cropState.offsetX = ox;
        cropState.offsetY = oy;

        cropCtx.drawImage(img, ox, oy, drawW, drawH);

        const b = cropState.box;
        const x = ox + b.x * scale;
        const y = oy + b.y * scale;
        const w = b.w * scale;
        const h = b.h * scale;

        // Shade only the outside area; keep the crop area as the original image.
        cropCtx.fillStyle = 'rgba(80,88,102,0.24)';
        cropCtx.fillRect(ox, oy, drawW, Math.max(0, y - oy)); // top
        cropCtx.fillRect(ox, y + h, drawW, Math.max(0, (oy + drawH) - (y + h))); // bottom
        cropCtx.fillRect(ox, y, Math.max(0, x - ox), h); // left
        cropCtx.fillRect(x + w, y, Math.max(0, (ox + drawW) - (x + w)), h); // right

        cropCtx.strokeStyle = '#0f62fe';
        cropCtx.lineWidth = isCoarsePointer ? 3 : 2;
        cropCtx.strokeRect(x, y, w, h);

        const hs = isCoarsePointer ? 11 : 6;
        const handles = [
          ['nw', x, y],
          ['ne', x + w, y],
          ['sw', x, y + h],
          ['se', x + w, y + h]
        ];
        if (!cropState.aspectRatio) {
          handles.push(['n', x + w / 2, y], ['s', x + w / 2, y + h], ['w', x, y + h / 2], ['e', x + w, y + h / 2]);
        }
        cropCtx.fillStyle = '#ffffff';
        cropCtx.strokeStyle = '#0f62fe';
        handles.forEach(([, hx, hy]) => {
          cropCtx.beginPath();
          cropCtx.rect(hx - hs, hy - hs, hs * 2, hs * 2);
          cropCtx.fill();
          cropCtx.stroke();
        });
      }

      function resizeCropCanvas(force = false) {
        if (!cropCanvasWrap) return false;
        const wrapWidth = Math.round(cropCanvasWrap.clientWidth || 860);
        const targetWidth = Math.max(280, wrapWidth);
        const isMobileViewport = window.matchMedia('(max-width: 760px)').matches;
        let targetHeight;

        if (isMobileViewport) {
          const viewportHeight =
            (window.visualViewport && window.visualViewport.height) ||
            window.innerHeight ||
            document.documentElement.clientHeight ||
            740;
          const preferredHeight = Math.round(viewportHeight * 0.46);
          const maxHeightByWidth = Math.round(targetWidth * 1.18);
          targetHeight = Math.max(260, Math.min(preferredHeight, maxHeightByWidth));
        } else {
          targetHeight = Math.round(targetWidth * (480 / 860));
          targetHeight = Math.max(420, Math.min(targetHeight, 620));
        }

        if (!force && cropCanvas.width === targetWidth && cropCanvas.height === targetHeight) return false;
        cropCanvas.width = targetWidth;
        cropCanvas.height = targetHeight;
        return true;
      }

      function clampBoxToImage() {
        if (!cropState.img) return;
        const img = cropState.img;
        const b = cropState.box;
        const ratio = cropState.aspectRatio;
        if (ratio) {
          let w = Math.max(20, b.w);
          let h = w / ratio;
          if (h < 20) {
            h = 20;
            w = h * ratio;
          }
          if (w > img.width) {
            w = img.width;
            h = w / ratio;
          }
          if (h > img.height) {
            h = img.height;
            w = h * ratio;
          }
          b.w = w;
          b.h = h;
        } else {
          b.w = Math.max(20, Math.min(b.w, img.width));
          b.h = Math.max(20, Math.min(b.h, img.height));
        }
        b.x = Math.max(0, Math.min(b.x, img.width - b.w));
        b.y = Math.max(0, Math.min(b.y, img.height - b.h));
      }

      function getPointer(e) {
        const rect = cropCanvas.getBoundingClientRect();
        const touch = e.touches && e.touches[0];
        const clientX = touch ? touch.clientX : e.clientX;
        const clientY = touch ? touch.clientY : e.clientY;

        // Canvas is often visually scaled down on mobile; convert CSS coords to canvas coords.
        const cssX = clientX - rect.left;
        const cssY = clientY - rect.top;
        const scaleX = rect.width > 0 ? cropCanvas.width / rect.width : 1;
        const scaleY = rect.height > 0 ? cropCanvas.height / rect.height : 1;
        return {
          x: cssX * scaleX,
          y: cssY * scaleY
        };
      }

      function canvasToImagePoint(point) {
        const img = cropState.img;
        if (!img) return { x: 0, y: 0 };
        const x = (point.x - cropState.offsetX) / cropState.scale;
        const y = (point.y - cropState.offsetY) / cropState.scale;
        return {
          x: Math.max(0, Math.min(img.width, x)),
          y: Math.max(0, Math.min(img.height, y))
        };
      }

      function hitTestHandle(px, py) {
        const b = cropState.box;
        const s = cropState.scale;
        const ox = cropState.offsetX;
        const oy = cropState.offsetY;
        const x = ox + b.x * s;
        const y = oy + b.y * s;
        const w = b.w * s;
        const h = b.h * s;
        const tol = isCoarsePointer ? 32 : 10;

        const points = {
          nw: { x, y },
          ne: { x: x + w, y },
          sw: { x, y: y + h },
          se: { x: x + w, y: y + h }
        };
        if (!cropState.aspectRatio) {
          points.n = { x: x + w / 2, y };
          points.s = { x: x + w / 2, y: y + h };
          points.w = { x, y: y + h / 2 };
          points.e = { x: x + w, y: y + h / 2 };
        }

        for (const [name, p] of Object.entries(points)) {
          if (Math.abs(px - p.x) <= tol && Math.abs(py - p.y) <= tol) return name;
        }

        if (px >= x && px <= x + w && py >= y && py <= y + h) return 'move';
        return null;
      }

      function onCropDown(e) {
        if (!cropState.img) return;
        e.preventDefault();
        const p = getPointer(e);
        const hit = hitTestHandle(p.x, p.y);
        if (!hit) {
          const ip = canvasToImagePoint(p);
          cropState.mode = 'new';
          cropState.handle = 'se';
          cropState.startX = p.x;
          cropState.startY = p.y;
          cropState.startBox = { ...cropState.box, startImgX: ip.x, startImgY: ip.y };
          cropState.box = { x: ip.x, y: ip.y, w: 20, h: 20 };
          clampBoxToImage();
          drawCropCanvas();
          return;
        }
        cropState.mode = hit === 'move' ? 'move' : 'resize';
        cropState.handle = hit;
        cropState.startX = p.x;
        cropState.startY = p.y;
        cropState.startBox = { ...cropState.box };
      }

      function onCropMove(e) {
        if (!cropState.img || !cropState.mode) return;
        e.preventDefault();
        const p = getPointer(e);
        const dx = (p.x - cropState.startX) / cropState.scale;
        const dy = (p.y - cropState.startY) / cropState.scale;
        const b = cropState.box;
        const s = cropState.startBox;

        if (cropState.mode === 'new') {
          const sp = {
            x: s.startImgX,
            y: s.startImgY
          };
          const ep = canvasToImagePoint(p);
          const ratio = cropState.aspectRatio;
          if (!ratio) {
            b.x = Math.min(sp.x, ep.x);
            b.y = Math.min(sp.y, ep.y);
            b.w = Math.max(20, Math.abs(ep.x - sp.x));
            b.h = Math.max(20, Math.abs(ep.y - sp.y));
          } else {
            const rawW = Math.abs(ep.x - sp.x);
            const rawH = Math.abs(ep.y - sp.y);
            const targetW = Math.max(20, Math.max(rawW, rawH * ratio));
            const targetH = targetW / ratio;
            b.w = targetW;
            b.h = targetH;
            b.x = ep.x >= sp.x ? sp.x : sp.x - targetW;
            b.y = ep.y >= sp.y ? sp.y : sp.y - targetH;
          }
        } else if (cropState.mode === 'move') {
          b.x = s.x + dx;
          b.y = s.y + dy;
        } else {
          const ratio = cropState.aspectRatio;
          if (!ratio) {
            const min = 20;
            if (cropState.handle.includes('n')) {
              b.y = s.y + dy;
              b.h = s.h - dy;
            }
            if (cropState.handle.includes('s')) {
              b.h = s.h + dy;
            }
            if (cropState.handle.includes('w')) {
              b.x = s.x + dx;
              b.w = s.w - dx;
            }
            if (cropState.handle.includes('e')) {
              b.w = s.w + dx;
            }

            if (b.w < min) {
              b.w = min;
              if (cropState.handle.includes('w')) b.x = s.x + (s.w - min);
            }
            if (b.h < min) {
              b.h = min;
              if (cropState.handle.includes('n')) b.y = s.y + (s.h - min);
            }
          } else {
            const horizontalDelta = cropState.handle.includes('e') ? dx : -dx;
            const verticalDelta = cropState.handle.includes('s') ? dy : -dy;
            const useHorizontal = Math.abs(horizontalDelta) >= Math.abs(verticalDelta * ratio);
            const nextW = useHorizontal ? s.w + horizontalDelta : s.w + verticalDelta * ratio;
            const targetW = Math.max(20, nextW);
            const targetH = targetW / ratio;

            b.w = targetW;
            b.h = targetH;
            b.x = cropState.handle.includes('w') ? s.x + (s.w - targetW) : s.x;
            b.y = cropState.handle.includes('n') ? s.y + (s.h - targetH) : s.y;
          }
        }

        clampBoxToImage();
        drawCropCanvas();
      }

      function onCropUp() {
        cropState.mode = null;
        cropState.handle = null;
      }

      cropCanvas.addEventListener('mousedown', onCropDown);
      window.addEventListener('mousemove', onCropMove);
      window.addEventListener('mouseup', onCropUp);

      cropCanvas.addEventListener('touchstart', onCropDown, { passive: false });
      window.addEventListener('touchmove', onCropMove, { passive: false });
      window.addEventListener('touchend', onCropUp, { passive: false });
      window.addEventListener('resize', () => {
        if (resizeCropCanvas()) drawCropCanvas();
      });
      window.addEventListener('orientationchange', () => {
        if (resizeCropCanvas()) drawCropCanvas();
      });
      if (window.visualViewport) {
        window.visualViewport.addEventListener('resize', () => {
          if (resizeCropCanvas()) drawCropCanvas();
        });
      }

      const cropAspectRatio = document.getElementById('cropAspectRatio');
      cropAspectRatio.addEventListener('change', () => {
        setCropAspectRatio(cropAspectRatio.value, true);
      });
      applyCropPreset(pageConfig.cropPreset);
      setCropAspectRatio(cropAspectRatio.value, false);

      cropImageInput.addEventListener('change', async () => {
        if (!cropImageInput.files || cropImageInput.files.length === 0) return;
        try {
          const img = await fileToImage(cropImageInput.files[0]);
          cropState.img = img;
          cropState.box = cropState.aspectRatio ? buildRatioBox(img, cropState.aspectRatio) : buildDefaultBox(img);
          clampBoxToImage();
          drawCropCanvas();
          setStatus(cropStatus, t('status.imageLoaded'), 'ok');
        } catch {
          setStatus(cropStatus, t('status.loadFailed'), 'error');
        }
      });

      document.getElementById('resetCropBtn').addEventListener('click', () => {
        if (!cropState.img) return;
        const img = cropState.img;
        cropState.box = cropState.aspectRatio ? buildRatioBox(img, cropState.aspectRatio) : buildDefaultBox(img);
        clampBoxToImage();
        drawCropCanvas();
        setStatus(cropStatus, t('status.cropReset'), 'ok');
      });

      const enableCropResize = document.getElementById('enableCropResize');
      const cropResizeWidthWrap = document.getElementById('cropResizeWidthWrap');
      const cropResizeHeightWrap = document.getElementById('cropResizeHeightWrap');
      enableCropResize.addEventListener('change', () => {
        const show = enableCropResize.checked;
        cropResizeWidthWrap.classList.toggle('hidden', !show);
        cropResizeHeightWrap.classList.toggle('hidden', !show);
      });
      if (pageConfig.enableCropResize) {
        enableCropResize.checked = true;
        cropResizeWidthWrap.classList.remove('hidden');
        cropResizeHeightWrap.classList.remove('hidden');
      }

      document.getElementById('confirmCropBtn').addEventListener('click', async () => {
        if (!cropState.img || !cropImageInput.files || cropImageInput.files.length === 0) {
          setStatus(cropStatus, t('status.uploadFirst'), 'error');
          return;
        }

        const format = document.getElementById('cropFormat').value;
        const mimeType = `image/${format}`;
        if (!canEncode(mimeType)) {
          setStatus(cropStatus, t('error.notSupported', { format: format.toUpperCase() }), 'error');
          return;
        }

        try {
          setStatus(cropStatus, t('status.cropProcessing'));
          const img = cropState.img;
          const b = cropState.box;
          let outW = Math.max(1, Math.round(b.w));
          let outH = Math.max(1, Math.round(b.h));

          if (enableCropResize.checked) {
            const rw = Number(document.getElementById('cropResizeWidth').value);
            const rh = Number(document.getElementById('cropResizeHeight').value);
            const hasW = Number.isFinite(rw) && rw > 0;
            const hasH = Number.isFinite(rh) && rh > 0;
            if (!hasW && !hasH) {
              throw new Error(t('error.resizeParams'));
            }
            const ratio = Math.min(hasW ? rw / outW : Infinity, hasH ? rh / outH : Infinity, 1);
            outW = Math.max(1, Math.round(outW * ratio));
            outH = Math.max(1, Math.round(outH * ratio));
          }

          const quality = toQuality(document.getElementById('cropQuality').value, 0.9);
          const blob = await renderToBlob(
            img,
            mimeType,
            quality,
            Math.round(b.x),
            Math.round(b.y),
            Math.round(b.w),
            Math.round(b.h),
            outW,
            outH
          );

          if (!blob) throw new Error('Crop failed.');
          const file = cropImageInput.files[0];
          const base = file.name.replace(/\.[^.]+$/, '') || 'image';
          const mode = await downloadBlob(blob, `${base}-crop.${extForFormat(format)}`);
          setStatus(
            cropStatus,
            mode === 'ios-preview' ? t('status.previewIos') : t('status.cropDone'),
            'ok'
          );
        } catch (err) {
          setStatus(cropStatus, err.message || t('error.cropFailed'), 'error');
        }
      });

      resizeCropCanvas(true);
      drawCropCanvas();

      // Compress tab
      document.getElementById('compressBtn').addEventListener('click', async () => {
        const fileInput = document.getElementById('compressImage');
        const statusEl = document.getElementById('compressStatus');
        if (!fileInput.files || fileInput.files.length === 0) {
          setStatus(statusEl, t('status.chooseImage'), 'error');
          return;
        }

        const file = fileInput.files[0];
        const format = document.getElementById('compressFormat').value;
        const mimeType = `image/${format}`;
        if (!canEncode(mimeType)) {
          setStatus(statusEl, t('error.notSupported', { format: format.toUpperCase() }), 'error');
          return;
        }

        setStatus(statusEl, t('status.compressing'));
        try {
          const img = await fileToImage(file);
          const quality = toQuality(document.getElementById('compressQuality').value, 0.7);
          const blob = await renderToBlob(img, mimeType, quality, 0, 0, img.width, img.height, img.width, img.height);
          if (!blob) throw new Error('Compress failed.');
          const base = file.name.replace(/\.[^.]+$/, '') || 'image';
          const mode = await downloadBlob(blob, `${base}-compressed.${extForFormat(format)}`);
          setStatus(
            statusEl,
            mode === 'ios-preview' ? t('status.previewIos') : t('status.compressDone'),
            'ok'
          );
        } catch (err) {
          setStatus(statusEl, err.message || t('error.compressFailed'), 'error');
        }
      });

      function setProgress(value, labelKey, vars) {
        const progressEl = document.getElementById('upscaleProgress');
        const labelEl = document.getElementById('upscaleProgressLabel');
        progressEl.value = Math.max(0, Math.min(100, Math.round(value)));
        labelEl.textContent = t(labelKey, vars);
      }

      function setUpscaleBusy(isBusy) {
        const wrap = document.getElementById('upscaleProgressWrap');
        if (!wrap) return;
        wrap.classList.toggle('is-busy', Boolean(isBusy));
      }

      let aiUpscaler = null;
      async function getAiUpscaler() {
        if (aiUpscaler) return aiUpscaler;
        if (!window.Upscaler || !window.ESRGANThick2x || !window.tf) {
          throw new Error('AI runtime failed to load.');
        }
        setProgress(8, 'status.aiInit');
        aiUpscaler = new window.Upscaler({
          model: window.ESRGANThick2x
        });
        setProgress(20, 'status.aiModelLoad');
        await aiUpscaler.ready;
        return aiUpscaler;
      }

      let upscaleConfirmResolver = null;
      function askUpscaleConfirm() {
        const box = document.getElementById('upscaleConfirmBox');
        const actionRow = document.getElementById('upscaleActionRow');
        const yesBtn = document.getElementById('upscaleConfirmYes');
        const noBtn = document.getElementById('upscaleConfirmNo');
        actionRow.classList.add('hidden');
        box.classList.remove('hidden');
        return new Promise((resolve) => {
          upscaleConfirmResolver = resolve;
          const resolveOnce = (value) => {
            if (!upscaleConfirmResolver) return;
            upscaleConfirmResolver = null;
            box.classList.add('hidden');
            actionRow.classList.remove('hidden');
            resolve(value);
          };
          yesBtn.onclick = () => resolveOnce(true);
          noBtn.onclick = () => resolveOnce(false);
        });
      }

      // Upscale tab
      document.getElementById('upscaleBtn').addEventListener('click', async () => {
        const fileInput = document.getElementById('upscaleImage');
        const statusEl = document.getElementById('upscaleStatus');
        const btn = document.getElementById('upscaleBtn');
        const actionRow = document.getElementById('upscaleActionRow');
        const confirmed = await askUpscaleConfirm();
        if (!confirmed) {
          setStatus(statusEl, t('status.cancelled'), 'error');
          return;
        }
        if (!fileInput.files || fileInput.files.length === 0) {
          setStatus(statusEl, t('status.chooseImage'), 'error');
          return;
        }

        const file = fileInput.files[0];
        const format = document.getElementById('upscaleFormat').value;
        const mimeType = `image/${format}`;
        if (!canEncode(mimeType)) {
          setStatus(statusEl, t('error.notSupported', { format: format.toUpperCase() }), 'error');
          return;
        }

        const scale = Number(document.getElementById('upscaleScale').value) || 2;
        const restoreMode = document.getElementById('upscaleRestoreMode').value || 'balanced';
        const targetOutputPixels = 24000000;
        const maxInputPixels = Math.floor(targetOutputPixels / (scale * scale));
        actionRow.classList.add('hidden');
        btn.disabled = true;
        setUpscaleBusy(true);
        setStatus(statusEl, '');
        setProgress(2, 'status.aiInit');
        try {
          const imgProbe = await fileToImage(file);
          if (imgProbe.width * imgProbe.height > maxInputPixels) {
            const maxMp = (maxInputPixels / 1000000).toFixed(1);
            throw new Error(t('error.upscaleTooLarge', { maxMp }));
          }

          const upscaler = await getAiUpscaler();
          const quality = toQuality(document.getElementById('upscaleQuality').value, 1);
          const passes = scale >= 4 ? 2 : 1;
          const isCoarseDevice = window.matchMedia('(pointer: coarse), (max-width: 760px)').matches;
          const aiPatchSize = isCoarseDevice ? 64 : 128;
          const aiPadding = aiPatchSize <= 64 ? 4 : 2;

          setProgress(15, 'status.aiPreprocess');
          const prepared = await preprocessForRestore(imgProbe, restoreMode, (p) => {
            const mapped = 15 + 10 * Math.max(0, Math.min(1, p));
            setProgress(mapped, 'status.aiPreprocess');
          });
          let currentImage = await canvasToImage(prepared);
          for (let i = 0; i < passes; i += 1) {
            await yieldToBrowser();
            const passNo = i + 1;
            const start = passes === 1 ? 25 : i === 0 ? 20 : 58;
            const end = passes === 1 ? 88 : i === 0 ? 54 : 90;
            const upscaledBase64 = await upscaler.upscale(currentImage, {
              output: 'base64',
              patchSize: aiPatchSize,
              padding: aiPadding,
              progress: (percent) => {
                const mapped = start + (end - start) * Math.max(0, Math.min(1, percent));
                setProgress(mapped, 'status.aiEnhancingPass', { pass: String(passNo), total: String(passes) });
              }
            });
            currentImage = await base64ToImage(upscaledBase64);
            await yieldToBrowser();
          }

          setProgress(92, 'status.aiPostprocess');
          const finalCanvas = await postprocessAfterRestore(currentImage, restoreMode, (p) => {
            const mapped = 92 + 3 * Math.max(0, Math.min(1, p));
            setProgress(mapped, 'status.aiPostprocess');
          });

          setProgress(95, 'status.aiFinalizing');
          const blob = await renderToBlob(
            finalCanvas,
            mimeType,
            quality,
            0,
            0,
            finalCanvas.width,
            finalCanvas.height,
            finalCanvas.width,
            finalCanvas.height
          );
          if (!blob) throw new Error('Upscale failed.');
          const base = file.name.replace(/\.[^.]+$/, '') || 'image';
          const mode = await downloadBlob(blob, `${base}-${finalCanvas.width}x${finalCanvas.height}.${extForFormat(format)}`);
          setProgress(100, 'status.upscaleDone');
          setStatus(
            statusEl,
            mode === 'ios-preview' ? t('status.previewIos') : t('status.upscaleDone'),
            'ok'
          );
        } catch (err) {
          setStatus(statusEl, err.message || t('error.upscaleFailed'), 'error');
          setProgress(0, 'upscale.progressIdle');
        } finally {
          btn.disabled = false;
          actionRow.classList.remove('hidden');
          setUpscaleBusy(false);
        }
      });
    </script>
  </body>
</html>
