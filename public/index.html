<!doctype html>
<html lang="__HTML_LANG__" dir="__HTML_DIR__">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="__META_DESCRIPTION__" />
    <meta name="robots" content="index,follow,max-image-preview:large,max-snippet:-1,max-video-preview:-1" />
    <link rel="canonical" href="__CANONICAL_URL__" />
    __ALT_HREFLANG_LINKS__
    <meta property="og:type" content="website" />
    <meta property="og:site_name" content="ImgConvertCrop" />
    <meta property="og:url" content="__CANONICAL_URL__" />
    <meta property="og:title" content="__OG_TITLE__" />
    <meta property="og:description" content="__OG_DESCRIPTION__" />
    <meta property="og:image" content="https://imgconvertcrop.com/og-image.png" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="__TWITTER_TITLE__" />
    <meta name="twitter:description" content="__TWITTER_DESCRIPTION__" />
    <meta name="twitter:image" content="https://imgconvertcrop.com/og-image.png" />
    <title>__PAGE_TITLE__</title>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4240863320156963"
     crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@upscalerjs/esrgan-thick@1.0.0-beta.16/dist/umd/models/esrgan-thick/src/x2/index.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/upscaler@1.0.0-beta.19/dist/browser/umd/upscaler.min.js"></script>
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "WebSite",
        "name": "ImgConvertCrop",
        "url": "__CANONICAL_URL__",
        "description": "__META_DESCRIPTION__"
      }
    </script>
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "SoftwareApplication",
        "name": "ImgConvertCrop",
        "applicationCategory": "MultimediaApplication",
        "operatingSystem": "Any",
        "url": "__CANONICAL_URL__",
        "offers": {
          "@type": "Offer",
          "price": "0",
          "priceCurrency": "USD"
        },
        "description": "__META_DESCRIPTION__"
      }
    </script>
    <style>
      :root {
        --bg-1: #eef4ff;
        --bg-2: #e6eefc;
        --card: rgba(255, 255, 255, 0.96);
        --ink: #122340;
        --muted: #5e7190;
        --line: #d2deef;
        --brand: #1768ff;
        --brand-2: #0b43b5;
        --ok: #0f7a4e;
        --danger: #c42929;
        --shadow: 0 20px 48px rgba(18, 45, 95, 0.15);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Plus Jakarta Sans", "Avenir Next", "Segoe UI", sans-serif;
        color: var(--ink);
        background:
          radial-gradient(circle at 10% 10%, #ffffff 0%, transparent 46%),
          radial-gradient(circle at 90% 14%, #dce9ff 0%, transparent 36%),
          linear-gradient(180deg, var(--bg-1) 0%, var(--bg-2) 100%);
        min-height: 100vh;
      }

      .page {
        max-width: 1040px;
        margin: 28px auto;
        padding: 0 18px 22px;
      }

      .card {
        background: var(--card);
        border: 1px solid var(--line);
        border-radius: 18px;
        backdrop-filter: blur(12px);
        box-shadow: var(--shadow);
        overflow: hidden;
      }

      .head {
        padding: 22px 22px 14px;
        border-bottom: 1px solid var(--line);
      }

      .head-top {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }

      .brand-chip {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 10px;
        border-radius: 999px;
        font-size: 12px;
        font-weight: 700;
        color: #1f4f9f;
        border: 1px solid #cfe0f6;
        background: #f4f8ff;
        margin-bottom: 10px;
      }

      .locale-picker {
        display: flex;
        align-items: center;
        gap: 8px;
        min-width: 180px;
        flex-wrap: nowrap;
      }

      .locale-picker label {
        margin: 0;
        font-size: 12px;
        white-space: nowrap;
        flex: 0 0 auto;
        writing-mode: horizontal-tb;
      }

      .locale-picker select {
        min-width: 120px;
        padding: 8px 10px;
      }

      h1 {
        margin: 0 0 8px;
        font-size: clamp(1.65rem, 2.1vw, 2rem);
        letter-spacing: -0.02em;
      }

      .subtitle {
        margin: 0;
        color: var(--muted);
        font-size: 0.96rem;
      }

      .quick-flow {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 12px;
      }

      .oss-callout {
        margin-top: 12px;
        padding: 10px 12px;
        border: 1px solid #d5e2f4;
        border-radius: 12px;
        background: #f8fbff;
        color: #2a4f82;
        font-size: 13px;
      }

      .oss-callout a {
        color: #1256c8;
        font-weight: 700;
        text-decoration: none;
      }

      .oss-callout a:hover {
        text-decoration: underline;
      }

      .flow-pill {
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid #d5e2f4;
        background: #f8fbff;
        color: #345987;
        font-size: 12px;
        font-weight: 600;
      }

      .tabs {
        display: flex;
        gap: 8px;
        padding: 12px 14px 10px;
        border-bottom: 1px solid var(--line);
        flex-wrap: nowrap;
        overflow-x: auto;
        background: #f7faff;
      }

      .tab-btn {
        border: 1px solid #cfdbef;
        background: #f2f6ff;
        color: #35547f;
        padding: 9px 16px;
        border-radius: 999px;
        cursor: pointer;
        font-weight: 700;
        font-size: 0.9rem;
        width: auto;
        transition: transform 120ms ease, box-shadow 120ms ease, background-color 120ms ease;
        box-shadow: none;
      }

      .tab-btn.active {
        background: linear-gradient(180deg, #2b7bff 0%, #1768ff 100%);
        border-color: #1768ff;
        color: #ffffff;
        box-shadow: 0 6px 14px rgba(23, 104, 255, 0.28);
      }

      .tab-btn:hover {
        transform: translateY(-1px);
      }

      .panel {
        display: none;
        padding: 18px 18px 22px;
      }

      .panel.active {
        display: block;
      }

      .grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 14px;
      }

      .full {
        grid-column: 1 / -1;
      }

      label {
        display: block;
        margin-bottom: 7px;
        font-size: 12px;
        font-weight: 700;
        text-transform: none;
        letter-spacing: 0.02em;
        color: #2f4467;
      }

      input,
      select,
      button {
        width: 100%;
        border: 1px solid #cfdced;
        border-radius: 12px;
        padding: 11px 12px;
        font-size: 14px;
        background: #fbfdff;
      }

      button {
        background: linear-gradient(180deg, #2b7bff 0%, #1768ff 100%);
        border-color: #1768ff;
        color: #fff;
        cursor: pointer;
        font-weight: 700;
        letter-spacing: 0.01em;
        box-shadow: 0 8px 16px rgba(23, 104, 255, 0.28);
      }

      button.alt {
        background: #f2f6ff;
        border-color: #ccd9f0;
        color: #1b3d74;
        box-shadow: none;
      }

      input:focus,
      select:focus,
      button:focus-visible {
        outline: none;
        border-color: #7aa9ff;
        box-shadow: 0 0 0 3px rgba(23, 104, 255, 0.16);
      }

      button:disabled {
        opacity: 0.7;
        cursor: not-allowed;
      }

      .status {
        margin-top: 14px;
        font-size: 14px;
        color: #2a4570;
        padding: 10px 12px;
        border-radius: 10px;
        background: #f3f8ff;
        border: 1px solid #d8e4f5;
      }
      .status:empty {
        display: none;
      }

      .status.error {
        color: var(--danger);
        background: #fff1f1;
        border-color: #f2c6c6;
      }

      .status.ok {
        color: var(--ok);
        background: #eefaf4;
        border-color: #bde8cf;
      }

      .progress-wrap {
        margin-top: 10px;
      }

      #upscaleProgressWrap {
        position: relative;
      }

      .progress-wrap progress {
        width: 100%;
        height: 12px;
        border-radius: 999px;
      }

      #upscaleProgress {
        appearance: none;
        -webkit-appearance: none;
      }

      #upscaleProgress::-webkit-progress-bar {
        background: #e5ebf5;
        border-radius: 999px;
      }

      #upscaleProgress::-webkit-progress-value {
        border-radius: 999px;
        background-image:
          linear-gradient(
            110deg,
            rgba(255, 255, 255, 0) 0%,
            rgba(255, 255, 255, 0.22) 25%,
            rgba(255, 255, 255, 0.36) 38%,
            rgba(255, 255, 255, 0.22) 51%,
            rgba(255, 255, 255, 0) 72%
          ),
          linear-gradient(90deg, #7f3fb0 0%, #9156c8 55%, #7f3fb0 100%);
        background-size: 220% 100%, 100% 100%;
        background-position: 200% 0, 0 0;
      }

      #upscaleProgress::-moz-progress-bar {
        border-radius: 999px;
        background-image:
          linear-gradient(
            110deg,
            rgba(255, 255, 255, 0) 0%,
            rgba(255, 255, 255, 0.22) 25%,
            rgba(255, 255, 255, 0.36) 38%,
            rgba(255, 255, 255, 0.22) 51%,
            rgba(255, 255, 255, 0) 72%
          ),
          linear-gradient(90deg, #7f3fb0 0%, #9156c8 55%, #7f3fb0 100%);
        background-size: 220% 100%, 100% 100%;
        background-position: 200% 0, 0 0;
      }

      @keyframes upscaleGlowPulse {
        0% {
          filter: brightness(1.03) saturate(1.02);
        }
        50% {
          filter: brightness(1.42) saturate(1.08);
        }
        100% {
          filter: brightness(1.03) saturate(1.02);
        }
      }

      @keyframes upscaleTrackBreathe {
        0% {
          box-shadow: 0 0 0 rgba(127, 63, 176, 0), 0 0 0 rgba(175, 104, 224, 0);
        }
        50% {
          box-shadow: 0 0 20px rgba(127, 63, 176, 0.62), 0 0 9px rgba(175, 104, 224, 0.46);
        }
        100% {
          box-shadow: 0 0 0 rgba(127, 63, 176, 0), 0 0 0 rgba(175, 104, 224, 0);
        }
      }

      @keyframes upscaleFlow {
        0% {
          background-position: 200% 0, 0 0;
        }
        100% {
          background-position: -80% 0, 0 0;
        }
      }

      @keyframes upscaleShineSweep {
        0% {
          transform: translateX(-120%);
          opacity: 0;
        }
        20% {
          opacity: 0.26;
        }
        100% {
          transform: translateX(320%);
          opacity: 0;
        }
      }

      #upscaleProgressWrap.is-busy #upscaleProgress {
        animation: upscaleTrackBreathe 1.35s ease-in-out infinite;
      }

      #upscaleProgressWrap.is-busy #upscaleProgress::-webkit-progress-value {
        animation: upscaleFlow 1.35s linear infinite, upscaleGlowPulse 1.1s ease-in-out infinite;
      }

      #upscaleProgressWrap.is-busy #upscaleProgress::-moz-progress-bar {
        animation: upscaleFlow 1.35s linear infinite, upscaleGlowPulse 1.1s ease-in-out infinite;
      }

      #upscaleProgressWrap.is-busy::after {
        content: '';
        position: absolute;
        left: 0;
        top: 0;
        width: 34%;
        height: 12px;
        border-radius: 999px;
        pointer-events: none;
        background: linear-gradient(90deg, rgba(255, 255, 255, 0) 0%, rgba(228, 194, 255, 0.64) 45%, rgba(255, 255, 255, 0) 100%);
        filter: blur(0.2px);
        animation: upscaleShineSweep 1.5s ease-in-out infinite;
      }

      .progress-label {
        margin-top: 6px;
        font-size: 12px;
        color: var(--muted);
      }

      .crop-shell {
        border: 1px solid var(--line);
        border-radius: 14px;
        background: #f8fbff;
        padding: 12px;
      }

      .crop-canvas-wrap {
        width: 100%;
        overflow: auto;
        -webkit-overflow-scrolling: touch;
        border-radius: 10px;
        background: linear-gradient(135deg, #d7e2f5 0%, #e8effd 100%);
        border: 1px solid #cfdbef;
      }

      #cropCanvas {
        display: block;
        width: 100%;
        max-width: 100%;
        height: auto;
        margin: 0 auto;
        cursor: crosshair;
        touch-action: none;
      }

      .remove-shell {
        border: 1px solid var(--line);
        border-radius: 14px;
        background: #f8fbff;
        padding: 12px;
      }

      .remove-toolbar {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 8px;
        margin-bottom: 10px;
        width: 100%;
        min-width: 0;
      }

      .remove-toolbar button {
        width: auto;
        min-width: 90px;
        padding: 8px 12px;
      }

      .remove-algo-group {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 8px;
        width: 100%;
        min-width: 0;
      }

      .brush-control {
        display: flex;
        align-items: center;
        gap: 8px;
        width: 100%;
        min-width: 0;
      }

      .brush-control input[type='range'] {
        flex: 1 1 auto;
        min-width: 0;
        width: auto;
      }

      .brush-step {
        width: auto;
        min-width: 44px;
        padding: 10px 12px;
        line-height: 1;
      }

      .brush-value {
        min-width: 52px;
        text-align: center;
        font-size: 13px;
        font-weight: 700;
        color: #1f467a;
      }

      .remove-algo-option {
        display: flex;
        flex-direction: column;
        gap: 4px;
        padding: 10px 10px 9px;
        border: 1px solid #cfdced;
        border-radius: 10px;
        background: #f8fbff;
        cursor: pointer;
        min-width: 0;
      }

      .remove-algo-option input {
        position: absolute;
        opacity: 0;
        pointer-events: none;
        width: 0;
        height: 0;
      }

      .remove-algo-title {
        font-size: 13px;
        font-weight: 700;
        color: #234773;
        overflow-wrap: anywhere;
      }

      .remove-algo-desc {
        font-size: 12px;
        color: #547198;
        line-height: 1.35;
        overflow-wrap: anywhere;
      }

      .remove-algo-option:has(input:checked) {
        border-color: #1768ff;
        background: #eef4ff;
        box-shadow: 0 0 0 2px rgba(23, 104, 255, 0.15);
      }

      .zoom-readout {
        font-size: 12px;
        color: var(--muted);
        min-width: 58px;
      }

      .remove-workspace-frame {
        position: relative;
        width: 100%;
        min-width: 0;
      }

      .remove-workspace {
        position: relative;
        width: 100%;
        height: 520px;
        max-height: 74vh;
        overflow: auto;
        border-radius: 10px;
        background: linear-gradient(135deg, #d7e2f5 0%, #e8effd 100%);
        border: 1px solid #cfdbef;
        padding: 8px;
      }

      @media (pointer: coarse) {
        .remove-workspace {
          scrollbar-width: none;
        }

        .remove-workspace::-webkit-scrollbar {
          width: 0;
          height: 0;
          display: none;
        }
      }

      .remove-stage {
        display: flex;
        align-items: center;
        justify-content: center;
        min-width: 100%;
        min-height: 100%;
        width: max-content;
        height: max-content;
      }

      .remove-busy-overlay {
        position: absolute;
        inset: 0;
        border-radius: 10px;
        pointer-events: none;
        opacity: 0;
      }

      .remove-empty {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: none;
        padding: 18px;
      }

      .remove-empty.hidden {
        display: none;
      }

      .remove-empty-card {
        max-width: 380px;
        width: 100%;
        border: 1px solid #d7e3f6;
        border-radius: 14px;
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.78) 0%, rgba(239, 246, 255, 0.78) 100%);
        box-shadow: 0 10px 24px rgba(20, 48, 98, 0.1);
        padding: 14px 14px 12px;
        text-align: center;
      }

      .remove-empty-title {
        margin: 0;
        font-size: 21px;
        line-height: 1;
      }

      .remove-empty-text {
        margin: 8px 0 0;
        font-size: 14px;
        color: #47648f;
        font-weight: 700;
      }

      .remove-empty-sub {
        margin: 6px 0 0;
        font-size: 12px;
        color: #6884ad;
      }

      .remove-busy-overlay.is-busy {
        opacity: 1;
        background:
          radial-gradient(circle at 25% 30%, rgba(255, 255, 255, 0.24), transparent 45%),
          linear-gradient(120deg, rgba(23, 104, 255, 0.06), rgba(23, 104, 255, 0.26), rgba(23, 104, 255, 0.06));
        background-size: 120% 120%, 220% 100%;
        animation: removeGlowSweep 1.2s linear infinite;
      }

      @keyframes removeGlowSweep {
        0% {
          background-position: 0% 0%, 200% 0%;
        }
        100% {
          background-position: 0% 0%, -80% 0%;
        }
      }

      #removeCanvas {
        display: block;
        cursor: crosshair;
        touch-action: none;
        flex: 0 0 auto;
      }

      .note {
        color: var(--muted);
        font-size: 12px;
        margin-bottom: 0;
      }

      .file-picker {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 10px 12px;
        border: 1px solid #cfdced;
        border-radius: 12px;
        background: #fbfdff;
      }

      .file-picker button {
        width: auto;
        min-width: 96px;
        padding: 8px 10px;
      }

      .file-picker-name {
        font-size: 14px;
        color: #365885;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .file-picker input[type='file'] {
        display: none;
      }

      .note-highlight {
        color: #0b43b5;
        font-weight: 700;
        background: #e8f0ff;
        border: 1px solid #c7d9ff;
        border-radius: 8px;
        padding: 8px 10px;
        margin-top: 6px;
      }

      .restore-help {
        border: 1px solid #d6e3f7;
        background: #f7faff;
        border-radius: 10px;
        padding: 10px 12px;
        margin-top: -2px;
      }

      .restore-help-title {
        margin: 0 0 8px;
        font-size: 12px;
        font-weight: 700;
        color: #2b4875;
      }

      .restore-item {
        display: flex;
        align-items: flex-start;
        gap: 8px;
        font-size: 12px;
        color: var(--muted);
        padding: 8px 0;
        border-top: 1px dashed #d9e5f8;
      }

      .restore-item:first-of-type {
        border-top: none;
      }

      .restore-chip {
        flex: 0 0 auto;
        font-weight: 700;
        color: #1c4ea0;
        background: #e5efff;
        border: 1px solid #c8dafd;
        border-radius: 999px;
        padding: 2px 8px;
        line-height: 1.35;
      }

      .restore-text {
        line-height: 1.4;
        padding-top: 2px;
      }

      .confirm-actions {
        display: flex;
        gap: 8px;
        margin-top: 8px;
      }

      .confirm-actions button {
        width: auto;
        min-width: 110px;
      }

      .inline-toggle {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 8px 10px;
        border-radius: 10px;
        background: #f3f7ff;
        border: 1px solid #d8e3f4;
      }

      .inline-toggle input {
        width: auto;
      }

      .hidden {
        display: none;
      }

      .ad-wrap {
        margin: 14px 0 6px;
        border: 1px solid #d9e3f2;
        border-radius: 12px;
        background: #f8fbff;
        padding: 8px;
      }

      .ad-wrap.bottom {
        margin-top: 18px;
      }

      .left-rail-ad {
        position: fixed;
        top: 120px;
        left: 14px;
        width: 190px;
        z-index: 20;
      }

      .right-rail-ad {
        position: fixed;
        top: 120px;
        right: 14px;
        width: 190px;
        z-index: 20;
      }

      .left-rail-ad .ad-wrap {
        margin: 0;
        padding: 10px;
        border-radius: 14px;
        box-shadow: 0 10px 20px rgba(16, 36, 74, 0.12);
      }

      .right-rail-ad .ad-wrap {
        margin: 0;
        padding: 10px;
        border-radius: 14px;
        box-shadow: 0 10px 20px rgba(16, 36, 74, 0.12);
      }

      .tool-card {
        margin-top: 12px;
        padding: 14px;
        border: 1px solid #d8e3f3;
        border-radius: 14px;
        background: linear-gradient(180deg, #fbfdff 0%, #f5f9ff 100%);
      }

      .tool-title {
        margin: 0 0 4px;
        font-size: 15px;
        font-weight: 700;
        color: #223f67;
      }

      .tool-subtitle {
        margin: 0 0 10px;
        color: var(--muted);
        font-size: 12px;
      }

      .seo-copy {
        margin-top: 16px;
        padding: 14px;
        border: 1px solid #d8e3f3;
        border-radius: 14px;
        background: #f9fcff;
      }

      .seo-copy h2 {
        margin: 0 0 8px;
        font-size: 18px;
        color: #1d3f70;
      }

      .seo-copy p {
        margin: 0 0 8px;
        color: #34557f;
        line-height: 1.5;
        font-size: 14px;
      }

      .seo-copy ul {
        margin: 0;
        padding-left: 18px;
        color: #34557f;
        font-size: 14px;
      }

      .keyword-copy {
        margin-top: 12px;
        padding-top: 12px;
        border-top: 1px dashed #d5e2f4;
      }

      .keyword-copy h3 {
        margin: 0 0 8px;
        font-size: 15px;
        color: #244a7f;
      }

      .keyword-copy p {
        margin: 0;
        color: #3d5f8c;
      }

      .related-links {
        margin-top: 12px;
        padding-top: 12px;
        border-top: 1px dashed #d5e2f4;
      }

      .related-links h3 {
        margin: 0 0 8px;
        font-size: 15px;
        color: #244a7f;
      }

      .related-links ul {
        margin: 0;
        padding-left: 18px;
      }

      .related-links a {
        color: #1c59b8;
        text-decoration: none;
      }

      .related-links a:hover {
        text-decoration: underline;
      }

      @media (max-width: 760px) {
        .page {
          margin-top: 20px;
          padding: 0 12px 16px;
        }

        .head {
          padding: 18px 16px 12px;
        }

        .tabs {
          padding: 12px 12px 10px;
        }

        .panel {
          padding: 16px 14px 18px;
        }

        .grid {
          grid-template-columns: 1fr;
        }

        .tabs {
          gap: 10px;
        }

        .tab-btn {
          padding: 10px 16px;
        }

        .crop-shell {
          padding: 10px;
        }

        .inline-toggle {
          padding: 10px 12px;
        }

        .remove-shell {
          padding: 10px;
          overflow-x: hidden;
        }

        .remove-workspace {
          height: 420px;
          max-height: 68vh;
        }

        .brush-step {
          min-width: 52px;
          padding: 12px 14px;
        }

        .brush-value {
          min-width: 44px;
          font-size: 12px;
        }

        .remove-algo-group {
          grid-template-columns: 1fr;
        }

        .remove-toolbar {
          display: grid;
          grid-template-columns: repeat(3, minmax(0, 1fr));
          gap: 8px;
        }

        .remove-toolbar button {
          min-width: 0;
          width: 100%;
          padding: 10px 10px;
          font-size: 13px;
        }

        .zoom-readout {
          grid-column: 3 / 4;
          justify-self: end;
          align-self: center;
          min-width: 0;
          font-size: 12px;
        }

        #removeUndoBtn {
          grid-column: 1 / 3;
        }

        #cropCanvas {
          touch-action: none;
        }
      }

      @media (max-width: 1300px) {
        .left-rail-ad {
          display: none;
        }
        .right-rail-ad {
          display: none;
        }
      }
    </style>
  </head>
  <body>
    <aside class="left-rail-ad" aria-label="Advertisement">
      <div class="ad-wrap">
        <ins class="adsbygoogle"
             style="display:block"
             data-ad-client="ca-pub-4240863320156963"
             data-ad-slot="3548309138"
             data-ad-format="auto"
             data-full-width-responsive="true"></ins>
      </div>
    </aside>
    <aside class="right-rail-ad" aria-label="Advertisement">
      <div class="ad-wrap">
        <ins class="adsbygoogle"
             style="display:block"
             data-ad-client="ca-pub-4240863320156963"
             data-ad-slot="2551746648"
             data-ad-format="auto"
             data-full-width-responsive="true"></ins>
      </div>
    </aside>
    <main class="page">
      <section class="card">
        <div class="head">
          <div class="head-top">
            <div class="brand-chip">imgconvertcrop.com</div>
            <div class="locale-picker">
              <label for="languageSelect" data-i18n="lang.label">Language</label>
              <select id="languageSelect">__LANG_OPTIONS_HTML__</select>
            </div>
          </div>
          <h1 id="heroTitle">__HERO_TITLE__</h1>
          <p class="subtitle" id="heroSubtitle">__HERO_SUBTITLE__</p>
          <p class="oss-callout">
            <span data-i18n="oss.prefix">Open source:</span>
            <a href="https://github.com/supdub/image-free-convert" target="_blank" rel="noopener noreferrer" data-i18n="oss.link">GitHub repo</a>
            <span data-i18n="oss.suffix">Deploy your own version.</span>
          </p>
          <div class="quick-flow">
            <span class="flow-pill" data-i18n="flow.upload">1. Upload</span>
            <span class="flow-pill" data-i18n="flow.adjust">2. Adjust</span>
            <span class="flow-pill" data-i18n="flow.download">3. Download</span>
            <span class="flow-pill" data-i18n="flow.privacy">We never save your images</span>
            <span class="flow-pill" data-i18n="flow.allInOne">All-in-one image toolkit: convert, crop, compress, upscale, and AI remove.</span>
          </div>
        </div>

        <div class="tabs" role="tablist">
          <button type="button" class="tab-btn __CONVERT_TAB_ACTIVE__" data-tab="convert" role="tab" data-i18n="tab.convert">Convert</button>
          <button type="button" class="tab-btn __CROP_TAB_ACTIVE__" data-tab="crop" role="tab" data-i18n="tab.crop">Crop</button>
          <button type="button" class="tab-btn __COMPRESS_TAB_ACTIVE__" data-tab="compress" role="tab" data-i18n="tab.compress">Compress</button>
          <button type="button" class="tab-btn __UPSCALE_TAB_ACTIVE__" data-tab="upscale" role="tab" data-i18n="tab.upscale">Upscale</button>
          <button type="button" class="tab-btn __REMOVE_TAB_ACTIVE__" data-tab="remove" role="tab" data-i18n="tab.remove">AI Remove</button>
        </div>

        <section class="panel __CONVERT_PANEL_ACTIVE__" id="panel-convert">
          <div class="tool-card">
            <p class="tool-title" data-i18n="convert.title">Convert Images</p>
            <p class="tool-subtitle" data-i18n="convert.subtitle">Change image format while keeping quality under your control.</p>
          <div class="ad-wrap">
            <ins class="adsbygoogle"
                 style="display:block"
                 data-ad-client="ca-pub-4240863320156963"
                 data-ad-slot="3548309138"
                 data-ad-format="auto"
                 data-full-width-responsive="true"></ins>
          </div>
          <div class="grid">
            <div class="full">
              <label for="convertImage" data-i18n="field.imageFile">Image File</label>
              <div class="file-picker">
                <button type="button" class="alt" data-file-target="convertImage" data-i18n="btn.chooseFile">Choose File</button>
                <span class="file-picker-name" id="convertImageName" data-i18n="status.noFileChosen">No file chosen</span>
                <input id="convertImage" type="file" accept="image/*" />
              </div>
            </div>
            <div>
              <label for="convertFormat" data-i18n="field.outputFormat">Output Format</label>
              <select id="convertFormat">
                <option value="jpeg">JPEG</option>
                <option value="png">PNG</option>
                <option value="webp">WEBP</option>
                <option value="avif">AVIF</option>
              </select>
            </div>
            <div>
              <label for="convertQuality" data-i18n="field.quality">Quality (1-100)</label>
              <input id="convertQuality" type="number" min="1" max="100" value="90" />
            </div>
            <div class="full">
              <button type="button" id="convertBtn" data-i18n="btn.convertDownload">Convert and Download</button>
            </div>
          </div>
          <div class="status" id="convertStatus" aria-live="polite"></div>
          <div class="ad-wrap bottom">
            <ins class="adsbygoogle"
                 style="display:block"
                 data-ad-client="ca-pub-4240863320156963"
                 data-ad-slot="3548309138"
                 data-ad-format="auto"
                 data-full-width-responsive="true"></ins>
          </div>
          <section class="seo-copy" aria-label="What this tool does">
            <h2>__SEO_H2__</h2>
            <p>__SEO_P1__</p>
            <p>__SEO_P2__</p>
            <ul>
              <li>__SEO_LI_1__</li>
              <li>__SEO_LI_2__</li>
              <li>__SEO_LI_3__</li>
            </ul>
            <div class="keyword-copy" aria-label="Keyword search intent">
              <h3>__KEYWORD_TITLE__</h3>
              <p>__KEYWORD_TEXT__</p>
            </div>
            <nav class="related-links" aria-label="Related tool pages">
              <h3 data-i18n="seo.relatedPages">Related pages</h3>
              <ul>
                __RELATED_LINKS_HTML__
              </ul>
            </nav>
          </section>
          </div>
        </section>

        <section class="panel __CROP_PANEL_ACTIVE__" id="panel-crop">
          <div class="tool-card">
            <p class="tool-title" data-i18n="crop.title">Crop Images</p>
            <p class="tool-subtitle" data-i18n="crop.subtitle">Use the crop frame to focus only on the area you want, then optionally resize.</p>
          <div class="ad-wrap">
            <ins class="adsbygoogle"
                 style="display:block"
                 data-ad-client="ca-pub-4240863320156963"
                 data-ad-slot="3548309138"
                 data-ad-format="auto"
                 data-full-width-responsive="true"></ins>
          </div>
          <div class="grid">
            <div class="full">
              <label for="cropImage" data-i18n="field.imageFile">Image File</label>
              <div class="file-picker">
                <button type="button" class="alt" data-file-target="cropImage" data-i18n="btn.chooseFile">Choose File</button>
                <span class="file-picker-name" id="cropImageName" data-i18n="status.noFileChosen">No file chosen</span>
                <input id="cropImage" type="file" accept="image/*" />
              </div>
            </div>
            <div class="full crop-shell">
              <div class="crop-canvas-wrap">
                <canvas id="cropCanvas" width="860" height="480"></canvas>
              </div>
              <p class="note" data-i18n="crop.instructions">Drag inside the box to move. Drag corners to resize. Use Confirm Crop when ready.</p>
            </div>

            <div>
              <label for="cropFormat" data-i18n="field.outputFormat">Output Format</label>
              <select id="cropFormat">
                <option value="png">PNG</option>
                <option value="jpeg">JPEG</option>
                <option value="webp">WEBP</option>
                <option value="avif">AVIF</option>
              </select>
            </div>
            <div>
              <label for="cropQuality" data-i18n="field.quality">Quality (1-100)</label>
              <input id="cropQuality" type="number" min="1" max="100" value="90" />
            </div>
            <div>
              <label for="cropAspectRatio" data-i18n="crop.aspectRatio">Aspect Ratio</label>
              <select id="cropAspectRatio">
                <option value="free" data-i18n="crop.ratio.free">Free</option>
                <option value="1:1">1:1</option>
                <option value="4:3">4:3</option>
                <option value="3:4">3:4</option>
                <option value="16:9">16:9</option>
                <option value="9:16">9:16</option>
                <option value="3:2">3:2</option>
                <option value="2:3">2:3</option>
              </select>
            </div>

            <div class="full inline-toggle">
              <input id="enableCropResize" type="checkbox" />
              <label for="enableCropResize" style="margin: 0" data-i18n="crop.resizeAfter">Resize after crop</label>
            </div>
            <div class="full note" id="cropResizeExplain" data-i18n="crop.resizeExplain">
              If enabled, the cropped image is scaled down to fit within the width/height you provide. It keeps aspect ratio and will not stretch.
            </div>

            <div id="cropResizeWidthWrap" class="hidden">
              <label for="cropResizeWidth" data-i18n="crop.resizeWidth">Resize Width</label>
              <input id="cropResizeWidth" type="number" min="1" placeholder="e.g. 800" />
            </div>
            <div id="cropResizeHeightWrap" class="hidden">
              <label for="cropResizeHeight" data-i18n="crop.resizeHeight">Resize Height</label>
              <input id="cropResizeHeight" type="number" min="1" placeholder="e.g. 600" />
            </div>

            <div>
              <button type="button" class="alt" id="resetCropBtn" data-i18n="btn.resetBox">Reset Box</button>
            </div>
            <div>
              <button type="button" id="confirmCropBtn" data-i18n="btn.confirmCropDownload">Confirm Crop and Download</button>
            </div>
          </div>
            <div class="status" id="cropStatus" aria-live="polite"></div>
            <div class="ad-wrap bottom">
              <ins class="adsbygoogle"
                   style="display:block"
                   data-ad-client="ca-pub-4240863320156963"
                   data-ad-slot="3548309138"
                   data-ad-format="auto"
                   data-full-width-responsive="true"></ins>
            </div>
          </div>
        </section>

        <section class="panel __COMPRESS_PANEL_ACTIVE__" id="panel-compress">
          <div class="tool-card">
            <p class="tool-title" data-i18n="compress.title">Compress Images</p>
            <p class="tool-subtitle" data-i18n="compress.subtitle">Reduce file size while preserving the same pixel dimensions.</p>
          <div class="ad-wrap">
            <ins class="adsbygoogle"
                 style="display:block"
                 data-ad-client="ca-pub-4240863320156963"
                 data-ad-slot="3548309138"
                 data-ad-format="auto"
                 data-full-width-responsive="true"></ins>
          </div>
          <div class="grid">
            <div class="full">
              <label for="compressImage" data-i18n="field.imageFile">Image File</label>
              <div class="file-picker">
                <button type="button" class="alt" data-file-target="compressImage" data-i18n="btn.chooseFile">Choose File</button>
                <span class="file-picker-name" id="compressImageName" data-i18n="status.noFileChosen">No file chosen</span>
                <input id="compressImage" type="file" accept="image/*" />
              </div>
            </div>
            <div>
              <label for="compressFormat" data-i18n="field.outputFormat">Output Format</label>
              <select id="compressFormat">
                <option value="jpeg">JPEG</option>
                <option value="webp">WEBP</option>
                <option value="avif">AVIF</option>
                <option value="png">PNG</option>
              </select>
            </div>
            <div>
              <label for="compressQuality" data-i18n="compress.quality">Compression Quality (1-100)</label>
              <input id="compressQuality" type="number" min="1" max="100" value="70" />
            </div>
            <div class="full">
              <p class="note" data-i18n="compress.note">Compress keeps the same pixel dimensions. It only reduces encoded quality/size.</p>
            </div>
            <div class="full">
              <button type="button" id="compressBtn" data-i18n="btn.compressDownload">Compress and Download</button>
            </div>
          </div>
          <div class="status" id="compressStatus" aria-live="polite"></div>
          <div class="ad-wrap bottom">
            <ins class="adsbygoogle"
                 style="display:block"
                 data-ad-client="ca-pub-4240863320156963"
                 data-ad-slot="3548309138"
                 data-ad-format="auto"
                 data-full-width-responsive="true"></ins>
          </div>
          </div>
        </section>

        <section class="panel __UPSCALE_PANEL_ACTIVE__" id="panel-upscale">
          <div class="tool-card">
            <p class="tool-title" data-i18n="upscale.title">Upscale Images</p>
            <p class="tool-subtitle" data-i18n="upscale.subtitle">AI Enhance upscale that can recover perceived detail, not just stretch pixels.</p>
          <div class="ad-wrap">
            <ins class="adsbygoogle"
                 style="display:block"
                 data-ad-client="ca-pub-4240863320156963"
                 data-ad-slot="3548309138"
                 data-ad-format="auto"
                 data-full-width-responsive="true"></ins>
          </div>
          <div class="grid">
            <div class="full">
              <label for="upscaleImage" data-i18n="field.imageFile">Image File</label>
              <div class="file-picker">
                <button type="button" class="alt" data-file-target="upscaleImage" data-i18n="btn.chooseFile">Choose File</button>
                <span class="file-picker-name" id="upscaleImageName" data-i18n="status.noFileChosen">No file chosen</span>
                <input id="upscaleImage" type="file" accept="image/*" />
              </div>
            </div>
            <div>
              <label for="upscaleScale" data-i18n="upscale.scale">Scale</label>
              <select id="upscaleScale">
                <option value="2">2x</option>
                <option value="4">4x</option>
              </select>
            </div>
            <div>
              <label for="upscaleFormat" data-i18n="field.outputFormat">Output Format</label>
              <select id="upscaleFormat">
                <option value="png">PNG</option>
                <option value="jpeg">JPEG</option>
                <option value="webp">WEBP</option>
                <option value="avif">AVIF</option>
              </select>
            </div>
            <div>
              <label for="upscaleQuality" data-i18n="upscale.quality">Output Quality (1-100)</label>
              <input id="upscaleQuality" type="number" min="1" max="100" value="100" />
            </div>
            <div>
              <label for="upscaleRestoreMode" data-i18n="upscale.restoreMode">Restore Mode</label>
              <select id="upscaleRestoreMode">
                <option value="balanced" data-i18n="upscale.restore.balanced">Balanced</option>
                <option value="aggressive" data-i18n="upscale.restore.aggressive">Aggressive</option>
                <option value="logo" data-i18n="upscale.restore.logo">Text/Logo</option>
              </select>
            </div>
            <div class="full restore-help">
              <p class="restore-help-title" data-i18n="upscale.restore.helpTitle">Which restore mode should I use?</p>
              <div class="restore-item">
                <span class="restore-chip" data-i18n="upscale.restore.balanced">Balanced</span>
                <span class="restore-text" data-i18n="upscale.restore.help.balanced">Safer default for most photos and mixed content.</span>
              </div>
              <div class="restore-item">
                <span class="restore-chip" data-i18n="upscale.restore.aggressive">Aggressive</span>
                <span class="restore-text" data-i18n="upscale.restore.help.aggressive">Stronger deblock and sharpening, may add halos/noise.</span>
              </div>
              <div class="restore-item">
                <span class="restore-chip" data-i18n="upscale.restore.logo">Text/Logo</span>
                <span class="restore-text" data-i18n="upscale.restore.help.logo">Prioritizes hard edges for logos, icons, and text-like shapes.</span>
              </div>
            </div>
            <div class="full">
              <p class="note" data-i18n="upscale.note">AI Enhance can improve sharpness and texture, but it cannot perfectly recreate missing detail.</p>
              <p class="note" data-i18n="upscale.note2">Very blurry or tiny sources may still look soft. First run downloads a larger ESRGAN model in your browser.</p>
              <p class="note note-highlight" data-i18n="upscale.note3">Expected first-run data: about 31 MB total (model + AI runtime), then cached by browser.</p>
              <p class="note" data-i18n="upscale.note4">4x runs two AI passes, so it is much slower than 2x.</p>
            </div>
            <div class="full progress-wrap" id="upscaleProgressWrap">
              <progress id="upscaleProgress" value="0" max="100"></progress>
              <div class="progress-label" id="upscaleProgressLabel" data-i18n="upscale.progressIdle">Waiting to start AI enhance.</div>
            </div>
            <div class="full hidden note note-highlight" id="upscaleConfirmBox">
              <span id="upscaleConfirmText" data-i18n="upscale.confirmUse">AI Enhance may download about 31 MB on first run and can take time. Continue?</span>
              <div class="confirm-actions">
                <button type="button" id="upscaleConfirmYes" data-i18n="btn.continue">Continue</button>
                <button type="button" class="alt" id="upscaleConfirmNo" data-i18n="btn.cancel">Cancel</button>
              </div>
            </div>
            <div class="full" id="upscaleActionRow">
              <button type="button" id="upscaleBtn" data-i18n="btn.upscaleDownload">Upscale and Download</button>
            </div>
          </div>
          <div class="status" id="upscaleStatus" aria-live="polite"></div>
          <div class="ad-wrap bottom">
            <ins class="adsbygoogle"
                 style="display:block"
                 data-ad-client="ca-pub-4240863320156963"
                 data-ad-slot="3548309138"
                 data-ad-format="auto"
                 data-full-width-responsive="true"></ins>
          </div>
          </div>
        </section>

        <section class="panel __REMOVE_PANEL_ACTIVE__" id="panel-remove">
          <div class="tool-card">
            <p class="tool-title" data-i18n="remove.title">AI Object Remover</p>
            <p class="tool-subtitle" data-i18n="remove.subtitle">Paint unwanted parts and lift to remove. Download is enabled only after each removal finishes.</p>
          <div class="ad-wrap">
            <ins class="adsbygoogle"
                 style="display:block"
                 data-ad-client="ca-pub-4240863320156963"
                 data-ad-slot="3548309138"
                 data-ad-format="auto"
                 data-full-width-responsive="true"></ins>
          </div>
          <div class="grid">
            <div class="full">
              <label for="removeImage" data-i18n="field.imageFile">Image File</label>
              <div class="file-picker">
                <button type="button" class="alt" data-file-target="removeImage" data-i18n="btn.chooseFile">Choose File</button>
                <span class="file-picker-name" id="removeImageName" data-i18n="status.noFileChosen">No file chosen</span>
                <input id="removeImage" type="file" accept="image/*" />
              </div>
            </div>
            <div>
              <label for="removeBrushSize" data-i18n="remove.brushSize">Removal Pen Size</label>
              <div class="brush-control">
                <button type="button" class="alt brush-step" id="removeBrushDownBtn" data-i18n-aria-label="remove.brushDownAria" aria-label="Decrease brush size">-</button>
                <input id="removeBrushSize" type="range" min="4" max="120" step="1" value="28" />
                <button type="button" class="alt brush-step" id="removeBrushUpBtn" data-i18n-aria-label="remove.brushUpAria" aria-label="Increase brush size">+</button>
                <span class="brush-value" id="removeBrushSizeValue">28 px</span>
              </div>
            </div>
            <div class="full">
              <label data-i18n="remove.algorithm">Removal Algorithm</label>
              <div class="remove-algo-group" id="removeAlgoGroup" role="radiogroup" data-i18n-aria-label="remove.algorithm" aria-label="Removal Algorithm">
                <label class="remove-algo-option">
                  <input type="radio" name="removeAlgorithm" value="aggressive" />
                  <span class="remove-algo-title" data-i18n="remove.algorithm.aggressive">Aggressive (Object Erase)</span>
                  <span class="remove-algo-desc" data-i18n="remove.algorithm.aggressive.desc">Fastest mode for quick object erase on labels, logos, text, and hard edges.</span>
                </label>
                <label class="remove-algo-option">
                  <input type="radio" name="removeAlgorithm" value="ai" checked />
                  <span class="remove-algo-title" data-i18n="remove.algorithm.ai">AI Generative (Client-side)</span>
                  <span class="remove-algo-desc" data-i18n="remove.algorithm.ai.desc">Best quality (slower): stronger object removal with cleaner generated background fill.</span>
                </label>
                <label class="remove-algo-option">
                  <input type="radio" name="removeAlgorithm" value="texture" />
                  <span class="remove-algo-title" data-i18n="remove.algorithm.texture">Texture Preserve</span>
                  <span class="remove-algo-desc" data-i18n="remove.algorithm.texture.desc">Best for wood grain, fabric, concrete, and noisy/patterned surfaces to keep natural texture.</span>
                </label>
                <label class="remove-algo-option">
                  <input type="radio" name="removeAlgorithm" value="natural" />
                  <span class="remove-algo-title" data-i18n="remove.algorithm.natural">Natural (Smooth)</span>
                  <span class="remove-algo-desc" data-i18n="remove.algorithm.natural.desc">Best for skies, walls, skin, and soft blur backgrounds where you want smooth blending.</span>
                </label>
              </div>
            </div>
            <div class="full remove-shell">
              <div class="remove-toolbar">
                <button type="button" class="alt" id="removeZoomOutBtn" data-i18n="btn.zoomOut">Zoom -</button>
                <button type="button" class="alt" id="removeZoomResetBtn" data-i18n="btn.zoomReset">Reset Zoom</button>
                <button type="button" class="alt" id="removeZoomInBtn" data-i18n="btn.zoomIn">Zoom +</button>
                <span class="zoom-readout" id="removeZoomLabel">100%</span>
                <button type="button" class="alt" id="removeUndoBtn" data-i18n="btn.back"><- Back</button>
              </div>
              <div class="remove-workspace-frame">
                <div class="remove-workspace" id="removeWorkspace">
                  <div class="remove-stage" id="removeStage">
                    <canvas id="removeCanvas" width="860" height="480"></canvas>
                  </div>
                </div>
                <div class="remove-empty" id="removeEmptyState">
                  <div class="remove-empty-card">
                    <p class="remove-empty-title">üñåÔ∏è</p>
                    <p class="remove-empty-text" data-i18n="remove.empty.title">Upload an image, then paint to remove.</p>
                    <p class="remove-empty-sub" data-i18n="remove.empty.sub">Lift finger or mouse to auto-apply removal.</p>
                  </div>
                </div>
                <div class="remove-busy-overlay" id="removeBusyOverlay"></div>
              </div>
              <p class="note" data-i18n="remove.instructions">Paint over the object to remove. You can zoom in/out for precise edits.</p>
              <p class="note note-highlight" data-i18n="remove.progressWarning">If you close or refresh this browser tab, removal progress will be lost.</p>
            </div>
            <div class="full">
              <button type="button" class="alt" id="removeDownloadBtn" disabled data-i18n="btn.downloadWhenReady">Download Result</button>
            </div>
          </div>
          <div class="status" id="removeStatus" aria-live="polite"></div>
          <div class="ad-wrap bottom">
            <ins class="adsbygoogle"
                 style="display:block"
                 data-ad-client="ca-pub-4240863320156963"
                 data-ad-slot="3548309138"
                 data-ad-format="auto"
                 data-full-width-responsive="true"></ins>
          </div>
          </div>
        </section>
      </section>
    </main>

    <script>
      window.__PAGE_CONFIG__ = __PAGE_CONFIG_JSON__;

      document.querySelectorAll('.adsbygoogle').forEach(() => {
        try { (adsbygoogle = window.adsbygoogle || []).push({}); } catch (_e) {}
      });

      const pageConfig = window.__PAGE_CONFIG__ || {};
      const locale = pageConfig.locale || 'en';
      const i18n = {
        en: {
          'lang.label': 'Language',
          'flow.upload': '1. Upload',
          'flow.adjust': '2. Adjust',
          'flow.download': '3. Download',
          'flow.privacy': 'We never save your images',
          'flow.allInOne': 'All-in-one image toolkit: convert, crop, compress, upscale, and AI remove.',
          'tab.convert': 'Convert',
          'tab.crop': 'Crop',
          'tab.compress': 'Compress',
          'tab.upscale': 'Upscale',
          'tab.remove': 'AI Remove',
          'oss.prefix': 'Open source:',
          'oss.link': 'GitHub repo',
          'oss.suffix': 'Deploy your own version.',
          'convert.title': 'Convert Images',
          'convert.subtitle': 'Change image format while keeping quality under your control.',
          'crop.title': 'Crop Images',
          'crop.subtitle': 'Use the crop frame to focus only on the area you want, then optionally resize.',
          'compress.title': 'Compress Images',
          'compress.subtitle': 'Reduce file size while preserving the same pixel dimensions.',
          'upscale.title': 'Upscale Images',
          'upscale.subtitle': 'AI Enhance upscale that can recover perceived detail, not just stretch pixels.',
          'remove.title': 'AI Object Remover',
          'remove.subtitle': 'Paint unwanted parts and lift to remove. Download is enabled only after each removal finishes.',
          'field.imageFile': 'Image File',
          'field.outputFormat': 'Output Format',
          'field.quality': 'Quality (1-100)',
          'compress.quality': 'Compression Quality (1-100)',
          'upscale.scale': 'Scale',
          'upscale.quality': 'Output Quality (1-100)',
          'upscale.restoreMode': 'Restore Mode',
          'upscale.restore.balanced': 'Balanced',
          'upscale.restore.aggressive': 'Aggressive',
          'upscale.restore.logo': 'Text/Logo',
          'upscale.restore.helpTitle': 'Which restore mode should I use?',
          'upscale.restore.help.balanced': 'Safer default for most photos and mixed content.',
          'upscale.restore.help.aggressive': 'Stronger deblock and sharpening, may add halos/noise.',
          'upscale.restore.help.logo': 'Prioritizes hard edges for logos, icons, and text-like shapes.',
          'btn.convertDownload': 'Convert and Download',
          'btn.chooseFile': 'Choose File',
          'btn.resetBox': 'Reset Box',
          'btn.confirmCropDownload': 'Confirm Crop and Download',
          'btn.compressDownload': 'Compress and Download',
          'btn.upscaleDownload': 'Upscale and Download',
          'btn.removeObject': 'Remove Object',
          'btn.downloadWhenReady': 'Download Result',
          'btn.zoomIn': 'Zoom +',
          'btn.zoomOut': 'Zoom -',
          'btn.zoomReset': 'Reset Zoom',
          'btn.back': '<- Back',
          'btn.continue': 'Continue',
          'btn.cancel': 'Cancel',
          'crop.instructions': 'Drag inside the box to move. Drag corners to resize. Use Confirm Crop when ready.',
          'crop.aspectRatio': 'Aspect Ratio',
          'crop.ratio.free': 'Free',
          'crop.resizeAfter': 'Resize after crop',
          'crop.resizeExplain':
            'If enabled, the cropped image is scaled down to fit within the width/height you provide. It keeps aspect ratio and will not stretch.',
          'crop.resizeWidth': 'Resize Width',
          'crop.resizeHeight': 'Resize Height',
          'compress.note': 'Compress keeps the same pixel dimensions. It only reduces encoded quality/size.',
          'upscale.note': 'AI Enhance can improve sharpness and texture, but it cannot perfectly recreate missing detail.',
          'upscale.note2': 'Very blurry or tiny sources may still look soft. First run downloads a larger ESRGAN model in your browser.',
          'upscale.note3': 'Expected first-run data: about 31 MB total (model + AI runtime), then cached by browser.',
          'upscale.note4': '4x runs two AI passes, so it is much slower than 2x.',
          'remove.brushSize': 'Removal Pen Size',
          'remove.brushDownAria': 'Decrease brush size',
          'remove.brushUpAria': 'Increase brush size',
          'remove.algorithm': 'Removal Algorithm',
          'remove.algorithm.natural': 'Natural (Smooth)',
          'remove.algorithm.natural.desc': 'Best for skies, walls, skin, and soft blur backgrounds where you want smooth blending.',
          'remove.algorithm.aggressive': 'Aggressive (Object Erase)',
          'remove.algorithm.aggressive.desc': 'Fastest mode for quick object erase on labels, logos, text, and hard edges.',
          'remove.algorithm.ai': 'AI Generative (Client-side)',
          'remove.algorithm.ai.desc': 'Best quality (slower): stronger object removal with cleaner generated background fill.',
          'remove.algorithm.texture': 'Texture Preserve',
          'remove.algorithm.texture.desc': 'Best for wood grain, fabric, concrete, and noisy/patterned surfaces to keep natural texture.',
          'remove.instructions': 'Paint over the object to remove. You can zoom in/out for precise edits.',
          'remove.empty.title': 'Upload an image, then paint to remove.',
          'remove.empty.sub': 'Lift finger or mouse to auto-apply removal.',
          'remove.progressWarning': 'If you close or refresh this browser tab, removal progress will be lost.',
          'upscale.progressIdle': 'Waiting to start AI enhance.',
          'upscale.confirmUse': 'AI Enhance may download about 31 MB on first run and can take time. Continue?',
          'hero.convert.title': 'Free Image Converter',
          'hero.convert.subtitle': 'Convert JPG, PNG, WEBP, and AVIF directly in your browser.',
          'hero.crop.title': 'Free Image Cropper',
          'hero.crop.subtitle': 'Drag, resize, and export exact crop areas with optional resize after crop.',
          'hero.compress.title': 'Free Image Compressor',
          'hero.compress.subtitle': 'Reduce image file size while keeping dimensions.',
          'hero.upscale.title': 'Free Image Upscaler',
          'hero.upscale.subtitle': 'AI Enhance runs on your device to upscale at 2x or 4x with practical quality limits.',
          'hero.remove.title': 'Free AI Object Remover',
          'hero.remove.subtitle': 'Paint, remove unwanted areas, then confirm download after processing.',
          'seo.relatedPages': 'Related pages',
          'status.chooseImage': 'Choose an image first.',
          'status.uploadFirst': 'Upload an image first.',
          'status.converting': 'Converting...',
          'status.compressing': 'Compressing (same dimensions)...',
          'status.upscaling': 'Upscaling image...',
          'status.aiInit': 'Preparing AI engine...',
          'status.aiModelLoad': 'Loading AI model (~31 MB on first run)...',
          'status.aiEnhancingPass': 'AI enhancing pass {pass}/{total}...',
          'status.aiPreprocess': 'Restoring before AI upscale...',
          'status.aiPostprocess': 'Enhancing edges after AI upscale...',
          'status.aiFinalizing': 'Finalizing output and downloading...',
          'status.cropProcessing': 'Processing crop...',
          'status.removing': 'Removing selected object...',
          'status.removeReady': 'Removal finished. Review and click Download Result.',
          'status.removeMaskEmpty': 'Paint at least one area to remove first.',
          'status.removeUndoDone': 'Undid last removal.',
          'status.noFileChosen': 'No file chosen',
          'status.doneDownload': 'Done. Download started.',
          'status.cancelled': 'Cancelled.',
          'status.cropDone': 'Crop confirmed. Download started.',
          'status.compressDone': 'Compression done. Download started.',
          'status.upscaleDone': 'Upscale done. Download started.',
          'status.previewIos': 'Preview opened. On iPhone tap Share, then Save Image.',
          'status.imageLoaded': 'Image loaded. Adjust crop and confirm.',
          'status.removeImageLoaded': 'Image loaded. Paint the area to remove and lift to apply removal.',
          'status.loadFailed': 'Failed to load image.',
          'status.cropReset': 'Crop box reset.',
          'status.removeCanvasPrompt': 'Upload an image, then paint the area to remove',
          'status.cropCanvasPrompt': 'Upload an image to crop',
          'error.notSupported': '{format} export is not supported in this browser.',
          'error.resizeParams': 'Provide resize width and/or height.',
          'error.convertFailed': 'Convert failed.',
          'error.cropFailed': 'Crop failed.',
          'error.compressFailed': 'Compress failed.',
          'error.upscaleFailed': 'Upscale failed.',
          'error.removeFailed': 'Object removal failed.',
          'error.upscaleTooLarge': 'Image is too large for AI Enhance in browser. Keep it under about {maxMp} MP for this scale.',
          'ph.resizeWidth': 'e.g. 800',
          'ph.resizeHeight': 'e.g. 600'
        },
        es: {
          'lang.label': 'Idioma',
          'flow.upload': '1. Subir',
          'flow.adjust': '2. Ajustar',
          'flow.download': '3. Descargar',
          'flow.privacy': 'Nunca guardamos tus imagenes',
          'flow.allInOne': 'Kit todo en uno: convertir, recortar, comprimir, mejorar y eliminar con IA.',
          'tab.convert': 'Convertir',
          'tab.crop': 'Recortar',
          'tab.compress': 'Comprimir',
          'tab.upscale': 'Mejorar',
          'oss.prefix': 'Codigo abierto:',
          'oss.link': 'Repositorio en GitHub',
          'oss.suffix': 'Despliega tu propia version.',
          'convert.title': 'Convertir imagenes',
          'convert.subtitle': 'Cambia el formato de imagen con control de calidad.',
          'crop.title': 'Recortar imagenes',
          'crop.subtitle': 'Usa el marco de recorte y, si quieres, cambia el tamano.',
          'compress.title': 'Comprimir imagenes',
          'compress.subtitle': 'Reduce el tamano del archivo manteniendo las dimensiones.',
          'upscale.title': 'Mejorar resolucion',
          'upscale.subtitle': 'Aumenta la resolucion de la imagen en tu dispositivo con un escalado practico.',
          'field.imageFile': 'Archivo de imagen',
          'field.outputFormat': 'Formato de salida',
          'field.quality': 'Calidad (1-100)',
          'compress.quality': 'Calidad de compresion (1-100)',
          'upscale.scale': 'Escala',
          'upscale.quality': 'Calidad de salida (1-100)',
          'upscale.restoreMode': 'Modo de restauracion',
          'upscale.restore.balanced': 'Equilibrado',
          'upscale.restore.aggressive': 'Agresivo',
          'upscale.restore.logo': 'Texto/Logo',
          'upscale.restore.helpTitle': 'Que modo de restauracion debo usar?',
          'upscale.restore.help.balanced': 'Opcion mas segura para fotos y contenido mixto.',
          'upscale.restore.help.aggressive': 'Deblock y enfoque mas fuertes; puede generar halos/ruido.',
          'upscale.restore.help.logo': 'Prioriza bordes duros para logos, iconos y formas de texto.',
          'btn.convertDownload': 'Convertir y descargar',
          'btn.chooseFile': 'Elegir archivo',
          'btn.resetBox': 'Restablecer caja',
          'btn.confirmCropDownload': 'Confirmar recorte y descargar',
          'btn.compressDownload': 'Comprimir y descargar',
          'btn.upscaleDownload': 'Mejorar y descargar',
          'btn.zoomIn': 'Zoom +',
          'btn.zoomOut': 'Zoom -',
          'btn.zoomReset': 'Restablecer zoom',
          'btn.continue': 'Continuar',
          'btn.cancel': 'Cancelar',
          'crop.instructions': 'Arrastra dentro para mover. Arrastra esquinas para cambiar tamano.',
          'crop.aspectRatio': 'Relacion de aspecto',
          'crop.ratio.free': 'Libre',
          'crop.resizeAfter': 'Redimensionar despues de recortar',
          'crop.resizeExplain': 'Si lo activas, la imagen recortada se ajusta al ancho/alto indicado sin deformar.',
          'crop.resizeWidth': 'Ancho',
          'crop.resizeHeight': 'Alto',
          'compress.note': 'Comprimir mantiene las mismas dimensiones de pixeles.',
          'upscale.note': 'Para mantener velocidad y estabilidad, salidas muy grandes pueden limitarse automaticamente.',
          'upscale.note2': 'Las imagenes muy borrosas o pequenas pueden seguir viendose suaves. En la primera ejecucion se descarga un modelo ESRGAN mas grande en tu navegador.',
          'upscale.note3': 'Datos esperados en la primera ejecucion: alrededor de 31 MB en total (modelo + runtime de IA), luego queda en cache del navegador.',
          'upscale.note4': '4x ejecuta dos pasadas de IA, por lo que es mucho mas lento que 2x.',
          'hero.convert.title': 'Convertidor de imagenes gratis',
          'hero.convert.subtitle': 'Convierte JPG, PNG, WEBP y AVIF directamente en tu navegador.',
          'hero.crop.title': 'Recortador de imagenes gratis',
          'hero.crop.subtitle': 'Arrastra, redimensiona y exporta recortes exactos con cambio de tamano opcional.',
          'hero.compress.title': 'Compresor de imagenes gratis',
          'hero.compress.subtitle': 'Reduce el tamano del archivo manteniendo las dimensiones.',
          'hero.upscale.title': 'Mejorador de imagenes gratis',
          'hero.upscale.subtitle': 'AI Enhance se ejecuta en tu dispositivo para ampliar a 2x o 4x con limites practicos.',
          'seo.relatedPages': 'Paginas relacionadas',
          'status.chooseImage': 'Elige una imagen primero.',
          'status.uploadFirst': 'Sube una imagen primero.',
          'status.converting': 'Convirtiendo...',
          'status.compressing': 'Comprimiendo (mismas dimensiones)...',
          'status.upscaling': 'Mejorando resolucion...',
          'status.cropProcessing': 'Procesando recorte...',
          'status.doneDownload': 'Listo. Descarga iniciada.',
          'status.cropDone': 'Recorte confirmado. Descarga iniciada.',
          'status.compressDone': 'Compresion lista. Descarga iniciada.',
          'status.upscaleDone': 'Mejora lista. Descarga iniciada.',
          'status.previewIos': 'Vista previa abierta. En iPhone, toca Share y luego Save Image.',
          'status.imageLoaded': 'Imagen cargada. Ajusta y confirma el recorte.',
          'status.loadFailed': 'No se pudo cargar la imagen.',
          'status.cropReset': 'Caja de recorte reiniciada.',
          'status.noFileChosen': 'Ningun archivo seleccionado',
          'status.cropCanvasPrompt': 'Sube una imagen para recortar',
          'error.notSupported': 'La exportacion {format} no es compatible con este navegador.',
          'error.resizeParams': 'Indica ancho y/o alto para redimensionar.',
          'error.convertFailed': 'Fallo al convertir.',
          'error.cropFailed': 'Fallo al recortar.',
          'error.compressFailed': 'Fallo al comprimir.',
          'error.upscaleFailed': 'Fallo al mejorar resolucion.',
          'ph.resizeWidth': 'p. ej. 800',
          'ph.resizeHeight': 'p. ej. 600'
        },
        zh: {
          'lang.label': 'ËØ≠Ë®Ä',
          'flow.upload': '1. ‰∏ä‰º†',
          'flow.adjust': '2. Ë∞ÉÊï¥',
          'flow.download': '3. ‰∏ãËΩΩ',
          'flow.privacy': 'Êàë‰ª¨‰∏ç‰ºö‰øùÂ≠ò‰Ω†ÁöÑÂõæÁâá',
          'flow.allInOne': '‰∏ÄÁ´ôÂºèÂõæÁâáÂ∑•ÂÖ∑ÔºöËΩ¨Êç¢„ÄÅË£ÅÂâ™„ÄÅÂéãÁº©„ÄÅÊîæÂ§ß„ÄÅAIÊ∂àÈô§„ÄÇ',
          'tab.convert': 'ËΩ¨Êç¢',
          'tab.crop': 'Ë£ÅÂâ™',
          'tab.compress': 'ÂéãÁº©',
          'tab.upscale': 'ÊîæÂ§ß',
          'oss.prefix': 'ÂºÄÊ∫êÈ°πÁõÆÔºö',
          'oss.link': 'GitHub ‰ªìÂ∫ì',
          'oss.suffix': 'ÂèØÈÉ®ÁΩ≤‰Ω†Ëá™Â∑±ÁöÑÁâàÊú¨„ÄÇ',
          'convert.title': 'ËΩ¨Êç¢ÂõæÁâá',
          'convert.subtitle': 'Âú®‰øùËØÅË¥®ÈáèÂèØÊéßÁöÑÊÉÖÂÜµ‰∏ãËΩ¨Êç¢ÂõæÁâáÊ†ºÂºè„ÄÇ',
          'crop.title': 'Ë£ÅÂâ™ÂõæÁâá',
          'crop.subtitle': '‰ΩøÁî®Ë£ÅÂâ™Ê°ÜÈÄâÊã©Âå∫ÂüüÔºåÂπ∂ÂèØÂú®Ë£ÅÂâ™ÂêéË∞ÉÊï¥Â∞∫ÂØ∏„ÄÇ',
          'compress.title': 'ÂéãÁº©ÂõæÁâá',
          'compress.subtitle': 'Âú®‰øùÊåÅÂÉèÁ¥†Â∞∫ÂØ∏‰∏çÂèòÁöÑÂâçÊèê‰∏ãÂáèÂ∞èÊñá‰ª∂‰ΩìÁßØ„ÄÇ',
          'upscale.title': 'ÊîæÂ§ßÂõæÁâá',
          'upscale.subtitle': 'Âú®‰Ω†ÁöÑËÆæÂ§á‰∏äÊèêÈ´òÂõæÁâáÂàÜËæ®ÁéáÔºåÈááÁî®ÂÆûÁî®‰∏îÁ®≥ÂÆöÁöÑÊîæÂ§ßÊñπÂºè„ÄÇ',
          'field.imageFile': 'ÂõæÁâáÊñá‰ª∂',
          'field.outputFormat': 'ËæìÂá∫Ê†ºÂºè',
          'field.quality': 'Ë¥®Èáè (1-100)',
          'compress.quality': 'ÂéãÁº©Ë¥®Èáè (1-100)',
          'upscale.scale': 'ÊîæÂ§ßÂÄçÊï∞',
          'upscale.quality': 'ËæìÂá∫Ë¥®Èáè (1-100)',
          'upscale.restoreMode': '‰øÆÂ§çÊ®°Âºè',
          'upscale.restore.balanced': 'ÂùáË°°',
          'upscale.restore.aggressive': 'Âº∫Âäõ',
          'upscale.restore.logo': 'ÊñáÂ≠ó/Logo',
          'upscale.restore.helpTitle': 'ËØ•ÈÄâÂì™Áßç‰øÆÂ§çÊ®°ÂºèÔºü',
          'upscale.restore.help.balanced': 'ÈÄÇÂêàÂ§ßÂ§öÊï∞ÁÖßÁâáÂíåÊ∑∑ÂêàÂÜÖÂÆπÔºåÊõ¥Á®≥Â¶•„ÄÇ',
          'upscale.restore.help.aggressive': 'Êõ¥Âº∫ÂéªÂùóÂíåÈîêÂåñÔºåÂèØËÉΩÂá∫Áé∞ÂÖâÊôïÊàñÂô™ÁÇπ„ÄÇ',
          'upscale.restore.help.logo': '‰ºòÂÖàÂº∫ÂåñÁ°¨ËæπÔºåÈÄÇÂêà Logo„ÄÅÂõæÊ†áÂíåÊñáÂ≠óÂΩ¢Áä∂„ÄÇ',
          'btn.convertDownload': 'ËΩ¨Êç¢Âπ∂‰∏ãËΩΩ',
          'btn.chooseFile': 'ÈÄâÊã©Êñá‰ª∂',
          'btn.resetBox': 'ÈáçÁΩÆË£ÅÂâ™Ê°Ü',
          'btn.confirmCropDownload': 'Á°ÆËÆ§Ë£ÅÂâ™Âπ∂‰∏ãËΩΩ',
          'btn.compressDownload': 'ÂéãÁº©Âπ∂‰∏ãËΩΩ',
          'btn.upscaleDownload': 'ÊîæÂ§ßÂπ∂‰∏ãËΩΩ',
          'btn.zoomIn': 'ÊîæÂ§ß +',
          'btn.zoomOut': 'Áº©Â∞è -',
          'btn.zoomReset': 'ÈáçÁΩÆÁº©Êîæ',
          'btn.continue': 'ÁªßÁª≠',
          'btn.cancel': 'ÂèñÊ∂à',
          'crop.instructions': 'Âú®Ê°ÜÂÜÖÊãñÂä®ÂèØÁßªÂä®ÔºåÊãñÂä®ËßíÁÇπÂèØË∞ÉÊï¥Â§ßÂ∞è„ÄÇ',
          'crop.aspectRatio': 'ÂÆΩÈ´òÊØî',
          'crop.ratio.free': 'Ëá™Áî±',
          'crop.resizeAfter': 'Ë£ÅÂâ™ÂêéË∞ÉÊï¥Â∞∫ÂØ∏',
          'crop.resizeExplain': 'ÂêØÁî®ÂêéÔºåË£ÅÂâ™ÁªìÊûú‰ºöÊåâ‰Ω†Â°´ÂÜôÁöÑÂÆΩÈ´òÁ≠âÊØîÁº©Â∞èÔºå‰∏ç‰ºöÊãâ‰º∏„ÄÇ',
          'crop.resizeWidth': 'ÂÆΩÂ∫¶',
          'crop.resizeHeight': 'È´òÂ∫¶',
          'compress.note': 'ÂéãÁº©‰ªÖÈôç‰ΩéÁºñÁ†Å‰ΩìÁßØÔºå‰∏çÊîπÂèòÂÉèÁ¥†Â∞∫ÂØ∏„ÄÇ',
          'upscale.note': '‰∏∫‰øùËØÅÈÄüÂ∫¶‰∏éÁ®≥ÂÆöÊÄßÔºåË∂ÖÂ§ßËæìÂá∫‰ºöËá™Âä®ÈôêÂà∂Âà∞ÂÆâÂÖ®Â∞∫ÂØ∏„ÄÇ',
          'upscale.note2': 'Ê∫êÂõæËøáÂ∞èÊàñËøáÊ®°Á≥äÊó∂ÔºåÁªìÊûú‰ªçÂèØËÉΩÂÅèËΩØ„ÄÇÈ¶ñÊ¨°ËøêË°å‰ºöÂú®ÊµèËßàÂô®‰∏ãËΩΩÊõ¥Â§ßÁöÑ ESRGAN Ê®°Âûã„ÄÇ',
          'upscale.note3': 'È¶ñÊ¨°ËøêË°åÈ¢ÑËÆ°‰∏ãËΩΩÊï∞ÊçÆÔºöÊÄªËÆ°Á∫¶ 31 MBÔºàÊ®°Âûã + AI ËøêË°åÊó∂ÔºâÔºå‰πãÂêé‰ºöË¢´ÊµèËßàÂô®ÁºìÂ≠ò„ÄÇ',
          'upscale.note4': '4x ‰ºöÊâßË°å‰∏§Ê¨° AI Â§ÑÁêÜÔºåÂõ†Ê≠§‰ºöÊØî 2x ÊÖ¢ÂæàÂ§ö„ÄÇ',
          'hero.convert.title': 'ÂÖçË¥πÂõæÁâáËΩ¨Êç¢Âô®',
          'hero.convert.subtitle': 'Âú®ÊµèËßàÂô®‰∏≠Áõ¥Êé•ËΩ¨Êç¢ JPG„ÄÅPNG„ÄÅWEBP„ÄÅAVIF„ÄÇ',
          'hero.crop.title': 'ÂÖçË¥πÂõæÁâáË£ÅÂâ™Âô®',
          'hero.crop.subtitle': 'ÊãñÊãΩÂπ∂ÂØºÂá∫Á≤æÁ°ÆË£ÅÂâ™Âå∫ÂüüÔºåÊîØÊåÅÂèØÈÄâÁº©Êîæ„ÄÇ',
          'hero.compress.title': 'ÂÖçË¥πÂõæÁâáÂéãÁº©Âô®',
          'hero.compress.subtitle': 'Âú®‰øùÊåÅÂ∞∫ÂØ∏ÁöÑÂâçÊèê‰∏ãÂáèÂ∞èÊñá‰ª∂‰ΩìÁßØ„ÄÇ',
          'hero.upscale.title': 'ÂÖçË¥πÂõæÁâáÊîæÂ§ßÂô®',
          'hero.upscale.subtitle': 'AI Enhance Âú®‰Ω†ÁöÑËÆæÂ§á‰∏äËøêË°åÔºåÊîØÊåÅ 2x/4x ÂÆûÁî®ÊîæÂ§ß„ÄÇ',
          'seo.relatedPages': 'Áõ∏ÂÖ≥È°µÈù¢',
          'status.chooseImage': 'ËØ∑ÂÖàÈÄâÊã©ÂõæÁâá„ÄÇ',
          'status.uploadFirst': 'ËØ∑ÂÖà‰∏ä‰º†ÂõæÁâá„ÄÇ',
          'status.converting': 'Ê≠£Âú®ËΩ¨Êç¢...',
          'status.compressing': 'Ê≠£Âú®ÂéãÁº©Ôºà‰øùÊåÅÂ∞∫ÂØ∏Ôºâ...',
          'status.upscaling': 'Ê≠£Âú®ÊîæÂ§ßÂõæÁâá...',
          'status.cropProcessing': 'Ê≠£Âú®Â§ÑÁêÜË£ÅÂâ™...',
          'status.doneDownload': 'ÂÆåÊàêÔºåÂºÄÂßã‰∏ãËΩΩ„ÄÇ',
          'status.cropDone': 'Ë£ÅÂâ™ÂÆåÊàêÔºåÂºÄÂßã‰∏ãËΩΩ„ÄÇ',
          'status.compressDone': 'ÂéãÁº©ÂÆåÊàêÔºåÂºÄÂßã‰∏ãËΩΩ„ÄÇ',
          'status.upscaleDone': 'ÊîæÂ§ßÂÆåÊàêÔºåÂºÄÂßã‰∏ãËΩΩ„ÄÇ',
          'status.previewIos': 'Â∑≤ÊâìÂºÄÈ¢ÑËßà„ÄÇiPhone ‰∏äËØ∑ÁÇπ Share ÂÜçÁÇπ Save Image„ÄÇ',
          'status.imageLoaded': 'ÂõæÁâáÂ∑≤Âä†ËΩΩÔºåËØ∑Ë∞ÉÊï¥ÂêéÁ°ÆËÆ§Ë£ÅÂâ™„ÄÇ',
          'status.loadFailed': 'ÂõæÁâáÂä†ËΩΩÂ§±Ë¥•„ÄÇ',
          'status.cropReset': 'Ë£ÅÂâ™Ê°ÜÂ∑≤ÈáçÁΩÆ„ÄÇ',
          'status.noFileChosen': 'Êú™ÈÄâÊã©Êñá‰ª∂',
          'status.cropCanvasPrompt': '‰∏ä‰º†‰∏ÄÂº†ÂõæÁâáÂºÄÂßãË£ÅÂâ™',
          'error.notSupported': 'ÂΩìÂâçÊµèËßàÂô®‰∏çÊîØÊåÅÂØºÂá∫ {format}„ÄÇ',
          'error.resizeParams': 'ËØ∑Â°´ÂÜôÁº©ÊîæÂÆΩÂ∫¶Âíå/ÊàñÈ´òÂ∫¶„ÄÇ',
          'error.convertFailed': 'ËΩ¨Êç¢Â§±Ë¥•„ÄÇ',
          'error.cropFailed': 'Ë£ÅÂâ™Â§±Ë¥•„ÄÇ',
          'error.compressFailed': 'ÂéãÁº©Â§±Ë¥•„ÄÇ',
          'error.upscaleFailed': 'ÊîæÂ§ßÂ§±Ë¥•„ÄÇ',
          'ph.resizeWidth': '‰æãÂ¶Ç 800',
          'ph.resizeHeight': '‰æãÂ¶Ç 600'
        },
        hi: {
          'lang.label': '‡§≠‡§æ‡§∑‡§æ',
          'flow.upload': '1. ‡§Ö‡§™‡§≤‡•ã‡§°',
          'flow.adjust': '2. ‡§è‡§°‡§ú‡§∏‡•ç‡§ü',
          'flow.download': '3. ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§°',
          'flow.privacy': '‡§π‡§Æ ‡§Ü‡§™‡§ï‡•Ä ‡§á‡§Æ‡•á‡§ú ‡§∏‡•á‡§µ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞‡§§‡•á',
          'flow.allInOne': '‡§ë‡§≤-‡§á‡§®-‡§µ‡§® ‡§á‡§Æ‡•á‡§ú ‡§ü‡•Ç‡§≤‡§ï‡§ø‡§ü: ‡§ï‡§®‡•ç‡§µ‡§∞‡•ç‡§ü, ‡§ï‡•ç‡§∞‡•â‡§™, ‡§ï‡§Ç‡§™‡•ç‡§∞‡•á‡§∏, ‡§Ö‡§™‡§∏‡•ç‡§ï‡•á‡§≤ ‡§î‡§∞ AI ‡§∞‡§ø‡§Æ‡•Ç‡§µ‡•§',
          'tab.convert': '‡§ï‡§®‡•ç‡§µ‡§∞‡•ç‡§ü',
          'tab.crop': '‡§ï‡•ç‡§∞‡•â‡§™',
          'tab.compress': '‡§ï‡§Ç‡§™‡•ç‡§∞‡•á‡§∏',
          'tab.upscale': '‡§Ö‡§™‡§∏‡•ç‡§ï‡•á‡§≤',
          'oss.prefix': '‡§ì‡§™‡§® ‡§∏‡•ã‡§∞‡•ç‡§∏:',
          'oss.link': 'GitHub ‡§∞‡§ø‡§™‡•â‡§ú‡§ø‡§ü‡§∞‡•Ä',
          'oss.suffix': '‡§Ö‡§™‡§®‡§æ ‡§µ‡§∞‡•ç‡§ú‡§® ‡§ñ‡•Å‡§¶ ‡§°‡§ø‡§™‡•ç‡§≤‡•â‡§Ø ‡§ï‡§∞‡•á‡§Ç‡•§',
          'convert.title': '‡§á‡§Æ‡•á‡§ú ‡§ï‡§®‡•ç‡§µ‡§∞‡•ç‡§ü ‡§ï‡§∞‡•á‡§Ç',
          'convert.subtitle': '‡§ï‡•ç‡§µ‡§æ‡§≤‡§ø‡§ü‡•Ä ‡§®‡§ø‡§Ø‡§Ç‡§§‡•ç‡§∞‡§£ ‡§ï‡•á ‡§∏‡§æ‡§• ‡§´‡•â‡§∞‡•ç‡§Æ‡•á‡§ü ‡§¨‡§¶‡§≤‡•á‡§Ç‡•§',
          'crop.title': '‡§á‡§Æ‡•á‡§ú ‡§ï‡•ç‡§∞‡•â‡§™ ‡§ï‡§∞‡•á‡§Ç',
          'crop.subtitle': '‡§ï‡•ç‡§∞‡•â‡§™ ‡§¨‡•â‡§ï‡•ç‡§∏ ‡§∏‡•á ‡§π‡§ø‡§∏‡•ç‡§∏‡§æ ‡§ö‡•Å‡§®‡•á‡§Ç, ‡§´‡§ø‡§∞ ‡§ú‡§∞‡•Ç‡§∞‡§§ ‡§π‡•ã ‡§§‡•ã ‡§∞‡§ø‡§∏‡§æ‡§á‡§ú‡§º ‡§ï‡§∞‡•á‡§Ç‡•§',
          'compress.title': '‡§á‡§Æ‡•á‡§ú ‡§ï‡§Ç‡§™‡•ç‡§∞‡•á‡§∏ ‡§ï‡§∞‡•á‡§Ç',
          'compress.subtitle': '‡§™‡§ø‡§ï‡•ç‡§∏‡•á‡§≤ ‡§∏‡§æ‡§á‡§ú‡§º ‡§µ‡§π‡•Ä ‡§∞‡§ñ‡§§‡•á ‡§π‡•Å‡§è ‡§´‡§æ‡§á‡§≤ ‡§∏‡§æ‡§á‡§ú‡§º ‡§ï‡§Æ ‡§ï‡§∞‡•á‡§Ç‡•§',
          'upscale.title': '‡§á‡§Æ‡•á‡§ú ‡§Ö‡§™‡§∏‡•ç‡§ï‡•á‡§≤ ‡§ï‡§∞‡•á‡§Ç',
          'upscale.subtitle': '‡§µ‡•ç‡§Ø‡§æ‡§µ‡§π‡§æ‡§∞‡§ø‡§ï ‡§∏‡•ç‡§ï‡•á‡§≤‡§ø‡§Ç‡§ó ‡§ï‡•á ‡§∏‡§æ‡§• ‡§Ö‡§™‡§®‡•á ‡§°‡§ø‡§µ‡§æ‡§á‡§∏ ‡§™‡§∞ ‡§á‡§Æ‡•á‡§ú ‡§∞‡§ø‡§ú‡•â‡§≤‡•ç‡§Ø‡•Ç‡§∂‡§® ‡§¨‡§¢‡§º‡§æ‡§è‡§Ç‡•§',
          'field.imageFile': '‡§á‡§Æ‡•á‡§ú ‡§´‡§æ‡§á‡§≤',
          'field.outputFormat': '‡§Ü‡§â‡§ü‡§™‡•Å‡§ü ‡§´‡•â‡§∞‡•ç‡§Æ‡•á‡§ü',
          'field.quality': '‡§ï‡•ç‡§µ‡§æ‡§≤‡§ø‡§ü‡•Ä (1-100)',
          'compress.quality': '‡§ï‡§Ç‡§™‡•ç‡§∞‡•á‡§∂‡§® ‡§ï‡•ç‡§µ‡§æ‡§≤‡§ø‡§ü‡•Ä (1-100)',
          'upscale.scale': '‡§∏‡•ç‡§ï‡•á‡§≤',
          'upscale.quality': '‡§Ü‡§â‡§ü‡§™‡•Å‡§ü ‡§ï‡•ç‡§µ‡§æ‡§≤‡§ø‡§ü‡•Ä (1-100)',
          'upscale.restoreMode': '‡§∞‡§ø‡§∏‡•ç‡§ü‡•ã‡§∞ ‡§Æ‡•ã‡§°',
          'upscale.restore.balanced': '‡§¨‡•à‡§≤‡•á‡§Ç‡§∏‡•ç‡§°',
          'upscale.restore.aggressive': '‡§è‡§ó‡•ç‡§∞‡•á‡§∏‡§ø‡§µ',
          'upscale.restore.logo': '‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü/‡§≤‡•ã‡§ó‡•ã',
          'upscale.restore.helpTitle': '‡§ï‡•å‡§® ‡§∏‡§æ ‡§∞‡§ø‡§∏‡•ç‡§ü‡•ã‡§∞ ‡§Æ‡•ã‡§° ‡§ö‡•Å‡§®‡•á‡§Ç?',
          'upscale.restore.help.balanced': '‡§ú‡•ç‡§Ø‡§æ‡§¶‡§æ‡§§‡§∞ ‡§´‡•ã‡§ü‡•ã ‡§î‡§∞ ‡§Æ‡§ø‡§∂‡•ç‡§∞‡§ø‡§§ ‡§ï‡§Ç‡§ü‡•á‡§Ç‡§ü ‡§ï‡•á ‡§≤‡§ø‡§è ‡§∏‡•Å‡§∞‡§ï‡•ç‡§∑‡§ø‡§§ ‡§°‡§ø‡§´‡§º‡•â‡§≤‡•ç‡§ü‡•§',
          'upscale.restore.help.aggressive': '‡§ú‡•ç‡§Ø‡§æ‡§¶‡§æ ‡§°‡•Ä‡§¨‡•ç‡§≤‡•â‡§ï ‡§î‡§∞ ‡§∂‡§æ‡§∞‡•ç‡§™‡§®; ‡§π‡•à‡§≤‡•ã/‡§®‡•â‡§á‡§ú‡§º ‡§Ü ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§',
          'upscale.restore.help.logo': '‡§≤‡•ã‡§ó‡•ã, ‡§Ü‡§á‡§ï‡§® ‡§î‡§∞ ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§ú‡•à‡§∏‡•Ä ‡§ï‡§†‡•ã‡§∞ ‡§ï‡§ø‡§®‡§æ‡§∞‡•ã‡§Ç ‡§ï‡•ã ‡§™‡•ç‡§∞‡§æ‡§•‡§Æ‡§ø‡§ï‡§§‡§æ ‡§¶‡•á‡§§‡§æ ‡§π‡•à‡•§',
          'btn.convertDownload': '‡§ï‡§®‡•ç‡§µ‡§∞‡•ç‡§ü ‡§î‡§∞ ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§°',
          'btn.chooseFile': '‡§´‡§º‡§æ‡§á‡§≤ ‡§ö‡•Å‡§®‡•á‡§Ç',
          'btn.resetBox': '‡§¨‡•â‡§ï‡•ç‡§∏ ‡§∞‡•Ä‡§∏‡•á‡§ü ‡§ï‡§∞‡•á‡§Ç',
          'btn.confirmCropDownload': '‡§ï‡•ç‡§∞‡•â‡§™ ‡§ï‡§®‡•ç‡§´‡§∞‡•ç‡§Æ ‡§î‡§∞ ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§°',
          'btn.compressDownload': '‡§ï‡§Ç‡§™‡•ç‡§∞‡•á‡§∏ ‡§î‡§∞ ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§°',
          'btn.upscaleDownload': '‡§Ö‡§™‡§∏‡•ç‡§ï‡•á‡§≤ ‡§î‡§∞ ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§°',
          'btn.zoomIn': '‡§ú‡§º‡•Ç‡§Æ +',
          'btn.zoomOut': '‡§ú‡§º‡•Ç‡§Æ -',
          'btn.zoomReset': '‡§ú‡§º‡•Ç‡§Æ ‡§∞‡•Ä‡§∏‡•á‡§ü',
          'btn.continue': '‡§ú‡§æ‡§∞‡•Ä ‡§∞‡§ñ‡•á‡§Ç',
          'btn.cancel': '‡§∞‡§¶‡•ç‡§¶ ‡§ï‡§∞‡•á‡§Ç',
          'crop.instructions': '‡§¨‡•â‡§ï‡•ç‡§∏ ‡§ï‡•á ‡§Ö‡§Ç‡§¶‡§∞ ‡§°‡•ç‡§∞‡•à‡§ó ‡§ï‡§∞‡§ï‡•á ‡§Æ‡•Ç‡§µ ‡§ï‡§∞‡•á‡§Ç‡•§ ‡§ï‡•ã‡§®‡•ã‡§Ç ‡§∏‡•á ‡§∏‡§æ‡§á‡§ú‡§º ‡§¨‡§¶‡§≤‡•á‡§Ç‡•§',
          'crop.aspectRatio': '‡§Ü‡§∏‡•ç‡§™‡•á‡§ï‡•ç‡§ü ‡§∞‡•á‡§∂‡§ø‡§Ø‡•ã',
          'crop.ratio.free': '‡§´‡•ç‡§∞‡•Ä',
          'crop.resizeAfter': '‡§ï‡•ç‡§∞‡•â‡§™ ‡§ï‡•á ‡§¨‡§æ‡§¶ ‡§∞‡§ø‡§∏‡§æ‡§á‡§ú‡§º',
          'crop.resizeExplain': '‡§ö‡§æ‡§≤‡•Ç ‡§ï‡§∞‡§®‡•á ‡§™‡§∞, ‡§ï‡•ç‡§∞‡•â‡§™ ‡§ï‡•Ä ‡§ó‡§à ‡§á‡§Æ‡•á‡§ú ‡§¶‡•Ä ‡§ó‡§à ‡§ö‡•å‡§°‡§º‡§æ‡§à/‡§ä‡§Ç‡§ö‡§æ‡§à ‡§Æ‡•á‡§Ç ‡§¨‡§ø‡§®‡§æ ‡§ñ‡§ø‡§Ç‡§ö‡•á ‡§´‡§ø‡§ü ‡§π‡•ã‡§ó‡•Ä‡•§',
          'crop.resizeWidth': '‡§ö‡•å‡§°‡§º‡§æ‡§à',
          'crop.resizeHeight': '‡§ä‡§Ç‡§ö‡§æ‡§à',
          'compress.note': '‡§ï‡§Ç‡§™‡•ç‡§∞‡•á‡§∏ ‡§ï‡§∞‡§®‡•á ‡§™‡§∞ ‡§™‡§ø‡§ï‡•ç‡§∏‡•á‡§≤ ‡§°‡§æ‡§Ø‡§Æ‡•á‡§Ç‡§∂‡§® ‡§µ‡§π‡•Ä ‡§∞‡§π‡§§‡•á ‡§π‡•à‡§Ç‡•§',
          'upscale.note': '‡§∏‡•ç‡§™‡•Ä‡§° ‡§î‡§∞ ‡§∏‡•ç‡§•‡§ø‡§∞‡§§‡§æ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§¨‡§π‡•Å‡§§ ‡§¨‡§°‡§º‡•á ‡§Ü‡§â‡§ü‡§™‡•Å‡§ü ‡§Ö‡§™‡§®‡•á ‡§Ü‡§™ ‡§∏‡•Å‡§∞‡§ï‡•ç‡§∑‡§ø‡§§ ‡§∏‡•Ä‡§Æ‡§æ ‡§§‡§ï ‡§∏‡•Ä‡§Æ‡§ø‡§§ ‡§π‡•ã ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§',
          'upscale.note2': '‡§¨‡§π‡•Å‡§§ ‡§ß‡•Å‡§Ç‡§ß‡§≤‡•Ä ‡§Ø‡§æ ‡§¨‡§π‡•Å‡§§ ‡§õ‡•ã‡§ü‡•Ä ‡§á‡§Æ‡•á‡§ú ‡§Æ‡•á‡§Ç ‡§™‡§∞‡§ø‡§£‡§æ‡§Æ ‡§´‡§ø‡§∞ ‡§≠‡•Ä ‡§∏‡•â‡§´‡•ç‡§ü ‡§∞‡§π ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§ ‡§™‡§π‡§≤‡•Ä ‡§¨‡§æ‡§∞ ‡§ö‡§≤‡§æ‡§®‡•á ‡§™‡§∞ ‡§¨‡•ç‡§∞‡§æ‡§â‡§ú‡§º‡§∞ ‡§Æ‡•á‡§Ç ‡§¨‡§°‡§º‡§æ ESRGAN ‡§Æ‡•â‡§°‡§≤ ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§π‡•ã‡§§‡§æ ‡§π‡•à‡•§',
          'upscale.note3': '‡§™‡§π‡§≤‡•Ä ‡§¨‡§æ‡§∞ ‡§Ö‡§®‡•Å‡§Æ‡§æ‡§®‡§ø‡§§ ‡§°‡•á‡§ü‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó: ‡§ï‡•Å‡§≤ ‡§≤‡§ó‡§≠‡§ó 31 MB (‡§Æ‡•â‡§°‡§≤ + AI ‡§∞‡§®‡§ü‡§æ‡§á‡§Æ), ‡§¨‡§æ‡§¶ ‡§Æ‡•á‡§Ç ‡§Ø‡§π ‡§¨‡•ç‡§∞‡§æ‡§â‡§ú‡§º‡§∞ ‡§Æ‡•á‡§Ç ‡§ï‡•à‡§∂ ‡§π‡•ã ‡§ú‡§æ‡§§‡§æ ‡§π‡•à‡•§',
          'upscale.note4': '4x ‡§Æ‡•á‡§Ç AI ‡§ï‡•á ‡§¶‡•ã ‡§™‡§æ‡§∏ ‡§ö‡§≤‡§§‡•á ‡§π‡•à‡§Ç, ‡§á‡§∏‡§≤‡§ø‡§è ‡§Ø‡§π 2x ‡§∏‡•á ‡§ï‡§æ‡§´‡•Ä ‡§ß‡•Ä‡§Æ‡§æ ‡§π‡•à‡•§',
          'hero.convert.title': '‡§´‡•ç‡§∞‡•Ä ‡§á‡§Æ‡•á‡§ú ‡§ï‡§®‡•ç‡§µ‡§∞‡•ç‡§ü‡§∞',
          'hero.convert.subtitle': 'JPG, PNG, WEBP ‡§î‡§∞ AVIF ‡§∏‡•Ä‡§ß‡•á ‡§¨‡•ç‡§∞‡§æ‡§â‡§ú‡§º‡§∞ ‡§Æ‡•á‡§Ç ‡§ï‡§®‡•ç‡§µ‡§∞‡•ç‡§ü ‡§ï‡§∞‡•á‡§Ç‡•§',
          'hero.crop.title': '‡§´‡•ç‡§∞‡•Ä ‡§á‡§Æ‡•á‡§ú ‡§ï‡•ç‡§∞‡•â‡§™‡§∞',
          'hero.crop.subtitle': '‡§°‡•ç‡§∞‡•à‡§ó ‡§ï‡§∞‡•á‡§Ç, ‡§Ü‡§ï‡§æ‡§∞ ‡§¨‡§¶‡§≤‡•á‡§Ç ‡§î‡§∞ ‡§∏‡§ü‡•Ä‡§ï ‡§ï‡•ç‡§∞‡•â‡§™ ‡§è‡§∞‡§ø‡§Ø‡§æ ‡§è‡§ï‡•ç‡§∏‡§™‡•ã‡§∞‡•ç‡§ü ‡§ï‡§∞‡•á‡§Ç‡•§',
          'hero.compress.title': '‡§´‡•ç‡§∞‡•Ä ‡§á‡§Æ‡•á‡§ú ‡§ï‡§Ç‡§™‡•ç‡§∞‡•á‡§∏‡§∞',
          'hero.compress.subtitle': '‡§°‡§æ‡§Ø‡§Æ‡•á‡§Ç‡§∂‡§® ‡§µ‡§π‡•Ä ‡§∞‡§ñ‡§§‡•á ‡§π‡•Å‡§è ‡§´‡§æ‡§á‡§≤ ‡§∏‡§æ‡§á‡§ú‡§º ‡§ò‡§ü‡§æ‡§è‡§Ç‡•§',
          'hero.upscale.title': '‡§´‡•ç‡§∞‡•Ä ‡§á‡§Æ‡•á‡§ú ‡§Ö‡§™‡§∏‡•ç‡§ï‡•á‡§≤‡§∞',
          'hero.upscale.subtitle': 'AI Enhance ‡§Ü‡§™‡§ï‡•á ‡§°‡§ø‡§µ‡§æ‡§á‡§∏ ‡§™‡§∞ 2x/4x ‡§Ö‡§™‡§∏‡•ç‡§ï‡•á‡§≤ ‡§ö‡§≤‡§æ‡§§‡§æ ‡§π‡•à‡•§',
          'seo.relatedPages': '‡§∏‡§Ç‡§¨‡§Ç‡§ß‡§ø‡§§ ‡§™‡•á‡§ú',
          'status.chooseImage': '‡§™‡§π‡§≤‡•á ‡§è‡§ï ‡§á‡§Æ‡•á‡§ú ‡§ö‡•Å‡§®‡•á‡§Ç‡•§',
          'status.uploadFirst': '‡§™‡§π‡§≤‡•á ‡§è‡§ï ‡§á‡§Æ‡•á‡§ú ‡§Ö‡§™‡§≤‡•ã‡§° ‡§ï‡§∞‡•á‡§Ç‡•§',
          'status.converting': '‡§ï‡§®‡•ç‡§µ‡§∞‡•ç‡§ü ‡§π‡•ã ‡§∞‡§π‡§æ ‡§π‡•à...',
          'status.compressing': '‡§ï‡§Ç‡§™‡•ç‡§∞‡•á‡§∏ ‡§π‡•ã ‡§∞‡§π‡§æ ‡§π‡•à (‡§µ‡§π‡•Ä ‡§°‡§æ‡§Ø‡§Æ‡•á‡§Ç‡§∂‡§®)...',
          'status.upscaling': '‡§á‡§Æ‡•á‡§ú ‡§Ö‡§™‡§∏‡•ç‡§ï‡•á‡§≤ ‡§π‡•ã ‡§∞‡§π‡•Ä ‡§π‡•à...',
          'status.cropProcessing': '‡§ï‡•ç‡§∞‡•â‡§™ ‡§™‡•ç‡§∞‡•ã‡§∏‡•á‡§∏ ‡§π‡•ã ‡§∞‡§π‡§æ ‡§π‡•à...',
          'status.doneDownload': '‡§π‡•ã ‡§ó‡§Ø‡§æ‡•§ ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§∂‡•Å‡§∞‡•Ç ‡§π‡•Å‡§Ü‡•§',
          'status.cropDone': '‡§ï‡•ç‡§∞‡•â‡§™ ‡§™‡•Ç‡§∞‡§æ‡•§ ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§∂‡•Å‡§∞‡•Ç ‡§π‡•Å‡§Ü‡•§',
          'status.compressDone': '‡§ï‡§Ç‡§™‡•ç‡§∞‡•á‡§∂‡§® ‡§™‡•Ç‡§∞‡§æ‡•§ ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§∂‡•Å‡§∞‡•Ç ‡§π‡•Å‡§Ü‡•§',
          'status.upscaleDone': '‡§Ö‡§™‡§∏‡•ç‡§ï‡•á‡§≤ ‡§™‡•Ç‡§∞‡§æ‡•§ ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§∂‡•Å‡§∞‡•Ç ‡§π‡•Å‡§Ü‡•§',
          'status.previewIos': '‡§™‡•ç‡§∞‡§ø‡§µ‡•ç‡§Ø‡•Ç ‡§ñ‡•Å‡§≤ ‡§ó‡§Ø‡§æ‡•§ iPhone ‡§™‡§∞ Share ‡§¶‡§¨‡§æ‡§è‡§Ç, ‡§´‡§ø‡§∞ Save Image ‡§ï‡§∞‡•á‡§Ç‡•§',
          'status.imageLoaded': '‡§á‡§Æ‡•á‡§ú ‡§≤‡•ã‡§° ‡§π‡•ã ‡§ó‡§à‡•§ ‡§ï‡•ç‡§∞‡•â‡§™ ‡§è‡§°‡§ú‡§∏‡•ç‡§ü ‡§ï‡§∞‡§ï‡•á ‡§ï‡§®‡•ç‡§´‡§∞‡•ç‡§Æ ‡§ï‡§∞‡•á‡§Ç‡•§',
          'status.loadFailed': '‡§á‡§Æ‡•á‡§ú ‡§≤‡•ã‡§° ‡§®‡§π‡•Ä‡§Ç ‡§π‡•Å‡§à‡•§',
          'status.cropReset': '‡§ï‡•ç‡§∞‡•â‡§™ ‡§¨‡•â‡§ï‡•ç‡§∏ ‡§∞‡•Ä‡§∏‡•á‡§ü ‡§π‡•ã ‡§ó‡§Ø‡§æ‡•§',
          'status.noFileChosen': '‡§ï‡•ã‡§à ‡§´‡§º‡§æ‡§á‡§≤ ‡§®‡§π‡•Ä‡§Ç ‡§ö‡•Å‡§®‡•Ä ‡§ó‡§à',
          'status.cropCanvasPrompt': '‡§ï‡•ç‡§∞‡•â‡§™ ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§á‡§Æ‡•á‡§ú ‡§Ö‡§™‡§≤‡•ã‡§° ‡§ï‡§∞‡•á‡§Ç',
          'error.notSupported': '‡§á‡§∏ ‡§¨‡•ç‡§∞‡§æ‡§â‡§ú‡§º‡§∞ ‡§Æ‡•á‡§Ç {format} ‡§è‡§ï‡•ç‡§∏‡§™‡•ã‡§∞‡•ç‡§ü ‡§∏‡§™‡•ã‡§∞‡•ç‡§ü ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡•§',
          'error.resizeParams': '‡§∞‡§ø‡§∏‡§æ‡§á‡§ú‡§º ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ö‡•å‡§°‡§º‡§æ‡§à ‡§î‡§∞/‡§Ø‡§æ ‡§ä‡§Ç‡§ö‡§æ‡§à ‡§¶‡•á‡§Ç‡•§',
          'error.convertFailed': '‡§ï‡§®‡•ç‡§µ‡§∞‡•ç‡§ü ‡§µ‡§ø‡§´‡§≤‡•§',
          'error.cropFailed': '‡§ï‡•ç‡§∞‡•â‡§™ ‡§µ‡§ø‡§´‡§≤‡•§',
          'error.compressFailed': '‡§ï‡§Ç‡§™‡•ç‡§∞‡•á‡§∏ ‡§µ‡§ø‡§´‡§≤‡•§',
          'error.upscaleFailed': '‡§Ö‡§™‡§∏‡•ç‡§ï‡•á‡§≤ ‡§µ‡§ø‡§´‡§≤‡•§',
          'ph.resizeWidth': '‡§ú‡•à‡§∏‡•á 800',
          'ph.resizeHeight': '‡§ú‡•à‡§∏‡•á 600'
        },
        ja: {
          'lang.label': 'Ë®ÄË™û',
          'flow.upload': '1. „Ç¢„ÉÉ„Éó„É≠„Éº„Éâ',
          'flow.adjust': '2. Ë™øÊï¥',
          'flow.download': '3. „ÉÄ„Ç¶„É≥„É≠„Éº„Éâ',
          'flow.privacy': 'ÁîªÂÉè„ÅØ‰øùÂ≠ò„Åó„Åæ„Åõ„Çì',
          'flow.allInOne': '„Ç™„Éº„É´„Ç§„É≥„ÉØ„É≥ÁîªÂÉè„ÉÑ„Éº„É´: Â§âÊèõ„ÉªÂàá„ÇäÊäú„Åç„ÉªÂúßÁ∏Æ„ÉªÊã°Â§ß„ÉªAIÂâäÈô§„ÄÇ',
          'tab.convert': 'Â§âÊèõ',
          'tab.crop': 'Âàá„ÇäÊäú„Åç',
          'tab.compress': 'ÂúßÁ∏Æ',
          'tab.upscale': 'Êã°Â§ß',
          'oss.prefix': '„Ç™„Éº„Éó„É≥„ÇΩ„Éº„Çπ:',
          'oss.link': 'GitHub „É™„Éù„Ç∏„Éà„É™',
          'oss.suffix': 'Ëá™ÂàÜ„ÅÆÁâà„Çí„Éá„Éó„É≠„Ç§„Åß„Åç„Åæ„Åô„ÄÇ',
          'convert.title': 'ÁîªÂÉèÂ§âÊèõ',
          'convert.subtitle': 'ÁîªË≥™„ÇíË™øÊï¥„Åó„Å™„Åå„ÇâÁîªÂÉèÂΩ¢Âºè„ÇíÂ§âÊèõ„Åó„Åæ„Åô„ÄÇ',
          'crop.title': 'ÁîªÂÉèÂàá„ÇäÊäú„Åç',
          'crop.subtitle': 'Âàá„ÇäÊäú„ÅçÁØÑÂõ≤„ÇíÈÅ∏„Å≥„ÄÅÂøÖË¶Å„Å´Âøú„Åò„Å¶„É™„Çµ„Ç§„Ç∫„Åß„Åç„Åæ„Åô„ÄÇ',
          'compress.title': 'ÁîªÂÉèÂúßÁ∏Æ',
          'compress.subtitle': '„Éî„ÇØ„Çª„É´ÂØ∏Ê≥ï„ÇíÁ∂≠ÊåÅ„Åó„Åü„Åæ„ÅæÂÆπÈáè„ÇíÂâäÊ∏õ„Åó„Åæ„Åô„ÄÇ',
          'upscale.title': 'ÁîªÂÉèÊã°Â§ß',
          'upscale.subtitle': 'AI Enhance „ÅßÊã°Â§ßÊôÇ„ÅÆË¶ã„ÅüÁõÆ„Éá„Ç£„ÉÜ„Éº„É´„ÇíÊîπÂñÑ„Åó„Åæ„Åô„ÄÇ',
          'field.imageFile': 'ÁîªÂÉè„Éï„Ç°„Ç§„É´',
          'field.outputFormat': 'Âá∫ÂäõÂΩ¢Âºè',
          'field.quality': 'ÂìÅË≥™ (1-100)',
          'compress.quality': 'ÂúßÁ∏ÆÂìÅË≥™ (1-100)',
          'upscale.scale': 'ÂÄçÁéá',
          'upscale.quality': 'Âá∫ÂäõÂìÅË≥™ (1-100)',
          'upscale.restoreMode': 'Âæ©ÂÖÉ„É¢„Éº„Éâ',
          'upscale.restore.balanced': '„Éê„É©„É≥„Çπ',
          'upscale.restore.aggressive': 'Âº∑„ÇÅ',
          'upscale.restore.logo': 'ÊñáÂ≠ó/„É≠„Ç¥',
          'upscale.restore.helpTitle': '„Å©„ÅÆÂæ©ÂÖÉ„É¢„Éº„Éâ„Çí‰Ωø„ÅÜ„Åπ„Åç„Åß„Åô„ÅãÔºü',
          'upscale.restore.help.balanced': 'ÂÜôÁúü„ÇÑÊ∑∑Âú®„Ç≥„É≥„ÉÜ„É≥„ÉÑÂêë„Åë„ÅÆÂÆâÂÖ®„Å™Ê®ôÊ∫ñË®≠ÂÆö„ÄÇ',
          'upscale.restore.help.aggressive': '„Éñ„É≠„ÉÉ„ÇØÈô§Âéª„Å®„Ç∑„É£„Éº„ÉóÂåñ„ÇíÂº∑„ÇÅ„Åæ„Åô„ÄÇ„Éè„É≠„Éº/„Éé„Ç§„Ç∫„ÅåÂá∫„ÇãÂ†¥Âêà„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ',
          'upscale.restore.help.logo': '„É≠„Ç¥„Éª„Ç¢„Ç§„Ç≥„É≥„ÉªÊñáÂ≠ó„ÅÆÁ°¨„ÅÑËº™ÈÉ≠„ÇíÂÑ™ÂÖà„Åó„Åæ„Åô„ÄÇ',
          'btn.convertDownload': 'Â§âÊèõ„Åó„Å¶„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ',
          'btn.chooseFile': '„Éï„Ç°„Ç§„É´„ÇíÈÅ∏Êäû',
          'btn.resetBox': 'Êû†„Çí„É™„Çª„ÉÉ„Éà',
          'btn.confirmCropDownload': 'Âàá„ÇäÊäú„ÅÑ„Å¶„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ',
          'btn.compressDownload': 'ÂúßÁ∏Æ„Åó„Å¶„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ',
          'btn.upscaleDownload': 'Êã°Â§ß„Åó„Å¶„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ',
          'btn.zoomIn': '„Ç∫„Éº„É† +',
          'btn.zoomOut': '„Ç∫„Éº„É† -',
          'btn.zoomReset': '„Ç∫„Éº„É†„Çí„É™„Çª„ÉÉ„Éà',
          'btn.continue': 'Á∂öË°å',
          'btn.cancel': '„Ç≠„É£„É≥„Çª„É´',
          'compress.note': 'ÂúßÁ∏Æ„ÅØ„Éî„ÇØ„Çª„É´ÂØ∏Ê≥ï„ÇíÂ§â„Åà„Åö„ÄÅÂÆπÈáè„ÅÆ„Åø„ÇíÊ∏õ„Çâ„Åó„Åæ„Åô„ÄÇ',
          'upscale.note': 'AI Enhance „ÅØË¶ã„ÅüÁõÆ„ÇíÊîπÂñÑ„Åó„Åæ„Åô„Åå„ÄÅÂ§±„Çè„Çå„ÅüÊÉÖÂ†±„ÇíÂÆåÂÖ®Âæ©ÂÖÉ„Åô„Çã„Åì„Å®„ÅØ„Åß„Åç„Åæ„Åõ„Çì„ÄÇ',
          'upscale.note2': 'ÂÖÉÁîªÂÉè„ÅåÈùûÂ∏∏„Å´Â∞è„Åï„ÅÑ/„Åº„ÇÑ„Åë„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÄÅÁµêÊûú„ÇÇÊüî„Çâ„Åã„ÅÑ„Åæ„Åæ„Å´„Å™„Çã„Åì„Å®„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ',
          'upscale.note3': 'ÂàùÂõû„ÉÄ„Ç¶„É≥„É≠„Éº„ÉâÁõÆÂÆâ: Á¥Ñ31MBÔºà„É¢„Éá„É´ + AI„É©„É≥„Çø„Ç§„É†Ôºâ„ÄÇ‰ª•Âæå„ÅØ„Éñ„É©„Ç¶„Ç∂„Å´„Ç≠„É£„ÉÉ„Ç∑„É•„Åï„Çå„Åæ„Åô„ÄÇ',
          'upscale.note4': '4x „ÅØ AI „Çí2„Éë„ÇπÂÆüË°å„Åô„Çã„Åü„ÇÅ„ÄÅ2x „Çà„Çä„Åã„Å™„ÇäÈÅÖ„Åè„Å™„Çä„Åæ„Åô„ÄÇ',
          'hero.convert.title': 'ÁÑ°ÊñôÁîªÂÉè„Ç≥„É≥„Éê„Éº„Çø„Éº',
          'hero.convert.subtitle': 'JPG/PNG/WEBP/AVIF „Çí„Éñ„É©„Ç¶„Ç∂„ÅßÂ§âÊèõ„ÄÇ',
          'hero.crop.title': 'ÁÑ°ÊñôÁîªÂÉè„ÇØ„É≠„ÉÉ„Éë„Éº',
          'hero.crop.subtitle': '„Éâ„É©„ÉÉ„Ç∞„ÅßÊ≠£Á¢∫„Å´Âàá„ÇäÊäú„Åç„ÄÅÂøÖË¶Å„Å™„Çâ„É™„Çµ„Ç§„Ç∫„ÄÇ',
          'hero.compress.title': 'ÁÑ°ÊñôÁîªÂÉèÂúßÁ∏Æ',
          'hero.compress.subtitle': 'ÂØ∏Ê≥ï„ÇíÁ∂≠ÊåÅ„Åó„Åü„Åæ„ÅæÂÆπÈáè„ÇíÂ∞è„Åï„Åè„Åó„Åæ„Åô„ÄÇ',
          'hero.upscale.title': 'ÁÑ°ÊñôÁîªÂÉè„Ç¢„ÉÉ„Éó„Çπ„Ç±„Éº„É©„Éº',
          'hero.upscale.subtitle': 'AI Enhance „ÅåÁ´ØÊú´‰∏ä„Åß 2x/4x Êã°Â§ß„ÇíÂÆüË°å„Åó„Åæ„Åô„ÄÇ',
          'seo.relatedPages': 'Èñ¢ÈÄ£„Éö„Éº„Ç∏',
          'status.chooseImage': 'ÂÖà„Å´ÁîªÂÉè„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
          'status.uploadFirst': 'ÂÖà„Å´ÁîªÂÉè„Çí„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
          'status.converting': 'Â§âÊèõ‰∏≠...',
          'status.compressing': 'ÂúßÁ∏Æ‰∏≠ÔºàÂêå„ÅòÂØ∏Ê≥ïÔºâ...',
          'status.upscaling': 'Êã°Â§ß‰∏≠...',
          'status.cropProcessing': 'Âàá„ÇäÊäú„ÅçÂá¶ÁêÜ‰∏≠...',
          'status.doneDownload': 'ÂÆå‰∫Ü„ÄÇ„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„ÇíÈñãÂßã„Åó„Åæ„Åó„Åü„ÄÇ',
          'status.cropDone': 'Âàá„ÇäÊäú„ÅçÂÆå‰∫Ü„ÄÇ„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„ÇíÈñãÂßã„Åó„Åæ„Åó„Åü„ÄÇ',
          'status.compressDone': 'ÂúßÁ∏ÆÂÆå‰∫Ü„ÄÇ„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„ÇíÈñãÂßã„Åó„Åæ„Åó„Åü„ÄÇ',
          'status.upscaleDone': 'Êã°Â§ßÂÆå‰∫Ü„ÄÇ„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„ÇíÈñãÂßã„Åó„Åæ„Åó„Åü„ÄÇ',
          'status.cancelled': '„Ç≠„É£„É≥„Çª„É´„Åó„Åæ„Åó„Åü„ÄÇ',
          'status.noFileChosen': '„Éï„Ç°„Ç§„É´„ÅåÈÅ∏Êäû„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì',
          'status.cropCanvasPrompt': 'Âàá„ÇäÊäú„ÅèÁîªÂÉè„Çí„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ',
          'status.previewIos': '„Éó„É¨„Éì„É•„Éº„ÇíÈñã„Åç„Åæ„Åó„Åü„ÄÇiPhone „Åß„ÅØ Share „Åã„Çâ Save Image „ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ',
          'error.notSupported': '„Åì„ÅÆ„Éñ„É©„Ç¶„Ç∂„Åß„ÅØ {format} „ÅÆÂá∫Âäõ„Å´ÂØæÂøú„Åó„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ',
          'error.convertFailed': 'Â§âÊèõ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ',
          'error.cropFailed': 'Âàá„ÇäÊäú„Åç„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ',
          'error.compressFailed': 'ÂúßÁ∏Æ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ',
          'error.upscaleFailed': 'Êã°Â§ß„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ',
          'ph.resizeWidth': '‰æã 800',
          'ph.resizeHeight': '‰æã 600'
        },
        ko: {
          'lang.label': 'Ïñ∏Ïñ¥',
          'flow.upload': '1. ÏóÖÎ°úÎìú',
          'flow.adjust': '2. Ï°∞Ï†ï',
          'flow.download': '3. Îã§Ïö¥Î°úÎìú',
          'flow.privacy': 'Ïù¥ÎØ∏ÏßÄÎäî Ï†ÄÏû•ÌïòÏßÄ ÏïäÏäµÎãàÎã§',
          'flow.allInOne': 'Ïò¨Ïù∏Ïõê Ïù¥ÎØ∏ÏßÄ Ìà¥ÌÇ∑: Î≥ÄÌôò, ÏûêÎ•¥Í∏∞, ÏïïÏ∂ï, ÏóÖÏä§ÏºÄÏùº, AI Ï†úÍ±∞.',
          'tab.convert': 'Î≥ÄÌôò',
          'tab.crop': 'ÏûêÎ•¥Í∏∞',
          'tab.compress': 'ÏïïÏ∂ï',
          'tab.upscale': 'ÏóÖÏä§ÏºÄÏùº',
          'oss.prefix': 'Ïò§ÌîàÏÜåÏä§:',
          'oss.link': 'GitHub Ï†ÄÏû•ÏÜå',
          'oss.suffix': 'ÏßÅÏ†ë Î∞∞Ìè¨Ìï† Ïàò ÏûàÏäµÎãàÎã§.',
          'convert.title': 'Ïù¥ÎØ∏ÏßÄ Î≥ÄÌôò',
          'convert.subtitle': 'ÌíàÏßàÏùÑ Ï°∞Ï†àÌïòÎ©∞ Ïù¥ÎØ∏ÏßÄ ÌòïÏãùÏùÑ Î≥ÄÌôòÌï©ÎãàÎã§.',
          'crop.title': 'Ïù¥ÎØ∏ÏßÄ ÏûêÎ•¥Í∏∞',
          'crop.subtitle': 'ÏûêÎ•¥Í∏∞ ÏòÅÏó≠ÏùÑ ÏÑ†ÌÉùÌïòÍ≥† ÌïÑÏöîÌïòÎ©¥ ÌÅ¨Í∏∞Î•º Ï°∞Ï†ïÌïòÏÑ∏Ïöî.',
          'compress.title': 'Ïù¥ÎØ∏ÏßÄ ÏïïÏ∂ï',
          'compress.subtitle': 'ÌîΩÏÖÄ ÌÅ¨Í∏∞Î•º Ïú†ÏßÄÌïú Ï±Ñ Ïö©ÎüâÏùÑ Ï§ÑÏûÖÎãàÎã§.',
          'upscale.title': 'Ïù¥ÎØ∏ÏßÄ ÏóÖÏä§ÏºÄÏùº',
          'upscale.subtitle': 'AI EnhanceÎ°ú ÌôïÎåÄ Ïãú ÎîîÌÖåÏùº ÌëúÌòÑÏùÑ Í∞úÏÑ†Ìï©ÎãàÎã§.',
          'field.imageFile': 'Ïù¥ÎØ∏ÏßÄ ÌååÏùº',
          'field.outputFormat': 'Ï∂úÎ†• ÌòïÏãù',
          'field.quality': 'ÌíàÏßà (1-100)',
          'compress.quality': 'ÏïïÏ∂ï ÌíàÏßà (1-100)',
          'upscale.scale': 'Î∞∞Ïú®',
          'upscale.quality': 'Ï∂úÎ†• ÌíàÏßà (1-100)',
          'upscale.restoreMode': 'Î≥µÏõê Î™®Îìú',
          'upscale.restore.balanced': 'Í∑†Ìòï',
          'upscale.restore.aggressive': 'Í∞ïÌïòÍ≤å',
          'upscale.restore.logo': 'ÌÖçÏä§Ìä∏/Î°úÍ≥†',
          'upscale.restore.helpTitle': 'Ïñ¥Îñ§ Î≥µÏõê Î™®ÎìúÎ•º Ïç®Ïïº ÌïòÎÇòÏöî?',
          'upscale.restore.help.balanced': 'ÎåÄÎ∂ÄÎ∂ÑÏùò ÏÇ¨ÏßÑ/ÌòºÌï© ÏΩòÌÖêÏ∏†Ïóê ÏïàÏ†ÑÌïú Í∏∞Î≥∏Í∞íÏûÖÎãàÎã§.',
          'upscale.restore.help.aggressive': 'Î∏îÎ°ù Ï†úÍ±∞ÏôÄ ÏÑ†Î™ÖÌôîÎ•º Í∞ïÌïòÍ≤å Ï†ÅÏö©Ìï©ÎãàÎã§. Ìï†Î°ú/ÎÖ∏Ïù¥Ï¶àÍ∞Ä ÏÉùÍ∏∏ Ïàò ÏûàÏäµÎãàÎã§.',
          'upscale.restore.help.logo': 'Î°úÍ≥†, ÏïÑÏù¥ÏΩò, ÌÖçÏä§Ìä∏Ïùò ÎòêÎ†∑Ìïú Í≤ΩÍ≥ÑÎ•º Ïö∞ÏÑ†Ìï©ÎãàÎã§.',
          'btn.convertDownload': 'Î≥ÄÌôò ÌõÑ Îã§Ïö¥Î°úÎìú',
          'btn.chooseFile': 'ÌååÏùº ÏÑ†ÌÉù',
          'btn.resetBox': 'Î∞ïÏä§ Ï¥àÍ∏∞Ìôî',
          'btn.confirmCropDownload': 'ÏûêÎ•¥Í≥† Îã§Ïö¥Î°úÎìú',
          'btn.compressDownload': 'ÏïïÏ∂ï ÌõÑ Îã§Ïö¥Î°úÎìú',
          'btn.upscaleDownload': 'ÏóÖÏä§ÏºÄÏùº ÌõÑ Îã§Ïö¥Î°úÎìú',
          'btn.zoomIn': 'ÌôïÎåÄ +',
          'btn.zoomOut': 'Ï∂ïÏÜå -',
          'btn.zoomReset': 'Ï§å Ï¥àÍ∏∞Ìôî',
          'btn.continue': 'Í≥ÑÏÜç',
          'btn.cancel': 'Ï∑®ÏÜå',
          'compress.note': 'ÏïïÏ∂ïÏùÄ ÌîΩÏÖÄ ÌÅ¨Í∏∞Î•º Ïú†ÏßÄÌïòÍ≥† Ïö©ÎüâÎßå Ï§ÑÏûÖÎãàÎã§.',
          'upscale.note': 'AI EnhanceÎäî ÏãúÍ∞ÅÏ†Å ÌíàÏßàÏùÑ Í∞úÏÑ†ÌïòÏßÄÎßå, ÏÜêÏã§Îêú Ï†ïÎ≥¥Î•º ÏôÑÏ†ÑÌûà Î≥µÏõêÌïòÏßÑ Î™ªÌï©ÎãàÎã§.',
          'upscale.note2': 'ÏõêÎ≥∏Ïù¥ Îß§Ïö∞ ÏûëÍ±∞ÎÇò ÌùêÎ¶¨Î©¥ Í≤∞Í≥ºÎèÑ Î∂ÄÎìúÎüΩÍ≤å Î≥¥Ïùº Ïàò ÏûàÏäµÎãàÎã§.',
          'upscale.note3': 'Ï≤´ Ïã§Ìñâ ÏòàÏÉÅ Îã§Ïö¥Î°úÎìú: ÏïΩ 31MB(Î™®Îç∏ + AI Îü∞ÌÉÄÏûÑ), Ïù¥ÌõÑ Î∏åÎùºÏö∞Ï†ÄÏóê Ï∫êÏãúÎê©ÎãàÎã§.',
          'upscale.note4': '4xÎäî AIÎ•º 2Ìöå Ïã§ÌñâÌïòÎØÄÎ°ú 2xÎ≥¥Îã§ Ìõ®Ïî¨ ÎäêÎ¶ΩÎãàÎã§.',
          'hero.convert.title': 'Î¨¥Î£å Ïù¥ÎØ∏ÏßÄ Î≥ÄÌôòÍ∏∞',
          'hero.convert.subtitle': 'JPG/PNG/WEBP/AVIFÎ•º Î∏åÎùºÏö∞Ï†ÄÏóêÏÑú Î∞îÎ°ú Î≥ÄÌôò.',
          'hero.crop.title': 'Î¨¥Î£å Ïù¥ÎØ∏ÏßÄ ÌÅ¨Î°≠',
          'hero.crop.subtitle': 'ÎìúÎûòÍ∑∏Î°ú Ï†ïÌôïÌûà ÏûêÎ•¥Í≥† ÌïÑÏöî Ïãú Î¶¨ÏÇ¨Ïù¥Ï¶à.',
          'hero.compress.title': 'Î¨¥Î£å Ïù¥ÎØ∏ÏßÄ ÏïïÏ∂ï',
          'hero.compress.subtitle': 'ÌÅ¨Í∏∞Îäî Ïú†ÏßÄÌïòÍ≥† ÌååÏùº Ïö©ÎüâÏùÑ Ï§ÑÏûÖÎãàÎã§.',
          'hero.upscale.title': 'Î¨¥Î£å Ïù¥ÎØ∏ÏßÄ ÏóÖÏä§ÏºÄÏùºÎü¨',
          'hero.upscale.subtitle': 'AI EnhanceÍ∞Ä Í∏∞Í∏∞ÏóêÏÑú 2x/4x ÏóÖÏä§ÏºÄÏùºÏùÑ Ïã§ÌñâÌï©ÎãàÎã§.',
          'seo.relatedPages': 'Í¥ÄÎ†® ÌéòÏù¥ÏßÄ',
          'status.chooseImage': 'Î®ºÏ†Ä Ïù¥ÎØ∏ÏßÄÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.',
          'status.uploadFirst': 'Î®ºÏ†Ä Ïù¥ÎØ∏ÏßÄÎ•º ÏóÖÎ°úÎìúÌïòÏÑ∏Ïöî.',
          'status.converting': 'Î≥ÄÌôò Ï§ë...',
          'status.compressing': 'ÏïïÏ∂ï Ï§ë(ÎèôÏùº ÌÅ¨Í∏∞)...',
          'status.upscaling': 'ÏóÖÏä§ÏºÄÏùº Ï§ë...',
          'status.cropProcessing': 'ÌÅ¨Î°≠ Ï≤òÎ¶¨ Ï§ë...',
          'status.doneDownload': 'ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§. Îã§Ïö¥Î°úÎìúÎ•º ÏãúÏûëÌñàÏäµÎãàÎã§.',
          'status.cropDone': 'ÌÅ¨Î°≠ ÏôÑÎ£å. Îã§Ïö¥Î°úÎìúÎ•º ÏãúÏûëÌñàÏäµÎãàÎã§.',
          'status.compressDone': 'ÏïïÏ∂ï ÏôÑÎ£å. Îã§Ïö¥Î°úÎìúÎ•º ÏãúÏûëÌñàÏäµÎãàÎã§.',
          'status.upscaleDone': 'ÏóÖÏä§ÏºÄÏùº ÏôÑÎ£å. Îã§Ïö¥Î°úÎìúÎ•º ÏãúÏûëÌñàÏäµÎãàÎã§.',
          'status.cancelled': 'Ï∑®ÏÜåÎêòÏóàÏäµÎãàÎã§.',
          'status.noFileChosen': 'ÏÑ†ÌÉùÎêú ÌååÏùº ÏóÜÏùå',
          'status.cropCanvasPrompt': 'ÏûêÎ•º Ïù¥ÎØ∏ÏßÄÎ•º ÏóÖÎ°úÎìúÌïòÏÑ∏Ïöî',
          'status.previewIos': 'ÎØ∏Î¶¨Î≥¥Í∏∞Í∞Ä Ïó¥Î†∏ÏäµÎãàÎã§. iPhoneÏóêÏÑúÎäî Share ÌõÑ Save ImageÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.',
          'error.notSupported': 'Ïù¥ Î∏åÎùºÏö∞Ï†ÄÎäî {format} ÎÇ¥Î≥¥ÎÇ¥Í∏∞Î•º ÏßÄÏõêÌïòÏßÄ ÏïäÏäµÎãàÎã§.',
          'error.convertFailed': 'Î≥ÄÌôò Ïã§Ìå®.',
          'error.cropFailed': 'ÌÅ¨Î°≠ Ïã§Ìå®.',
          'error.compressFailed': 'ÏïïÏ∂ï Ïã§Ìå®.',
          'error.upscaleFailed': 'ÏóÖÏä§ÏºÄÏùº Ïã§Ìå®.',
          'ph.resizeWidth': 'Ïòà: 800',
          'ph.resizeHeight': 'Ïòà: 600'
        },
        ar: {
          'lang.label': 'ÿßŸÑŸÑÿ∫ÿ©',
          'flow.upload': '1. ÿ±ŸÅÿπ',
          'flow.adjust': '2. ÿ™ÿπÿØŸäŸÑ',
          'flow.download': '3. ÿ™ŸÜÿ≤ŸäŸÑ',
          'flow.privacy': 'ŸÜÿ≠ŸÜ ŸÑÿß ŸÜÿ≠ŸÅÿ∏ ÿµŸàÿ±ŸÉ',
          'flow.allInOne': 'ŸÖÿ¨ŸÖŸàÿπÿ© ÿµŸàÿ± ÿ¥ÿßŸÖŸÑÿ©: ÿ™ÿ≠ŸàŸäŸÑÿå ŸÇÿµÿå ÿ∂ÿ∫ÿ∑ÿå ÿ™ŸÉÿ®Ÿäÿ±ÿå Ÿàÿ•ÿ≤ÿßŸÑÿ© ÿ®ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä.',
          'tab.convert': 'ÿ™ÿ≠ŸàŸäŸÑ',
          'tab.crop': 'ŸÇÿµ',
          'tab.compress': 'ÿ∂ÿ∫ÿ∑',
          'tab.upscale': 'ÿ™ŸÉÿ®Ÿäÿ±',
          'oss.prefix': 'ŸÖŸÅÿ™Ÿàÿ≠ ÿßŸÑŸÖÿµÿØÿ±:',
          'oss.link': 'ŸÖÿ≥ÿ™ŸàÿØÿπ GitHub',
          'oss.suffix': 'ÿßŸÜÿ¥ÿ± ŸÜÿ≥ÿÆÿ™ŸÉ ÿßŸÑÿÆÿßÿµÿ©.',
          'convert.title': 'ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑÿµŸàÿ±',
          'convert.subtitle': 'ÿ∫ŸäŸëÿ± ÿµŸäÿ∫ÿ© ÿßŸÑÿµŸàÿ±ÿ© ŸÖÿπ ÿßŸÑÿ™ÿ≠ŸÉŸÖ ŸÅŸä ÿßŸÑÿ¨ŸàÿØÿ©.',
          'crop.title': 'ŸÇÿµ ÿßŸÑÿµŸàÿ±',
          'crop.subtitle': 'ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿ•ÿ∑ÿßÿ± ÿßŸÑŸÇÿµ ŸÑÿ™ÿ≠ÿØŸäÿØ ÿßŸÑÿ¨ÿ≤ÿ° ÿßŸÑŸÖÿ∑ŸÑŸàÿ® ÿ´ŸÖ ÿ∫ŸäŸëÿ± ÿßŸÑÿ≠ÿ¨ŸÖ ÿßÿÆÿ™Ÿäÿßÿ±ŸäŸãÿß.',
          'compress.title': 'ÿ∂ÿ∫ÿ∑ ÿßŸÑÿµŸàÿ±',
          'compress.subtitle': 'ŸÇŸÑŸëŸÑ ÿ≠ÿ¨ŸÖ ÿßŸÑŸÖŸÑŸÅ ŸÖÿπ ÿßŸÑÿ≠ŸÅÿßÿ∏ ÿπŸÑŸâ ŸÜŸÅÿ≥ ÿßŸÑÿ£ÿ®ÿπÿßÿØ.',
          'upscale.title': 'ÿ™ŸÉÿ®Ÿäÿ± ÿßŸÑÿµŸàÿ±',
          'upscale.subtitle': 'ÿ≤ŸêÿØ ÿØŸÇÿ© ÿßŸÑÿµŸàÿ±ÿ© ÿπŸÑŸâ ÿ¨Ÿáÿßÿ≤ŸÉ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿ™ŸÉÿ®Ÿäÿ± ÿπŸÖŸÑŸä ŸàŸÖÿ≥ÿ™ŸÇÿ±.',
          'field.imageFile': 'ŸÖŸÑŸÅ ÿßŸÑÿµŸàÿ±ÿ©',
          'field.outputFormat': 'ÿµŸäÿ∫ÿ© ÿßŸÑÿ•ÿÆÿ±ÿßÿ¨',
          'field.quality': 'ÿßŸÑÿ¨ŸàÿØÿ© (1-100)',
          'compress.quality': 'ÿ¨ŸàÿØÿ© ÿßŸÑÿ∂ÿ∫ÿ∑ (1-100)',
          'upscale.scale': 'ŸÖŸÇÿØÿßÿ± ÿßŸÑÿ™ŸÉÿ®Ÿäÿ±',
          'upscale.quality': 'ÿ¨ŸàÿØÿ© ÿßŸÑÿ•ÿÆÿ±ÿßÿ¨ (1-100)',
          'upscale.restoreMode': 'Ÿàÿ∂ÿπ ÿßŸÑÿßÿ≥ÿ™ÿπÿßÿØÿ©',
          'upscale.restore.balanced': 'ŸÖÿ™Ÿàÿßÿ≤ŸÜ',
          'upscale.restore.aggressive': 'ŸÇŸàŸä',
          'upscale.restore.logo': 'ŸÜÿµ/ÿ¥ÿπÿßÿ±',
          'upscale.restore.helpTitle': 'ŸÖÿß Ÿàÿ∂ÿπ ÿßŸÑÿßÿ≥ÿ™ÿπÿßÿØÿ© ÿßŸÑŸÖŸÜÿßÿ≥ÿ®ÿü',
          'upscale.restore.help.balanced': 'ÿßŸÑÿÆŸäÿßÿ± ÿßŸÑÿ£ŸÉÿ´ÿ± ÿ£ŸÖÿßŸÜŸãÿß ŸÑŸÖÿπÿ∏ŸÖ ÿßŸÑÿµŸàÿ± ŸàÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑŸÖÿÆÿ™ŸÑÿ∑.',
          'upscale.restore.help.aggressive': 'ÿ•ÿ≤ÿßŸÑÿ© ÿ∂ÿ∫ÿ∑ Ÿàÿ≠ÿØŸëÿ© ÿ£ŸÇŸàŸâÿå ŸàŸÇÿØ ÿ™ÿ∏Ÿáÿ± ŸáÿßŸÑÿßÿ™/ÿ∂ÿ¨Ÿäÿ¨.',
          'upscale.restore.help.logo': 'Ÿäÿ±ŸÉŸëÿ≤ ÿπŸÑŸâ ÿßŸÑÿ≠ŸàÿßŸÅ ÿßŸÑÿµŸÑÿ®ÿ© ŸÑŸÑÿ¥ÿπÿßÿ±ÿßÿ™ ŸàÿßŸÑÿ£ŸäŸÇŸàŸÜÿßÿ™ Ÿàÿ£ÿ¥ŸÉÿßŸÑ ÿßŸÑŸÜÿµ.',
          'btn.convertDownload': 'ÿ™ÿ≠ŸàŸäŸÑ Ÿàÿ™ŸÜÿ≤ŸäŸÑ',
          'btn.chooseFile': 'ÿßÿÆÿ™ÿ± ŸÖŸÑŸÅ',
          'btn.resetBox': 'ÿ•ÿπÿßÿØÿ© ÿ∂ÿ®ÿ∑ ÿßŸÑÿ•ÿ∑ÿßÿ±',
          'btn.confirmCropDownload': 'ÿ™ÿ£ŸÉŸäÿØ ÿßŸÑŸÇÿµ ŸàÿßŸÑÿ™ŸÜÿ≤ŸäŸÑ',
          'btn.compressDownload': 'ÿ∂ÿ∫ÿ∑ Ÿàÿ™ŸÜÿ≤ŸäŸÑ',
          'btn.upscaleDownload': 'ÿ™ŸÉÿ®Ÿäÿ± Ÿàÿ™ŸÜÿ≤ŸäŸÑ',
          'btn.zoomIn': 'ÿ™ŸÉÿ®Ÿäÿ± +',
          'btn.zoomOut': 'ÿ™ÿµÿ∫Ÿäÿ± -',
          'btn.zoomReset': 'ÿ•ÿπÿßÿØÿ© ÿ∂ÿ®ÿ∑ ÿßŸÑÿ™ŸÉÿ®Ÿäÿ±',
          'btn.continue': 'ŸÖÿ™ÿßÿ®ÿπÿ©',
          'btn.cancel': 'ÿ•ŸÑÿ∫ÿßÿ°',
          'crop.instructions': 'ÿßÿ≥ÿ≠ÿ® ÿØÿßÿÆŸÑ ÿßŸÑÿ•ÿ∑ÿßÿ± ŸÑŸÑÿ™ÿ≠ÿ±ŸäŸÉ Ÿàÿßÿ≥ÿ≠ÿ® ÿßŸÑÿ≤ŸàÿßŸäÿß ŸÑÿ™ÿ∫ŸäŸäÿ± ÿßŸÑÿ≠ÿ¨ŸÖ.',
          'crop.aspectRatio': 'ŸÜÿ≥ÿ®ÿ© ÿßŸÑÿ£ÿ®ÿπÿßÿØ',
          'crop.ratio.free': 'ÿ≠ÿ±',
          'crop.resizeAfter': 'ÿ™ÿ∫ŸäŸäÿ± ÿßŸÑÿ≠ÿ¨ŸÖ ÿ®ÿπÿØ ÿßŸÑŸÇÿµ',
          'crop.resizeExplain': 'ÿπŸÜÿØ ÿßŸÑÿ™ŸÅÿπŸäŸÑÿå Ÿäÿ™ŸÖ ÿ™ÿµÿ∫Ÿäÿ± ÿßŸÑÿµŸàÿ±ÿ© ÿßŸÑŸÖŸÇÿµŸàÿµÿ© ŸÑÿ™ŸÜÿßÿ≥ÿ® ÿßŸÑÿπÿ±ÿ∂/ÿßŸÑÿßÿ±ÿ™ŸÅÿßÿπ ÿ®ÿØŸàŸÜ ÿ™ŸÖÿØÿØ.',
          'crop.resizeWidth': 'ÿßŸÑÿπÿ±ÿ∂',
          'crop.resizeHeight': 'ÿßŸÑÿßÿ±ÿ™ŸÅÿßÿπ',
          'compress.note': 'ÿßŸÑÿ∂ÿ∫ÿ∑ Ÿäÿ≠ÿßŸÅÿ∏ ÿπŸÑŸâ ŸÜŸÅÿ≥ ÿ£ÿ®ÿπÿßÿØ ÿßŸÑÿ®ŸÉÿ≥ŸÑ.',
          'upscale.note': 'ŸÑŸÑÿ≠ŸÅÿßÿ∏ ÿπŸÑŸâ ÿßŸÑÿ≥ÿ±ÿπÿ© ŸàÿßŸÑÿßÿ≥ÿ™ŸÇÿ±ÿßÿ±ÿå ŸÇÿØ Ÿäÿ™ŸÖ ÿ™ŸÇŸÑŸäŸÑ ÿßŸÑŸÖÿÆÿ±ÿ¨ÿßÿ™ ÿßŸÑŸÉÿ®Ÿäÿ±ÿ© ÿ¨ÿØŸãÿß ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß ÿ•ŸÑŸâ ÿ£ÿ®ÿπÿßÿØ ÿ¢ŸÖŸÜÿ©.',
          'upscale.note2': 'ŸÇÿØ ÿ™ÿ®ŸÇŸâ ÿßŸÑÿµŸàÿ± ÿßŸÑÿµÿ∫Ÿäÿ±ÿ© ÿ¨ÿØŸãÿß ÿ£Ÿà ÿßŸÑÿ∂ÿ®ÿßÿ®Ÿäÿ© ŸÜÿßÿπŸÖÿ© ÿ≠ÿ™Ÿâ ÿ®ÿπÿØ ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©. ŸÅŸä ÿ£ŸàŸÑ ÿ™ÿ¥ÿ∫ŸäŸÑ Ÿäÿ™ŸÖ ÿ™ŸÜÿ≤ŸäŸÑ ŸÜŸÖŸàÿ∞ÿ¨ ESRGAN ÿ£ŸÉÿ®ÿ± ÿØÿßÿÆŸÑ ÿßŸÑŸÖÿ™ÿµŸÅÿ≠.',
          'upscale.note3': 'ÿßÿ≥ÿ™ŸáŸÑÿßŸÉ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ™ŸàŸÇÿπ ŸÑÿ£ŸàŸÑ ÿ™ÿ¥ÿ∫ŸäŸÑ: ÿ≠ŸàÿßŸÑŸä 31 ŸÖŸäÿ¨ÿßÿ®ÿßŸäÿ™ ÿ•ÿ¨ŸÖÿßŸÑŸãÿß (ÿßŸÑŸÜŸÖŸàÿ∞ÿ¨ + ŸàŸÇÿ™ ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä)ÿå ÿ´ŸÖ Ÿäÿ™ŸÖ ÿ≠ŸÅÿ∏Ÿá ŸÅŸä ÿ∞ÿßŸÉÿ±ÿ© ÿßŸÑŸÖÿ™ÿµŸÅÿ≠ ÿßŸÑŸÖÿ§ŸÇÿ™ÿ©.',
          'upscale.note4': 'Ÿàÿ∂ÿπ 4x Ÿäÿ¥ÿ∫ŸëŸÑ ŸÖÿ±ÿ≠ŸÑÿ™ŸäŸÜ ŸÖŸÜ ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸäÿå ŸÑÿ∞ŸÑŸÉ ŸäŸÉŸàŸÜ ÿ£ÿ®ÿ∑ÿ£ ÿ®ŸÉÿ´Ÿäÿ± ŸÖŸÜ 2x.',
          'hero.convert.title': 'ŸÖÿ≠ŸàŸÑ ÿµŸàÿ± ŸÖÿ¨ÿßŸÜŸä',
          'hero.convert.subtitle': 'ÿ≠ŸàŸëŸÑ JPG ŸàPNG ŸàWEBP ŸàAVIF ŸÖÿ®ÿßÿ¥ÿ±ÿ© ÿØÿßÿÆŸÑ ÿßŸÑŸÖÿ™ÿµŸÅÿ≠.',
          'hero.crop.title': 'ÿ£ÿØÿßÿ© ŸÇÿµ ÿµŸàÿ± ŸÖÿ¨ÿßŸÜŸäÿ©',
          'hero.crop.subtitle': 'ÿßÿ≥ÿ≠ÿ® Ÿàÿ∫ŸäŸëÿ± ÿßŸÑÿ≠ÿ¨ŸÖ ŸàÿµÿØŸëÿ± ŸÖŸÜÿ∑ŸÇÿ© ŸÇÿµ ÿØŸÇŸäŸÇÿ© ŸÖÿπ ÿ™ÿ∫ŸäŸäÿ± ÿ≠ÿ¨ŸÖ ÿßÿÆÿ™Ÿäÿßÿ±Ÿä.',
          'hero.compress.title': 'ÿ∂ÿßÿ∫ÿ∑ ÿµŸàÿ± ŸÖÿ¨ÿßŸÜŸä',
          'hero.compress.subtitle': 'ŸÇŸÑŸëŸÑ ÿ≠ÿ¨ŸÖ ÿßŸÑŸÖŸÑŸÅ ŸÖÿπ ÿßŸÑÿ≠ŸÅÿßÿ∏ ÿπŸÑŸâ ÿßŸÑÿ£ÿ®ÿπÿßÿØ.',
          'hero.upscale.title': 'ŸÖŸÉÿ®ÿ± ÿµŸàÿ± ŸÖÿ¨ÿßŸÜŸä',
          'hero.upscale.subtitle': 'ŸäÿπŸÖŸÑ AI Enhance ÿπŸÑŸâ ÿ¨Ÿáÿßÿ≤ŸÉ ŸÑŸÑÿ™ŸÉÿ®Ÿäÿ± 2x ÿ£Ÿà 4x ÿ®ÿ≠ÿØŸàÿØ ÿπŸÖŸÑŸäÿ©.',
          'seo.relatedPages': 'ÿµŸÅÿ≠ÿßÿ™ ÿ∞ÿßÿ™ ÿµŸÑÿ©',
          'status.chooseImage': 'ÿßÿÆÿ™ÿ± ÿµŸàÿ±ÿ© ÿ£ŸàŸÑÿßŸã.',
          'status.uploadFirst': 'ÿßÿ±ŸÅÿπ ÿµŸàÿ±ÿ© ÿ£ŸàŸÑÿßŸã.',
          'status.converting': 'ÿ¨ÿßÿ±Ÿç ÿßŸÑÿ™ÿ≠ŸàŸäŸÑ...',
          'status.compressing': 'ÿ¨ÿßÿ±Ÿç ÿßŸÑÿ∂ÿ∫ÿ∑ (ŸÜŸÅÿ≥ ÿßŸÑÿ£ÿ®ÿπÿßÿØ)...',
          'status.upscaling': 'ÿ¨ÿßÿ±Ÿç ÿ™ŸÉÿ®Ÿäÿ± ÿßŸÑÿµŸàÿ±ÿ©...',
          'status.cropProcessing': 'ÿ¨ÿßÿ±Ÿç ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑŸÇÿµ...',
          'status.doneDownload': 'ÿ™ŸÖ. ÿ®ÿØÿ£ ÿßŸÑÿ™ŸÜÿ≤ŸäŸÑ.',
          'status.cropDone': 'ÿ™ŸÖ ÿßŸÑŸÇÿµ. ÿ®ÿØÿ£ ÿßŸÑÿ™ŸÜÿ≤ŸäŸÑ.',
          'status.compressDone': 'ÿ™ŸÖ ÿßŸÑÿ∂ÿ∫ÿ∑. ÿ®ÿØÿ£ ÿßŸÑÿ™ŸÜÿ≤ŸäŸÑ.',
          'status.upscaleDone': 'ÿ™ŸÖ ÿßŸÑÿ™ŸÉÿ®Ÿäÿ±. ÿ®ÿØÿ£ ÿßŸÑÿ™ŸÜÿ≤ŸäŸÑ.',
          'status.previewIos': 'ÿ™ŸÖ ŸÅÿ™ÿ≠ ÿßŸÑŸÖÿπÿßŸäŸÜÿ©. ŸÅŸä iPhone ÿßÿ∂ÿ∫ÿ∑ Share ÿ´ŸÖ Save Image.',
          'status.imageLoaded': 'ÿ™ŸÖ ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿµŸàÿ±ÿ©. ÿπÿØŸëŸÑ ÿßŸÑŸÇÿµ ÿ´ŸÖ ÿ£ŸÉŸëÿØ.',
          'status.loadFailed': 'ŸÅÿ¥ŸÑ ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿµŸàÿ±ÿ©.',
          'status.cropReset': 'ÿ™ŸÖÿ™ ÿ•ÿπÿßÿØÿ© ÿ∂ÿ®ÿ∑ ÿ•ÿ∑ÿßÿ± ÿßŸÑŸÇÿµ.',
          'status.noFileChosen': 'ŸÑŸÖ Ÿäÿ™ŸÖ ÿßÿÆÿ™Ÿäÿßÿ± ŸÖŸÑŸÅ',
          'status.cropCanvasPrompt': 'ÿßÿ±ŸÅÿπ ÿµŸàÿ±ÿ© ŸÑŸÑŸÇÿµ',
          'error.notSupported': 'ÿ™ÿµÿØŸäÿ± {format} ÿ∫Ÿäÿ± ŸÖÿØÿπŸàŸÖ ŸÅŸä Ÿáÿ∞ÿß ÿßŸÑŸÖÿ™ÿµŸÅÿ≠.',
          'error.resizeParams': 'ÿ£ÿØÿÆŸÑ ÿπÿ±ÿ∂Ÿãÿß Ÿà/ÿ£Ÿà ÿßÿ±ÿ™ŸÅÿßÿπŸãÿß ŸÑÿ™ÿ∫ŸäŸäÿ± ÿßŸÑÿ≠ÿ¨ŸÖ.',
          'error.convertFailed': 'ŸÅÿ¥ŸÑ ÿßŸÑÿ™ÿ≠ŸàŸäŸÑ.',
          'error.cropFailed': 'ŸÅÿ¥ŸÑ ÿßŸÑŸÇÿµ.',
          'error.compressFailed': 'ŸÅÿ¥ŸÑ ÿßŸÑÿ∂ÿ∫ÿ∑.',
          'error.upscaleFailed': 'ŸÅÿ¥ŸÑ ÿßŸÑÿ™ŸÉÿ®Ÿäÿ±.',
          'ph.resizeWidth': 'ŸÖÿ´ÿßŸÑ 800',
          'ph.resizeHeight': 'ŸÖÿ´ÿßŸÑ 600'
        }
      };

      const removeI18nOverrides = {
        es: {
          'tab.remove': 'AI Eliminar',
          'remove.title': 'Eliminar objetos',
          'remove.subtitle': 'Pinta la zona no deseada y suelta para eliminar. La descarga se habilita al terminar.',
          'remove.brushSize': 'Tamano del pincel',
          'remove.brushDownAria': 'Reducir tamano del pincel',
          'remove.brushUpAria': 'Aumentar tamano del pincel',
          'remove.algorithm': 'Algoritmo de eliminacion',
          'remove.algorithm.aggressive': 'Agresivo (Borrado de objeto)',
          'remove.algorithm.aggressive.desc': 'Modo mas rapido para borrado rapido de etiquetas, logos, texto y bordes duros.',
          'remove.algorithm.ai': 'IA Generativa (en navegador)',
          'remove.algorithm.ai.desc': 'Mejor calidad (mas lento): eliminacion mas fuerte con relleno de fondo mas limpio.',
          'remove.algorithm.texture': 'Preservar textura',
          'remove.algorithm.texture.desc': 'Ideal para madera, tela, concreto y fondos con ruido/patrones para conservar textura.',
          'remove.algorithm.natural': 'Natural (Suave)',
          'remove.algorithm.natural.desc': 'Ideal para cielo, pared, piel y fondos desenfocados con transicion suave.',
          'remove.instructions': 'Pinta sobre el objeto a eliminar. Puedes acercar/alejar para editar con precision.',
          'remove.empty.title': 'Sube una imagen y pinta para eliminar.',
          'remove.empty.sub': 'Suelta el dedo o el mouse para aplicar la eliminacion.',
          'remove.progressWarning': 'Si cierras o recargas esta pestana, se perdera el progreso.',
          'hero.remove.title': 'Eliminador de objetos gratis',
          'hero.remove.subtitle': 'Pinta, elimina zonas no deseadas y descarga al terminar.',
          'btn.downloadWhenReady': 'Descargar resultado',
          'btn.back': '<- Atras',
          'status.removing': 'Eliminando objeto seleccionado...',
          'status.removeReady': 'Eliminacion terminada. Revisa y pulsa Descargar resultado.',
          'status.removeMaskEmpty': 'Pinta al menos una zona para eliminar primero.',
          'status.removeUndoDone': 'Se deshizo la ultima eliminacion.',
          'status.removeImageLoaded': 'Imagen cargada. Pinta la zona y suelta para aplicar.',
          'error.removeFailed': 'Fallo al eliminar objeto.'
        },
        zh: {
          'tab.remove': 'AIÊ∂àÈô§',
          'remove.title': 'Ê∂àÈô§ÂØπË±°',
          'remove.subtitle': 'Ê∂ÇÊäπ‰∏çÈúÄË¶ÅÁöÑÂå∫ÂüüÔºåÊä¨ÊâãÂç≥Ëá™Âä®Ê∂àÈô§„ÄÇÂ§ÑÁêÜÂÆåÊàêÂêéÂèØ‰∏ãËΩΩ„ÄÇ',
          'remove.brushSize': 'ÁîªÁ¨îÂ§ßÂ∞è',
          'remove.brushDownAria': 'ÂáèÂ∞èÁîªÁ¨îÂ§ßÂ∞è',
          'remove.brushUpAria': 'Â¢ûÂ§ßÁîªÁ¨îÂ§ßÂ∞è',
          'remove.algorithm': 'Ê∂àÈô§ÁÆóÊ≥ï',
          'remove.algorithm.aggressive': 'Âº∫ÂäõÔºàÂØπË±°Êì¶Èô§Ôºâ',
          'remove.algorithm.aggressive.desc': 'ÊúÄÂø´Ê®°ÂºèÔºöÈÄÇÂêàÂø´ÈÄüÂéªÈô§Ê†áÁ≠æ„ÄÅLogo„ÄÅÊñáÂ≠óÂíåÁ°¨ËæπÂØπË±°„ÄÇ',
          'remove.algorithm.ai': 'AI ÁîüÊàêÂºèÔºàÊú¨Âú∞Ôºâ',
          'remove.algorithm.ai.desc': 'ÊúÄ‰Ω≥Ë¥®ÈáèÔºàÊõ¥ÊÖ¢ÔºâÔºöÊõ¥Âº∫Ê∂àÈô§ÔºåËÉåÊôØÁîüÊàêÊõ¥Âπ≤ÂáÄ„ÄÇ',
          'remove.algorithm.texture': '‰øùÁïôÁ∫πÁêÜ',
          'remove.algorithm.texture.desc': 'ÈÄÇÂêàÊú®Á∫π„ÄÅÁªáÁâ©„ÄÅÊ∑∑ÂáùÂúüÂíåÂô™ÁÇπ/ÂõæÊ°àËÉåÊôØÔºå‰øùÁïôËá™ÁÑ∂Á∫πÁêÜ„ÄÇ',
          'remove.algorithm.natural': 'Ëá™ÁÑ∂ÔºàÂπ≥ÊªëÔºâ',
          'remove.algorithm.natural.desc': 'ÈÄÇÂêàÂ§©Á©∫„ÄÅÂ¢ôÈù¢„ÄÅÁöÆËÇ§ÂíåÊüîÂíåËôöÂåñËÉåÊôØÔºåËøáÊ∏°Êõ¥Âπ≥Êªë„ÄÇ',
          'remove.instructions': 'Âú®Ë¶ÅÁßªÈô§ÁöÑÂØπË±°‰∏äÊ∂ÇÊäπ„ÄÇÂèØÁº©Êîæ‰ª•Á≤æÁªÜÁºñËæë„ÄÇ',
          'remove.empty.title': '‰∏ä‰º†ÂõæÁâáÂêéÂºÄÂßãÊ∂ÇÊäπÊ∂àÈô§„ÄÇ',
          'remove.empty.sub': 'Êä¨Ëµ∑ÊâãÊåáÊàñÈº†Ê†áÂç≥ÂèØËá™Âä®Â∫îÁî®Ê∂àÈô§„ÄÇ',
          'remove.progressWarning': 'Â¶ÇÊûúÂÖ≥Èó≠ÊàñÂà∑Êñ∞Ê≠§È°µÈù¢ÔºåÊ∂àÈô§ËøõÂ∫¶Â∞Ü‰∏¢Â§±„ÄÇ',
          'hero.remove.title': 'ÂÖçË¥πÂØπË±°Ê∂àÈô§',
          'hero.remove.subtitle': 'Ê∂ÇÊäπÂπ∂Ê∂àÈô§‰∏çÈúÄË¶ÅÂå∫ÂüüÔºåÂÆåÊàêÂêé‰∏ãËΩΩ„ÄÇ',
          'btn.downloadWhenReady': '‰∏ãËΩΩÁªìÊûú',
          'btn.back': '<- ËøîÂõû',
          'status.removing': 'Ê≠£Âú®Ê∂àÈô§ÈÄâ‰∏≠ÂØπË±°...',
          'status.removeReady': 'Ê∂àÈô§ÂÆåÊàê„ÄÇËØ∑Ê£ÄÊü•ÂêéÁÇπÂáª‰∏ãËΩΩÁªìÊûú„ÄÇ',
          'status.removeMaskEmpty': 'ËØ∑ÂÖàÊ∂ÇÊäπËá≥Â∞ë‰∏Ä‰∏™ÈúÄË¶ÅÊ∂àÈô§ÁöÑÂå∫Âüü„ÄÇ',
          'status.removeUndoDone': 'Â∑≤Êí§ÈîÄ‰∏ä‰∏ÄÊ¨°Ê∂àÈô§„ÄÇ',
          'status.removeImageLoaded': 'ÂõæÁâáÂ∑≤Âä†ËΩΩ„ÄÇÊ∂ÇÊäπÂêéÊä¨ÊâãÂç≥ÂèØÂ∫îÁî®Ê∂àÈô§„ÄÇ',
          'error.removeFailed': 'ÂØπË±°Ê∂àÈô§Â§±Ë¥•„ÄÇ'
        },
        hi: {
          'tab.remove': 'AI ‡§π‡§ü‡§æ‡§è‡§Ç',
          'remove.title': '‡§ë‡§¨‡•ç‡§ú‡•á‡§ï‡•ç‡§ü ‡§π‡§ü‡§æ‡§è‡§Ç',
          'remove.subtitle': '‡§Ö‡§®‡§ö‡§æ‡§π‡§æ ‡§π‡§ø‡§∏‡•ç‡§∏‡§æ ‡§™‡•á‡§Ç‡§ü ‡§ï‡§∞‡•á‡§Ç, ‡§õ‡•ã‡§°‡§º‡§§‡•á ‡§π‡•Ä ‡§π‡§ü‡•á‡§ó‡§æ‡•§ ‡§™‡•Ç‡§∞‡§æ ‡§π‡•ã‡§®‡•á ‡§™‡§∞ ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§ö‡§æ‡§≤‡•Ç ‡§π‡•ã‡§ó‡§æ‡•§',
          'remove.brushSize': '‡§¨‡•ç‡§∞‡§∂ ‡§Ü‡§ï‡§æ‡§∞',
          'remove.brushDownAria': '‡§¨‡•ç‡§∞‡§∂ ‡§Ü‡§ï‡§æ‡§∞ ‡§ï‡§Æ ‡§ï‡§∞‡•á‡§Ç',
          'remove.brushUpAria': '‡§¨‡•ç‡§∞‡§∂ ‡§Ü‡§ï‡§æ‡§∞ ‡§¨‡§¢‡§º‡§æ‡§è‡§Ç',
          'remove.algorithm': '‡§∞‡§ø‡§Æ‡•Ç‡§µ‡§≤ ‡§è‡§≤‡•ç‡§ó‡•ã‡§∞‡§ø‡§¶‡§Æ',
          'remove.algorithm.aggressive': '‡§è‡§ó‡•ç‡§∞‡•á‡§∏‡§ø‡§µ (‡§ë‡§¨‡•ç‡§ú‡•á‡§ï‡•ç‡§ü ‡§á‡§∞‡•á‡§ú‡§º)',
          'remove.algorithm.aggressive.desc': '‡§∏‡§¨‡§∏‡•á ‡§§‡•á‡§ú‡§º ‡§Æ‡•ã‡§°: ‡§≤‡•á‡§¨‡§≤, ‡§≤‡•ã‡§ó‡•ã, ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§î‡§∞ ‡§π‡§æ‡§∞‡•ç‡§°-‡§è‡§ú ‡§ë‡§¨‡•ç‡§ú‡•á‡§ï‡•ç‡§ü ‡§ï‡•ã ‡§ú‡§≤‡•ç‡§¶‡•Ä ‡§π‡§ü‡§æ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è‡•§',
          'remove.algorithm.ai': 'AI ‡§ú‡•á‡§®‡§∞‡•á‡§ü‡§ø‡§µ (‡§ï‡•ç‡§≤‡§æ‡§á‡§Ç‡§ü-‡§∏‡§æ‡§á‡§°)',
          'remove.algorithm.ai.desc': '‡§¨‡•á‡§π‡§§‡§∞ ‡§ï‡•ç‡§µ‡§æ‡§≤‡§ø‡§ü‡•Ä (‡§ß‡•Ä‡§Æ‡§æ): ‡§ú‡•ç‡§Ø‡§æ‡§¶‡§æ ‡§∏‡§æ‡§´ ‡§π‡§ü‡§æ‡§®‡§æ ‡§î‡§∞ ‡§¨‡•á‡§π‡§§‡§∞ ‡§¨‡•à‡§ï‡§ó‡•ç‡§∞‡§æ‡§â‡§Ç‡§° ‡§´‡§ø‡§≤‡•§',
          'remove.algorithm.texture': '‡§ü‡•á‡§ï‡•ç‡§∏‡§ö‡§∞ ‡§™‡•ç‡§∞‡§ø‡§ú‡§º‡§∞‡•ç‡§µ',
          'remove.algorithm.texture.desc': '‡§µ‡•Å‡§° ‡§ó‡•ç‡§∞‡•á‡§®, ‡§ï‡§™‡§°‡§º‡§æ, ‡§ï‡§Ç‡§ï‡•ç‡§∞‡•Ä‡§ü ‡§î‡§∞ ‡§™‡•à‡§ü‡§∞‡•ç‡§®/‡§®‡•â‡§á‡§ú‡§º ‡§¨‡•à‡§ï‡§ó‡•ç‡§∞‡§æ‡§â‡§Ç‡§° ‡§Æ‡•á‡§Ç ‡§ü‡•á‡§ï‡•ç‡§∏‡§ö‡§∞ ‡§¨‡§ö‡§æ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è‡•§',
          'remove.algorithm.natural': '‡§®‡•á‡§ö‡•Å‡§∞‡§≤ (‡§∏‡•ç‡§Æ‡•Ç‡§¶)',
          'remove.algorithm.natural.desc': '‡§Ü‡§∏‡§Æ‡§æ‡§®, ‡§¶‡•Ä‡§µ‡§æ‡§∞, ‡§§‡•ç‡§µ‡§ö‡§æ ‡§î‡§∞ ‡§∏‡•â‡§´‡•ç‡§ü ‡§¨‡•ç‡§≤‡§∞ ‡§¨‡•à‡§ï‡§ó‡•ç‡§∞‡§æ‡§â‡§Ç‡§° ‡§ï‡•á ‡§≤‡§ø‡§è ‡§∏‡•ç‡§Æ‡•Ç‡§¶ ‡§¨‡•ç‡§≤‡•á‡§Ç‡§°‡§ø‡§Ç‡§ó‡•§',
          'remove.instructions': '‡§ú‡§ø‡§∏ ‡§ë‡§¨‡•ç‡§ú‡•á‡§ï‡•ç‡§ü ‡§ï‡•ã ‡§π‡§ü‡§æ‡§®‡§æ ‡§π‡•à ‡§â‡§∏ ‡§™‡§∞ ‡§™‡•á‡§Ç‡§ü ‡§ï‡§∞‡•á‡§Ç‡•§ ‡§∏‡§ü‡•Ä‡§ï ‡§è‡§°‡§ø‡§ü ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ú‡§º‡•Ç‡§Æ ‡§ï‡§∞‡•á‡§Ç‡•§',
          'remove.empty.title': '‡§á‡§Æ‡•á‡§ú ‡§Ö‡§™‡§≤‡•ã‡§° ‡§ï‡§∞‡•á‡§Ç, ‡§´‡§ø‡§∞ ‡§π‡§ü‡§æ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§™‡•á‡§Ç‡§ü ‡§ï‡§∞‡•á‡§Ç‡•§',
          'remove.empty.sub': '‡§â‡§Ç‡§ó‡§≤‡•Ä/‡§Æ‡§æ‡§â‡§∏ ‡§õ‡•ã‡§°‡§º‡§§‡•á ‡§π‡•Ä ‡§∞‡§ø‡§Æ‡•Ç‡§µ‡§≤ ‡§≤‡§æ‡§ó‡•Ç ‡§π‡•ã‡§ó‡§æ‡•§',
          'remove.progressWarning': '‡§Ö‡§ó‡§∞ ‡§Ü‡§™ ‡§Ø‡§π ‡§ü‡•à‡§¨ ‡§¨‡§Ç‡§¶ ‡§Ø‡§æ ‡§∞‡§ø‡§´‡•ç‡§∞‡•á‡§∂ ‡§ï‡§∞‡•á‡§Ç‡§ó‡•á, ‡§™‡•ç‡§∞‡•ã‡§ó‡•ç‡§∞‡•á‡§∏ ‡§ñ‡•ã ‡§ú‡§æ‡§è‡§ó‡•Ä‡•§',
          'hero.remove.title': '‡§´‡•ç‡§∞‡•Ä ‡§ë‡§¨‡•ç‡§ú‡•á‡§ï‡•ç‡§ü ‡§∞‡§ø‡§Æ‡•Ç‡§µ‡§∞',
          'hero.remove.subtitle': '‡§™‡•á‡§Ç‡§ü ‡§ï‡§∞‡•á‡§Ç, ‡§Ö‡§®‡§ö‡§æ‡§π‡§æ ‡§π‡§ø‡§∏‡•ç‡§∏‡§æ ‡§π‡§ü‡§æ‡§è‡§Ç ‡§î‡§∞ ‡§™‡•Ç‡§∞‡§æ ‡§π‡•ã‡§®‡•á ‡§™‡§∞ ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§ï‡§∞‡•á‡§Ç‡•§',
          'btn.downloadWhenReady': '‡§∞‡§ø‡§ú‡§º‡§≤‡•ç‡§ü ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§ï‡§∞‡•á‡§Ç',
          'btn.back': '<- ‡§µ‡§æ‡§™‡§∏',
          'status.removing': '‡§ö‡§Ø‡§®‡§ø‡§§ ‡§ë‡§¨‡•ç‡§ú‡•á‡§ï‡•ç‡§ü ‡§π‡§ü‡§æ‡§Ø‡§æ ‡§ú‡§æ ‡§∞‡§π‡§æ ‡§π‡•à...',
          'status.removeReady': '‡§∞‡§ø‡§Æ‡•Ç‡§µ‡§≤ ‡§™‡•Ç‡§∞‡§æ‡•§ ‡§ú‡§æ‡§Ç‡§ö‡•á‡§Ç ‡§î‡§∞ ‡§∞‡§ø‡§ú‡§º‡§≤‡•ç‡§ü ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§ï‡§∞‡•á‡§Ç‡•§',
          'status.removeMaskEmpty': '‡§™‡§π‡§≤‡•á ‡§π‡§ü‡§æ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ï‡§Æ ‡§∏‡•á ‡§ï‡§Æ ‡§è‡§ï ‡§ï‡•ç‡§∑‡•á‡§§‡•ç‡§∞ ‡§™‡•á‡§Ç‡§ü ‡§ï‡§∞‡•á‡§Ç‡•§',
          'status.removeUndoDone': '‡§Ü‡§ñ‡§ø‡§∞‡•Ä ‡§∞‡§ø‡§Æ‡•Ç‡§µ‡§≤ ‡§µ‡§æ‡§™‡§∏ ‡§≤‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ‡•§',
          'status.removeImageLoaded': '‡§á‡§Æ‡•á‡§ú ‡§≤‡•ã‡§° ‡§π‡•ã ‡§ó‡§à‡•§ ‡§™‡•á‡§Ç‡§ü ‡§ï‡§∞‡•á‡§Ç ‡§î‡§∞ ‡§õ‡•ã‡§°‡§º‡§§‡•á ‡§π‡•Ä ‡§≤‡§æ‡§ó‡•Ç ‡§π‡•ã‡§ó‡§æ‡•§',
          'error.removeFailed': '‡§ë‡§¨‡•ç‡§ú‡•á‡§ï‡•ç‡§ü ‡§∞‡§ø‡§Æ‡•Ç‡§µ‡§≤ ‡§µ‡§ø‡§´‡§≤‡•§'
        },
        ja: {
          'tab.remove': 'AIÂâäÈô§',
          'remove.title': '„Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÂâäÈô§',
          'remove.subtitle': '‰∏çË¶ÅÈÉ®ÂàÜ„ÇíÂ°ó„Çã„Å®„ÄÅÊåá/„Éû„Ç¶„Çπ„ÇíÈõ¢„Åó„ÅüÊôÇÁÇπ„ÅßËá™ÂãïÂâäÈô§„Åï„Çå„Åæ„Åô„ÄÇ',
          'remove.brushSize': '„Éñ„É©„Ç∑„Çµ„Ç§„Ç∫',
          'remove.brushDownAria': '„Éñ„É©„Ç∑„Çµ„Ç§„Ç∫„ÇíÂ∞è„Åï„Åè„Åô„Çã',
          'remove.brushUpAria': '„Éñ„É©„Ç∑„Çµ„Ç§„Ç∫„ÇíÂ§ß„Åç„Åè„Åô„Çã',
          'remove.algorithm': 'ÂâäÈô§„Ç¢„É´„Ç¥„É™„Ç∫„É†',
          'remove.algorithm.aggressive': 'Âº∑ÂäõÔºà„Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÊ∂àÂéªÔºâ',
          'remove.algorithm.aggressive.desc': 'ÊúÄÈÄü„É¢„Éº„Éâ„ÄÇ„É©„Éô„É´„Éª„É≠„Ç¥„ÉªÊñáÂ≠ó„ÉªÁ°¨„ÅÑËº™ÈÉ≠„ÇíÁ¥†Êó©„ÅèÊ∂à„Åó„Åü„ÅÑÊôÇ„Å´ÊúÄÈÅ©„Åß„Åô„ÄÇ',
          'remove.algorithm.ai': 'AIÁîüÊàêÔºà„ÇØ„É©„Ç§„Ç¢„É≥„ÉàÂÅ¥Ôºâ',
          'remove.algorithm.ai.desc': 'È´òÂìÅË≥™ÔºàÈÅÖ„ÇÅÔºâÔºö„Çà„ÇäÂº∑„ÅÑÂâäÈô§„Å®„ÄÅ„Çà„ÇäËá™ÁÑ∂„Å™ËÉåÊôØÂÜçÁîüÊàê„ÄÇ',
          'remove.algorithm.texture': '„ÉÜ„ÇØ„Çπ„ÉÅ„É£‰øùÊåÅ',
          'remove.algorithm.texture.desc': 'Êú®ÁõÆ„ÉªÂ∏É„Éª„Ç≥„É≥„ÇØ„É™„Éº„Éà„Éª„Éé„Ç§„Ç∫/„Éë„Çø„Éº„É≥ËÉåÊôØ„ÅßË≥™ÊÑü„Çí‰øù„Å°„Åü„ÅÑÂ†¥Âêà„Å´ÊúÄÈÅ©„ÄÇ',
          'remove.algorithm.natural': '„Éä„ÉÅ„É•„É©„É´ÔºàÊªë„Çâ„ÅãÔºâ',
          'remove.algorithm.natural.desc': 'Á©∫„ÉªÂ£Å„ÉªËÇå„Éª„Åº„Åã„ÅóËÉåÊôØ„Å™„Å©„ÄÅÊªë„Çâ„Åã„Å™„Å§„Å™„Åå„Çä„ÇíÈáçË¶ñ„Åô„ÇãÂ†¥Âêà„Å´ÊúÄÈÅ©„ÄÇ',
          'remove.instructions': 'ÂâäÈô§„Åó„Åü„ÅÑÂØæË±°„ÇíÂ°ó„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇÊã°Â§ß/Á∏ÆÂ∞è„Åó„Å¶Á≤æÂØÜ„Å´Á∑®ÈõÜ„Åß„Åç„Åæ„Åô„ÄÇ',
          'remove.empty.title': 'ÁîªÂÉè„Çí„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Åó„Å¶„ÄÅÂâäÈô§„Åó„Åü„ÅÑÁÆáÊâÄ„ÇíÂ°ó„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
          'remove.empty.sub': 'Êåá/„Éû„Ç¶„Çπ„ÇíÈõ¢„Åô„Å®Ëá™Âãï„ÅßÂâäÈô§„ÅåÈÅ©Áî®„Åï„Çå„Åæ„Åô„ÄÇ',
          'remove.progressWarning': '„Åì„ÅÆ„Çø„Éñ„ÇíÈñâ„Åò„Çã/Êõ¥Êñ∞„Åô„Çã„Å®„ÄÅ‰ΩúÊ•≠‰∏≠„ÅÆÈÄ≤Êçó„ÅØÂ§±„Çè„Çå„Åæ„Åô„ÄÇ',
          'hero.remove.title': 'ÁÑ°Êñô„Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÂâäÈô§',
          'hero.remove.subtitle': 'Â°ó„Å£„Å¶‰∏çË¶ÅÈÉ®ÂàÜ„ÇíÂâäÈô§„Åó„ÄÅÂÆå‰∫ÜÂæå„Å´„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„ÄÇ',
          'btn.downloadWhenReady': 'ÁµêÊûú„Çí„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ',
          'btn.back': '<- Êàª„Çã',
          'status.removing': 'ÈÅ∏Êäû„Åó„Åü„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíÂâäÈô§‰∏≠...',
          'status.removeReady': 'ÂâäÈô§ÂÆå‰∫Ü„ÄÇÁ¢∫Ë™ç„Åó„Å¶„ÄåÁµêÊûú„Çí„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Äç„ÇíÊäº„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
          'status.removeMaskEmpty': 'ÂÖà„Å´ÂâäÈô§„Åó„Åü„ÅÑÈ†òÂüü„ÇíÂ∞ë„Å™„Åè„Å®„ÇÇ1„ÅãÊâÄÂ°ó„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
          'status.removeUndoDone': 'Áõ¥Ââç„ÅÆÂâäÈô§„ÇíÂÖÉ„Å´Êàª„Åó„Åæ„Åó„Åü„ÄÇ',
          'status.removeImageLoaded': 'ÁîªÂÉè„ÇíË™≠„ÅøËæº„Åø„Åæ„Åó„Åü„ÄÇÂ°ó„Å£„Å¶Èõ¢„Åô„Å®Ëá™ÂãïÈÅ©Áî®„Åï„Çå„Åæ„Åô„ÄÇ',
          'error.removeFailed': '„Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÂâäÈô§„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ'
        },
        ko: {
          'tab.remove': 'AI Ï†úÍ±∞',
          'remove.title': 'Ïò§Î∏åÏ†ùÌä∏ Ï†úÍ±∞',
          'remove.subtitle': 'ÏõêÌïòÎäî ÏòÅÏó≠ÏùÑ Ïπ†ÌïòÍ≥† ÏÜê/ÎßàÏö∞Ïä§Î•º ÎñºÎ©¥ ÏûêÎèôÏúºÎ°ú Ï†úÍ±∞Îê©ÎãàÎã§.',
          'remove.brushSize': 'Î∏åÎü¨Ïãú ÌÅ¨Í∏∞',
          'remove.brushDownAria': 'Î∏åÎü¨Ïãú ÌÅ¨Í∏∞ Ï§ÑÏù¥Í∏∞',
          'remove.brushUpAria': 'Î∏åÎü¨Ïãú ÌÅ¨Í∏∞ ÎäòÎ¶¨Í∏∞',
          'remove.algorithm': 'Ï†úÍ±∞ ÏïåÍ≥†Î¶¨Ï¶ò',
          'remove.algorithm.aggressive': 'Í∞ïÎ†• (Ïò§Î∏åÏ†ùÌä∏ ÏßÄÏö∞Í∏∞)',
          'remove.algorithm.aggressive.desc': 'Í∞ÄÏû• Îπ†Î•∏ Î™®Îìú: ÎùºÎ≤®, Î°úÍ≥†, ÌÖçÏä§Ìä∏, ÎöúÎ†∑Ìïú Í≤ΩÍ≥ÑÎ•º Îπ†Î•¥Í≤å ÏßÄÏö∏ Îïå Ï†ÅÌï©Ìï©ÎãàÎã§.',
          'remove.algorithm.ai': 'AI ÏÉùÏÑ±Ìòï (ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï∏°)',
          'remove.algorithm.ai.desc': 'ÏµúÍ≥† ÌíàÏßà(ÎäêÎ¶º): Îçî Í∞ïÌïú Ï†úÍ±∞ÏôÄ Îçî ÍπîÎÅîÌïú Î∞∞Í≤Ω ÏÉùÏÑ±.',
          'remove.algorithm.texture': 'ÌÖçÏä§Ï≤ò Î≥¥Ï°¥',
          'remove.algorithm.texture.desc': 'ÎÇòÎ¨¥Í≤∞, Ï≤ú, ÏΩòÌÅ¨Î¶¨Ìä∏, ÎÖ∏Ïù¥Ï¶à/Ìå®ÌÑ¥ Î∞∞Í≤ΩÏùò ÏßàÍ∞êÏùÑ ÏÇ¥Î¶¨Í≥† Ïã∂ÏùÑ Îïå Ï†ÅÌï©Ìï©ÎãàÎã§.',
          'remove.algorithm.natural': 'ÏûêÏó∞Ïä§Îü¨ÏõÄ (Î∂ÄÎìúÎüΩÍ≤å)',
          'remove.algorithm.natural.desc': 'ÌïòÎäò, Î≤Ω, ÌîºÎ∂Ä, ÏÜåÌîÑÌä∏ Î∏îÎü¨ Î∞∞Í≤ΩÏùò ÏûêÏó∞Ïä§Îü¨Ïö¥ Î∏îÎ†åÎî©Ïóê Ï†ÅÌï©Ìï©ÎãàÎã§.',
          'remove.instructions': 'Ï†úÍ±∞Ìï† ÎåÄÏÉÅ ÏúÑÎ•º Ïπ†ÌïòÏÑ∏Ïöî. ÌôïÎåÄ/Ï∂ïÏÜåÎ°ú Ï†ïÎ∞Ä Ìé∏ÏßëÌï† Ïàò ÏûàÏäµÎãàÎã§.',
          'remove.empty.title': 'Ïù¥ÎØ∏ÏßÄÎ•º ÏóÖÎ°úÎìúÌïú Îí§, Ï†úÍ±∞Ìï† Î∂ÄÎ∂ÑÏùÑ Ïπ†ÌïòÏÑ∏Ïöî.',
          'remove.empty.sub': 'ÏÜêÍ∞ÄÎùΩ/ÎßàÏö∞Ïä§Î•º ÎñºÎ©¥ ÏûêÎèôÏúºÎ°ú Ï†úÍ±∞Í∞Ä Ï†ÅÏö©Îê©ÎãàÎã§.',
          'remove.progressWarning': 'Ïù¥ ÌÉ≠ÏùÑ Îã´Í±∞ÎÇò ÏÉàÎ°úÍ≥†Ïπ®ÌïòÎ©¥ ÏßÑÌñâ ÎÇ¥Ïö©Ïù¥ ÏÇ¨ÎùºÏßëÎãàÎã§.',
          'hero.remove.title': 'Î¨¥Î£å Ïò§Î∏åÏ†ùÌä∏ Ï†úÍ±∞Í∏∞',
          'hero.remove.subtitle': 'Ïπ†Ìï¥ÏÑú Î∂àÌïÑÏöîÌïú Î∂ÄÎ∂ÑÏùÑ Ï†úÍ±∞ÌïòÍ≥† ÏôÑÎ£å ÌõÑ Îã§Ïö¥Î°úÎìúÌïòÏÑ∏Ïöî.',
          'btn.downloadWhenReady': 'Í≤∞Í≥º Îã§Ïö¥Î°úÎìú',
          'btn.back': '<- Îí§Î°ú',
          'status.removing': 'ÏÑ†ÌÉùÌïú Ïò§Î∏åÏ†ùÌä∏Î•º Ï†úÍ±∞ Ï§ë...',
          'status.removeReady': 'Ï†úÍ±∞ ÏôÑÎ£å. ÌôïÏù∏ ÌõÑ Í≤∞Í≥ºÎ•º Îã§Ïö¥Î°úÎìúÌïòÏÑ∏Ïöî.',
          'status.removeMaskEmpty': 'Î®ºÏ†Ä Ï†úÍ±∞Ìï† ÏòÅÏó≠ÏùÑ ÏµúÏÜå Ìïú Í≥≥ Ïù¥ÏÉÅ Ïπ†ÌïòÏÑ∏Ïöî.',
          'status.removeUndoDone': 'ÎßàÏßÄÎßâ Ï†úÍ±∞Î•º ÎêòÎèåÎ†∏ÏäµÎãàÎã§.',
          'status.removeImageLoaded': 'Ïù¥ÎØ∏ÏßÄ Î°úÎìú ÏôÑÎ£å. Ïπ†ÌïòÍ≥† ÎñºÎ©¥ ÏûêÎèô Ï†ÅÏö©Îê©ÎãàÎã§.',
          'error.removeFailed': 'Ïò§Î∏åÏ†ùÌä∏ Ï†úÍ±∞ Ïã§Ìå®.'
        },
        ar: {
          'tab.remove': 'ÿ•ÿ≤ÿßŸÑÿ© AI',
          'remove.title': 'ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿπŸÜÿßÿµÿ±',
          'remove.subtitle': 'ŸÑŸàŸëŸÜ ÿßŸÑÿ¨ÿ≤ÿ° ÿ∫Ÿäÿ± ÿßŸÑŸÖÿ±ÿ∫Ÿàÿ®ÿå ŸàÿπŸÜÿØ ÿ±ŸÅÿπ ÿßŸÑÿ•ÿµÿ®ÿπ/ÿßŸÑŸÖÿßŸàÿ≥ Ÿäÿ™ŸÖ ÿßŸÑÿ•ÿ≤ÿßŸÑÿ© ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß.',
          'remove.brushSize': 'ÿ≠ÿ¨ŸÖ ÿßŸÑŸÅÿ±ÿ¥ÿßÿ©',
          'remove.brushDownAria': 'ÿ™ŸÇŸÑŸäŸÑ ÿ≠ÿ¨ŸÖ ÿßŸÑŸÅÿ±ÿ¥ÿßÿ©',
          'remove.brushUpAria': 'ÿ≤ŸäÿßÿØÿ© ÿ≠ÿ¨ŸÖ ÿßŸÑŸÅÿ±ÿ¥ÿßÿ©',
          'remove.algorithm': 'ÿÆŸàÿßÿ±ÿ≤ŸÖŸäÿ© ÿßŸÑÿ•ÿ≤ÿßŸÑÿ©',
          'remove.algorithm.aggressive': 'ŸÇŸàŸä (ŸÖÿ≠Ÿà ÿßŸÑÿπŸÜÿµÿ±)',
          'remove.algorithm.aggressive.desc': 'ÿ£ÿ≥ÿ±ÿπ Ÿàÿ∂ÿπ ŸÑÿ•ÿ≤ÿßŸÑÿ© ÿ≥ÿ±Ÿäÿπÿ© ŸÑŸÑŸÖŸÑÿµŸÇÿßÿ™ ŸàÿßŸÑÿ¥ÿπÿßÿ±ÿßÿ™ ŸàÿßŸÑŸÜÿµŸàÿµ ŸàÿßŸÑÿ≠ŸàÿßŸÅ ÿßŸÑŸÇŸàŸäÿ©.',
          'remove.algorithm.ai': 'ÿ™ŸàŸÑŸäÿØŸä ÿ®ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä (ŸÖÿ≠ŸÑŸäŸãÿß)',
          'remove.algorithm.ai.desc': 'ÿ£ŸÅÿ∂ŸÑ ÿ¨ŸàÿØÿ© (ÿ£ÿ®ÿ∑ÿ£): ÿ•ÿ≤ÿßŸÑÿ© ÿ£ŸÇŸàŸâ ŸÖÿπ ÿ™ŸàŸÑŸäÿØ ÿÆŸÑŸÅŸäÿ© ÿ£ŸÜÿ∏ŸÅ.',
          'remove.algorithm.texture': 'ÿßŸÑÿ≠ŸÅÿßÿ∏ ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÖÿ≥',
          'remove.algorithm.texture.desc': 'ÿßŸÑÿ£ŸÅÿ∂ŸÑ ŸÑÿπÿ±ŸàŸÇ ÿßŸÑÿÆÿ¥ÿ® ŸàÿßŸÑÿ£ŸÇŸÖÿ¥ÿ© ŸàÿßŸÑÿÆÿ±ÿ≥ÿßŸÜÿ© ŸàÿßŸÑÿÆŸÑŸÅŸäÿßÿ™ ÿ∞ÿßÿ™ ÿßŸÑÿ∂ÿ¨Ÿäÿ¨/ÿßŸÑŸÜŸÖÿ∑ ŸÑŸÑÿ≠ŸÅÿßÿ∏ ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÖÿ≥.',
          'remove.algorithm.natural': 'ÿ∑ÿ®ŸäÿπŸä (ŸÜÿßÿπŸÖ)',
          'remove.algorithm.natural.desc': 'ÿßŸÑÿ£ŸÅÿ∂ŸÑ ŸÑŸÑÿ≥ŸÖÿßÿ° ŸàÿßŸÑÿ¨ÿØÿ±ÿßŸÜ ŸàÿßŸÑÿ®ÿ¥ÿ±ÿ© ŸàÿßŸÑÿÆŸÑŸÅŸäÿßÿ™ ÿßŸÑÿ∂ÿ®ÿßÿ®Ÿäÿ© ÿßŸÑŸÜÿßÿπŸÖÿ©.',
          'remove.instructions': 'ŸÑŸàŸëŸÜ ŸÅŸàŸÇ ÿßŸÑÿπŸÜÿµÿ± ÿßŸÑŸÖÿ±ÿßÿØ ÿ•ÿ≤ÿßŸÑÿ™Ÿá. ŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿ™ŸÉÿ®Ÿäÿ±/ÿßŸÑÿ™ÿµÿ∫Ÿäÿ± ŸÑŸÑÿ™ÿ≠ÿ±Ÿäÿ± ÿßŸÑÿØŸÇŸäŸÇ.',
          'remove.empty.title': 'ÿßÿ±ŸÅÿπ ÿµŸàÿ±ÿ© ÿ´ŸÖ ŸÑŸàŸëŸÜ ŸÑŸÑÿ•ÿ≤ÿßŸÑÿ©.',
          'remove.empty.sub': 'ÿπŸÜÿØ ÿ±ŸÅÿπ ÿßŸÑÿ•ÿµÿ®ÿπ ÿ£Ÿà ÿßŸÑŸÖÿßŸàÿ≥ Ÿäÿ™ŸÖ ÿ™ÿ∑ÿ®ŸäŸÇ ÿßŸÑÿ•ÿ≤ÿßŸÑÿ© ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß.',
          'remove.progressWarning': 'ÿ•ÿ∞ÿß ÿ£ÿ∫ŸÑŸÇÿ™ ÿ£Ÿà ÿ≠ÿØŸëÿ´ÿ™ Ÿáÿ∞Ÿá ÿßŸÑÿµŸÅÿ≠ÿ© ŸÅÿ≥ÿ™ŸÅŸÇÿØ ÿßŸÑÿ™ŸÇÿØŸÖ.',
          'hero.remove.title': 'ŸÖÿ≤ŸäŸÑ ÿßŸÑÿπŸÜÿßÿµÿ± ÿßŸÑŸÖÿ¨ÿßŸÜŸä',
          'hero.remove.subtitle': 'ŸÑŸàŸëŸÜ Ÿàÿ£ÿ≤ŸÑ ÿßŸÑŸÖŸÜÿßÿ∑ŸÇ ÿ∫Ÿäÿ± ÿßŸÑŸÖÿ±ÿ∫Ÿàÿ®ÿ© ÿ´ŸÖ ŸÜÿ≤ŸëŸÑ ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ© ÿ®ÿπÿØ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ°.',
          'btn.downloadWhenReady': 'ÿ™ŸÜÿ≤ŸäŸÑ ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ©',
          'btn.back': '<- ÿ±ÿ¨Ÿàÿπ',
          'status.removing': 'ÿ¨ÿßÿ±Ÿç ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿπŸÜÿµÿ± ÿßŸÑŸÖÿ≠ÿØÿØ...',
          'status.removeReady': 'ÿßŸÉÿ™ŸÖŸÑÿ™ ÿßŸÑÿ•ÿ≤ÿßŸÑÿ©. ÿ±ÿßÿ¨ÿπ ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ© Ÿàÿßÿ∂ÿ∫ÿ∑ ÿ™ŸÜÿ≤ŸäŸÑ.',
          'status.removeMaskEmpty': 'ŸÑŸàŸëŸÜ ŸÖŸÜÿ∑ŸÇÿ© Ÿàÿßÿ≠ÿØÿ© ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ ŸÇÿ®ŸÑ ÿßŸÑÿ®ÿØÿ° ÿ®ÿßŸÑÿ•ÿ≤ÿßŸÑÿ©.',
          'status.removeUndoDone': 'ÿ™ŸÖ ÿßŸÑÿ™ÿ±ÿßÿ¨ÿπ ÿπŸÜ ÿ¢ÿÆÿ± ÿ•ÿ≤ÿßŸÑÿ©.',
          'status.removeImageLoaded': 'ÿ™ŸÖ ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿµŸàÿ±ÿ©. ŸÑŸàŸëŸÜ ÿ´ŸÖ ÿßÿ±ŸÅÿπ ÿßŸÑÿ•ÿµÿ®ÿπ/ÿßŸÑŸÖÿßŸàÿ≥ ŸÑŸÑÿ™ÿ∑ÿ®ŸäŸÇ.',
          'error.removeFailed': 'ŸÅÿ¥ŸÑÿ™ ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿπŸÜÿµÿ±.'
        }
      };

      Object.entries(removeI18nOverrides).forEach(([lang, map]) => {
        if (!i18n[lang]) return;
        Object.assign(i18n[lang], map);
      });

      function t(key, vars) {
        const dict = i18n[locale] || i18n.en;
        let text = dict[key] || i18n.en[key] || key;
        if (vars) {
          Object.entries(vars).forEach(([name, value]) => {
            text = text.replace(`{${name}}`, value);
          });
        }
        return text;
      }

      function fileNameLabelId(fileInputId) {
        return `${fileInputId}Name`;
      }

      function syncFilePickerLabel(fileInput) {
        if (!fileInput) return;
        const nameEl = document.getElementById(fileNameLabelId(fileInput.id));
        if (!nameEl) return;
        const file = fileInput.files && fileInput.files[0];
        nameEl.textContent = file ? file.name : t('status.noFileChosen');
      }

      function syncAllFilePickerLabels() {
        document.querySelectorAll('input[type="file"]').forEach((input) => {
          syncFilePickerLabel(input);
        });
      }

      function applyTranslations() {
        document.querySelectorAll('[data-i18n]').forEach((el) => {
          const key = el.getAttribute('data-i18n');
          el.textContent = t(key);
        });
        document.querySelectorAll('[data-i18n-aria-label]').forEach((el) => {
          const key = el.getAttribute('data-i18n-aria-label');
          el.setAttribute('aria-label', t(key));
        });
        document.getElementById('cropResizeWidth').placeholder = t('ph.resizeWidth');
        document.getElementById('cropResizeHeight').placeholder = t('ph.resizeHeight');
        syncAllFilePickerLabels();
      }

      function localePathFor(basePath, targetLocale) {
        const cleanBase = !basePath || basePath === '/' ? '' : basePath;
        return `/${targetLocale}${cleanBase}`;
      }

      function updateHeroForTab(tab) {
        const titleEl = document.getElementById('heroTitle');
        const subtitleEl = document.getElementById('heroSubtitle');
        if (!titleEl || !subtitleEl) return;
        titleEl.textContent = t(`hero.${tab}.title`);
        subtitleEl.textContent = t(`hero.${tab}.subtitle`);
      }

      applyTranslations();

      const languageSelect = document.getElementById('languageSelect');
      languageSelect.addEventListener('change', () => {
        const targetLocale = languageSelect.value;
        const basePath = pageConfig.basePath || '/';
        document.cookie = `lang=${targetLocale}; Path=/; Max-Age=31536000; SameSite=Lax`;
        window.location.href = localePathFor(basePath, targetLocale);
      });

      const tabButtons = Array.from(document.querySelectorAll('.tab-btn'));
      const isCoarsePointer = window.matchMedia && window.matchMedia('(pointer: coarse)').matches;
      const panels = {
        convert: document.getElementById('panel-convert'),
        crop: document.getElementById('panel-crop'),
        compress: document.getElementById('panel-compress'),
        upscale: document.getElementById('panel-upscale'),
        remove: document.getElementById('panel-remove')
      };
      const tabToPath = {
        convert: localePathFor('/convert', locale),
        crop: localePathFor('/crop', locale),
        compress: localePathFor('/compress', locale),
        upscale: localePathFor('/upscale', locale),
        remove: localePathFor('/remove', locale)
      };

      function setStatus(el, message, type) {
        el.textContent = message;
        el.className = `status${type ? ` ${type}` : ''}`;
      }

      function toQuality(value, fallback) {
        const n = Number(value);
        if (!Number.isFinite(n)) return fallback;
        return Math.max(0.01, Math.min(1, n / 100));
      }

      function extForFormat(format) {
        return format === 'jpeg' ? 'jpg' : format;
      }

      async function base64ToImage(src) {
        const img = new Image();
        await new Promise((resolve, reject) => {
          img.onload = resolve;
          img.onerror = reject;
          img.src = src;
        });
        return img;
      }

      function canvasToImage(canvas) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = reject;
          img.src = canvas.toDataURL('image/png');
        });
      }

      function drawImageToCanvas(img, width, height) {
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        ctx.drawImage(img, 0, 0, width, height);
        return canvas;
      }

      function drawResampled(canvas, ratio) {
        const srcW = canvas.width;
        const srcH = canvas.height;
        const downW = Math.max(1, Math.round(srcW * ratio));
        const downH = Math.max(1, Math.round(srcH * ratio));
        const down = document.createElement('canvas');
        down.width = downW;
        down.height = downH;
        const dctx = down.getContext('2d');
        dctx.imageSmoothingEnabled = true;
        dctx.imageSmoothingQuality = 'high';
        dctx.drawImage(canvas, 0, 0, downW, downH);

        const out = document.createElement('canvas');
        out.width = srcW;
        out.height = srcH;
        const octx = out.getContext('2d');
        octx.imageSmoothingEnabled = true;
        octx.imageSmoothingQuality = 'high';
        octx.drawImage(down, 0, 0, srcW, srcH);
        return out;
      }

      async function yieldToBrowser() {
        if (typeof requestAnimationFrame === 'function') {
          await new Promise((resolve) => requestAnimationFrame(() => resolve()));
          return;
        }
        await new Promise((resolve) => setTimeout(resolve, 0));
      }

      function estimateBlockiness(canvas) {
        const w = canvas.width;
        const h = canvas.height;
        if (w < 16 || h < 16) return 0;
        const ctx = canvas.getContext('2d');
        const data = ctx.getImageData(0, 0, w, h).data;
        let verticalDiff = 0;
        let verticalCount = 0;
        let horizontalDiff = 0;
        let horizontalCount = 0;
        const step = 2;

        for (let x = 8; x < w; x += 8) {
          for (let y = 0; y < h; y += step) {
            const a = (y * w + (x - 1)) * 4;
            const b = (y * w + x) * 4;
            const ya = data[a] * 0.299 + data[a + 1] * 0.587 + data[a + 2] * 0.114;
            const yb = data[b] * 0.299 + data[b + 1] * 0.587 + data[b + 2] * 0.114;
            verticalDiff += Math.abs(ya - yb);
            verticalCount += 1;
          }
        }

        for (let y = 8; y < h; y += 8) {
          for (let x = 0; x < w; x += step) {
            const a = ((y - 1) * w + x) * 4;
            const b = (y * w + x) * 4;
            const ya = data[a] * 0.299 + data[a + 1] * 0.587 + data[a + 2] * 0.114;
            const yb = data[b] * 0.299 + data[b + 1] * 0.587 + data[b + 2] * 0.114;
            horizontalDiff += Math.abs(ya - yb);
            horizontalCount += 1;
          }
        }

        const v = verticalCount ? verticalDiff / verticalCount : 0;
        const hAvg = horizontalCount ? horizontalDiff / horizontalCount : 0;
        return (v + hAvg) * 0.5;
      }

      async function applySharpenKernel(canvas, amount, options = {}) {
        const w = canvas.width;
        const h = canvas.height;
        const ctx = canvas.getContext('2d');
        const src = ctx.getImageData(0, 0, w, h);
        const dst = ctx.createImageData(w, h);
        const s = src.data;
        const d = dst.data;
        const a = amount;
        const center = 1 + 4 * a;
        const side = -a;
        const chunkRows = Math.max(16, Math.min(96, Number(options.chunkRows) || 48));
        const onProgress = typeof options.onProgress === 'function' ? options.onProgress : null;

        for (let yStart = 0; yStart < h; yStart += chunkRows) {
          const yEnd = Math.min(h, yStart + chunkRows);
          for (let y = yStart; y < yEnd; y += 1) {
            for (let x = 0; x < w; x += 1) {
              const idx = (y * w + x) * 4;
              for (let c = 0; c < 3; c += 1) {
                const upY = Math.max(0, y - 1);
                const dnY = Math.min(h - 1, y + 1);
                const lfX = Math.max(0, x - 1);
                const rtX = Math.min(w - 1, x + 1);
                const centerV = s[idx + c] * center;
                const up = s[(upY * w + x) * 4 + c] * side;
                const down = s[(dnY * w + x) * 4 + c] * side;
                const left = s[(y * w + lfX) * 4 + c] * side;
                const right = s[(y * w + rtX) * 4 + c] * side;
                const out = Math.max(0, Math.min(255, centerV + up + down + left + right));
                d[idx + c] = out;
              }
              d[idx + 3] = s[idx + 3];
            }
          }
          if (onProgress) onProgress(yEnd / h);
          await yieldToBrowser();
        }
        ctx.putImageData(dst, 0, 0);
      }

      async function preprocessForRestore(img, mode, onProgress) {
        const report = typeof onProgress === 'function' ? onProgress : () => {};
        report(0.04);
        const base = drawImageToCanvas(img, img.width, img.height);
        const ctx = base.getContext('2d');
        await yieldToBrowser();

        const blockiness = estimateBlockiness(base);

        // Deblock: slight down/up sampling smooths JPEG block boundaries.
        let ratio = mode === 'aggressive' ? 0.88 : mode === 'logo' ? 0.93 : 0.9;
        if (blockiness > 14) ratio -= 0.02;
        if (blockiness > 22) ratio -= 0.02;
        ratio = Math.max(0.84, Math.min(0.95, ratio));
        const deblocked = drawResampled(base, ratio);
        report(0.38);
        await yieldToBrowser();

        // Denoise lightly using blur on top of deblocked image.
        ctx.clearRect(0, 0, base.width, base.height);
        const blockBoost = blockiness > 22 ? 0.2 : blockiness > 14 ? 0.1 : 0;
        const blur = mode === 'aggressive' ? 0.8 : mode === 'logo' ? 0.3 : 0.5;
        const contrast = mode === 'aggressive' ? 1.04 : mode === 'logo' ? 1.06 : 1.03;
        ctx.filter = `blur(${(blur + blockBoost).toFixed(2)}px) contrast(${contrast})`;
        ctx.drawImage(deblocked, 0, 0);
        ctx.filter = 'none';
        report(0.6);
        await yieldToBrowser();

        // Edge recovery before AI.
        const preSharpen = mode === 'aggressive' ? 0.35 : mode === 'logo' ? 0.5 : 0.22;
        await applySharpenKernel(base, preSharpen, {
          chunkRows: 40,
          onProgress: (p) => report(0.6 + p * 0.4)
        });
        report(1);
        return base;
      }

      async function postprocessAfterRestore(img, mode, onProgress) {
        const report = typeof onProgress === 'function' ? onProgress : () => {};
        const canvas = drawImageToCanvas(img, img.width, img.height);
        const ctx = canvas.getContext('2d');
        const source = drawImageToCanvas(canvas, canvas.width, canvas.height);
        report(0.2);
        await yieldToBrowser();
        ctx.filter = mode === 'aggressive' ? 'contrast(1.05) saturate(1.03)' : mode === 'logo' ? 'contrast(1.12) saturate(1.02)' : 'contrast(1.03) saturate(1.02)';
        ctx.drawImage(source, 0, 0);
        ctx.filter = 'none';
        report(0.45);
        await yieldToBrowser();

        const postSharpen = mode === 'aggressive' ? 0.5 : mode === 'logo' ? 0.75 : 0.32;
        await applySharpenKernel(canvas, postSharpen, {
          chunkRows: 48,
          onProgress: (p) => report(0.45 + p * 0.55)
        });
        report(1);
        return canvas;
      }

      function isIOSLike() {
        const ua = navigator.userAgent || '';
        return /iPad|iPhone|iPod/.test(ua) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
      }

      async function downloadBlob(blob, filename) {
        const url = URL.createObjectURL(blob);
        if (isIOSLike()) {
          const opened = window.open(url, '_blank');
          if (!opened) {
            window.location.href = url;
          }
          setTimeout(() => URL.revokeObjectURL(url), 60000);
          return 'ios-preview';
        }

        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        link.remove();
        URL.revokeObjectURL(url);
        return 'downloaded';
      }

      function canEncode(mimeType) {
        const c = document.createElement('canvas');
        const out = c.toDataURL(mimeType);
        return out.startsWith(`data:${mimeType}`);
      }

      async function fileToImage(file) {
        const url = URL.createObjectURL(file);
        try {
          const img = new Image();
          await new Promise((resolve, reject) => {
            img.onload = resolve;
            img.onerror = reject;
            img.src = url;
          });
          return img;
        } finally {
          URL.revokeObjectURL(url);
        }
      }

      async function renderToBlob(img, mimeType, quality, sx, sy, sw, sh, dw, dh) {
        const canvas = document.createElement('canvas');
        canvas.width = dw;
        canvas.height = dh;
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        ctx.drawImage(img, sx, sy, sw, sh, 0, 0, dw, dh);
        return new Promise((resolve) => canvas.toBlob(resolve, mimeType, quality));
      }

      function setActiveTab(tab, shouldUpdateUrl = false) {
        const nextTab = panels[tab] ? tab : 'convert';
        tabButtons.forEach((b) => b.classList.toggle('active', b.dataset.tab === nextTab));
        Object.entries(panels).forEach(([name, panel]) => {
          panel.classList.toggle('active', name === nextTab);
        });
        updateHeroForTab(nextTab);
        if (nextTab === 'remove') {
          setTimeout(() => {
            refreshRemoveViewportLayout();
          }, 0);
        }

        try {
          localStorage.setItem('imgconvertcrop:lastTab', nextTab);
        } catch (_e) {}

        if (shouldUpdateUrl && tabToPath[nextTab]) {
          history.replaceState(null, '', tabToPath[nextTab]);
        }
      }

      tabButtons.forEach((btn) => {
        btn.addEventListener('click', () => {
          setActiveTab(btn.dataset.tab, true);
        });
      });

      let initialTab = pageConfig.activeTab || 'convert';
      if ((pageConfig.basePath || '/') === '/' && initialTab === 'convert') {
        try {
          const rememberedTab = localStorage.getItem('imgconvertcrop:lastTab');
          if (rememberedTab && panels[rememberedTab]) {
            initialTab = rememberedTab;
          }
        } catch (_e) {}
      }
      setActiveTab(initialTab, false);

      document.querySelectorAll('[data-file-target]').forEach((btn) => {
        btn.addEventListener('click', () => {
          const targetId = btn.getAttribute('data-file-target');
          const input = document.getElementById(targetId);
          if (input) input.click();
        });
      });
      document.querySelectorAll('input[type="file"]').forEach((input) => {
        input.addEventListener('change', () => {
          syncFilePickerLabel(input);
        });
      });

      if (pageConfig.convertFormat) {
        document.getElementById('convertFormat').value = pageConfig.convertFormat;
      }
      if (typeof pageConfig.convertQuality === 'number') {
        document.getElementById('convertQuality').value = String(pageConfig.convertQuality);
      }
      if (pageConfig.compressFormat) {
        document.getElementById('compressFormat').value = pageConfig.compressFormat;
      }
      if (typeof pageConfig.compressQuality === 'number') {
        document.getElementById('compressQuality').value = String(pageConfig.compressQuality);
      }
      if (pageConfig.upscaleFormat) {
        document.getElementById('upscaleFormat').value = pageConfig.upscaleFormat;
      }
      if (typeof pageConfig.upscaleQuality === 'number') {
        document.getElementById('upscaleQuality').value = String(pageConfig.upscaleQuality);
      }
      if (typeof pageConfig.upscaleScale === 'number') {
        document.getElementById('upscaleScale').value = String(pageConfig.upscaleScale);
      }
      if (!['2', '4'].includes(document.getElementById('upscaleScale').value)) {
        document.getElementById('upscaleScale').value = '2';
      }

      // Convert tab
      document.getElementById('convertBtn').addEventListener('click', async () => {
        const fileInput = document.getElementById('convertImage');
        const statusEl = document.getElementById('convertStatus');
        if (!fileInput.files || fileInput.files.length === 0) {
          setStatus(statusEl, t('status.chooseImage'), 'error');
          return;
        }

        const file = fileInput.files[0];
        const format = document.getElementById('convertFormat').value;
        const mimeType = `image/${format}`;

        if (!canEncode(mimeType)) {
          setStatus(statusEl, t('error.notSupported', { format: format.toUpperCase() }), 'error');
          return;
        }

        setStatus(statusEl, t('status.converting'));
        try {
          const quality = toQuality(document.getElementById('convertQuality').value, 0.9);
          const img = await fileToImage(file);
          const blob = await renderToBlob(img, mimeType, quality, 0, 0, img.width, img.height, img.width, img.height);
          if (!blob) throw new Error('Failed to convert image.');
          const base = file.name.replace(/\.[^.]+$/, '') || 'image';
          const mode = await downloadBlob(blob, `${base}-converted.${extForFormat(format)}`);
          setStatus(
            statusEl,
            mode === 'ios-preview' ? t('status.previewIos') : t('status.doneDownload'),
            'ok'
          );
        } catch (err) {
          setStatus(statusEl, err.message || t('error.convertFailed'), 'error');
        }
      });

      // Crop tab
      const cropCanvas = document.getElementById('cropCanvas');
      const cropCtx = cropCanvas.getContext('2d');
      const cropStatus = document.getElementById('cropStatus');
      const cropImageInput = document.getElementById('cropImage');
      const cropCanvasWrap = cropCanvas.parentElement;

      const cropState = {
        img: null,
        aspectRatio: null,
        scale: 1,
        offsetX: 0,
        offsetY: 0,
        box: { x: 80, y: 60, w: 240, h: 180 },
        mode: null,
        handle: null,
        startX: 0,
        startY: 0,
        startBox: null
      };

      function parseAspectRatio(raw) {
        if (!raw || raw === 'free') return null;
        const parts = String(raw).split(':');
        if (parts.length !== 2) return null;
        const w = Number(parts[0]);
        const h = Number(parts[1]);
        if (!Number.isFinite(w) || !Number.isFinite(h) || w <= 0 || h <= 0) return null;
        return w / h;
      }

      function buildDefaultBox(img) {
        return {
          x: img.width * 0.1,
          y: img.height * 0.1,
          w: img.width * 0.8,
          h: img.height * 0.8
        };
      }

      function buildRatioBox(img, ratio) {
        const maxW = img.width * 0.9;
        const maxH = img.height * 0.9;
        let w = maxW;
        let h = w / ratio;
        if (h > maxH) {
          h = maxH;
          w = h * ratio;
        }
        return {
          x: (img.width - w) / 2,
          y: (img.height - h) / 2,
          w,
          h
        };
      }

      function applyCropPreset(preset) {
        if (!preset) return;
        const cropAspectRatio = document.getElementById('cropAspectRatio');
        if (!cropAspectRatio) return;
        if (preset === 'square') {
          cropAspectRatio.value = '1:1';
        } else if (preset === '16:9') {
          cropAspectRatio.value = '16:9';
        }
      }

      function setCropAspectRatio(value, fitToRatio = false) {
        cropState.aspectRatio = parseAspectRatio(value);
        if (!cropState.img) return;
        if (fitToRatio && cropState.aspectRatio) {
          cropState.box = buildRatioBox(cropState.img, cropState.aspectRatio);
          clampBoxToImage();
          drawCropCanvas();
        } else if (fitToRatio && !cropState.aspectRatio) {
          cropState.box = buildDefaultBox(cropState.img);
          clampBoxToImage();
          drawCropCanvas();
        }
      }

      function drawCropCanvas() {
        cropCtx.clearRect(0, 0, cropCanvas.width, cropCanvas.height);
        cropCtx.fillStyle = '#dfe9f8';
        cropCtx.fillRect(0, 0, cropCanvas.width, cropCanvas.height);

        if (!cropState.img) {
          cropCtx.fillStyle = '#4f678a';
          cropCtx.font = '16px Segoe UI';
          cropCtx.fillText(t('status.cropCanvasPrompt'), 24, 34);
          return;
        }

        const img = cropState.img;
        const scale = Math.min(cropCanvas.width / img.width, cropCanvas.height / img.height);
        const drawW = img.width * scale;
        const drawH = img.height * scale;
        const ox = (cropCanvas.width - drawW) / 2;
        const oy = (cropCanvas.height - drawH) / 2;

        cropState.scale = scale;
        cropState.offsetX = ox;
        cropState.offsetY = oy;

        cropCtx.drawImage(img, ox, oy, drawW, drawH);

        const b = cropState.box;
        const x = ox + b.x * scale;
        const y = oy + b.y * scale;
        const w = b.w * scale;
        const h = b.h * scale;

        // Shade only the outside area; keep the crop area as the original image.
        cropCtx.fillStyle = 'rgba(80,88,102,0.24)';
        cropCtx.fillRect(ox, oy, drawW, Math.max(0, y - oy)); // top
        cropCtx.fillRect(ox, y + h, drawW, Math.max(0, (oy + drawH) - (y + h))); // bottom
        cropCtx.fillRect(ox, y, Math.max(0, x - ox), h); // left
        cropCtx.fillRect(x + w, y, Math.max(0, (ox + drawW) - (x + w)), h); // right

        cropCtx.strokeStyle = '#0f62fe';
        cropCtx.lineWidth = isCoarsePointer ? 3 : 2;
        cropCtx.strokeRect(x, y, w, h);

        const hs = isCoarsePointer ? 11 : 6;
        const handles = [
          ['nw', x, y],
          ['ne', x + w, y],
          ['sw', x, y + h],
          ['se', x + w, y + h]
        ];
        if (!cropState.aspectRatio) {
          handles.push(['n', x + w / 2, y], ['s', x + w / 2, y + h], ['w', x, y + h / 2], ['e', x + w, y + h / 2]);
        }
        cropCtx.fillStyle = '#ffffff';
        cropCtx.strokeStyle = '#0f62fe';
        handles.forEach(([, hx, hy]) => {
          cropCtx.beginPath();
          cropCtx.rect(hx - hs, hy - hs, hs * 2, hs * 2);
          cropCtx.fill();
          cropCtx.stroke();
        });
      }

      function resizeCropCanvas(force = false) {
        if (!cropCanvasWrap) return false;
        const wrapWidth = Math.round(cropCanvasWrap.clientWidth || 860);
        const targetWidth = Math.max(280, wrapWidth);
        const isMobileViewport = window.matchMedia('(max-width: 760px)').matches;
        let targetHeight;

        if (isMobileViewport) {
          const viewportHeight =
            (window.visualViewport && window.visualViewport.height) ||
            window.innerHeight ||
            document.documentElement.clientHeight ||
            740;
          const preferredHeight = Math.round(viewportHeight * 0.46);
          const maxHeightByWidth = Math.round(targetWidth * 1.18);
          targetHeight = Math.max(260, Math.min(preferredHeight, maxHeightByWidth));
        } else {
          targetHeight = Math.round(targetWidth * (480 / 860));
          targetHeight = Math.max(420, Math.min(targetHeight, 620));
        }

        if (!force && cropCanvas.width === targetWidth && cropCanvas.height === targetHeight) return false;
        cropCanvas.width = targetWidth;
        cropCanvas.height = targetHeight;
        return true;
      }

      function clampBoxToImage() {
        if (!cropState.img) return;
        const img = cropState.img;
        const b = cropState.box;
        const ratio = cropState.aspectRatio;
        if (ratio) {
          let w = Math.max(20, b.w);
          let h = w / ratio;
          if (h < 20) {
            h = 20;
            w = h * ratio;
          }
          if (w > img.width) {
            w = img.width;
            h = w / ratio;
          }
          if (h > img.height) {
            h = img.height;
            w = h * ratio;
          }
          b.w = w;
          b.h = h;
        } else {
          b.w = Math.max(20, Math.min(b.w, img.width));
          b.h = Math.max(20, Math.min(b.h, img.height));
        }
        b.x = Math.max(0, Math.min(b.x, img.width - b.w));
        b.y = Math.max(0, Math.min(b.y, img.height - b.h));
      }

      function getPointer(e) {
        const rect = cropCanvas.getBoundingClientRect();
        const touch = e.touches && e.touches[0];
        const clientX = touch ? touch.clientX : e.clientX;
        const clientY = touch ? touch.clientY : e.clientY;

        // Canvas is often visually scaled down on mobile; convert CSS coords to canvas coords.
        const cssX = clientX - rect.left;
        const cssY = clientY - rect.top;
        const scaleX = rect.width > 0 ? cropCanvas.width / rect.width : 1;
        const scaleY = rect.height > 0 ? cropCanvas.height / rect.height : 1;
        return {
          x: cssX * scaleX,
          y: cssY * scaleY
        };
      }

      function canvasToImagePoint(point) {
        const img = cropState.img;
        if (!img) return { x: 0, y: 0 };
        const x = (point.x - cropState.offsetX) / cropState.scale;
        const y = (point.y - cropState.offsetY) / cropState.scale;
        return {
          x: Math.max(0, Math.min(img.width, x)),
          y: Math.max(0, Math.min(img.height, y))
        };
      }

      function hitTestHandle(px, py) {
        const b = cropState.box;
        const s = cropState.scale;
        const ox = cropState.offsetX;
        const oy = cropState.offsetY;
        const x = ox + b.x * s;
        const y = oy + b.y * s;
        const w = b.w * s;
        const h = b.h * s;
        const tol = isCoarsePointer ? 32 : 10;

        const points = {
          nw: { x, y },
          ne: { x: x + w, y },
          sw: { x, y: y + h },
          se: { x: x + w, y: y + h }
        };
        if (!cropState.aspectRatio) {
          points.n = { x: x + w / 2, y };
          points.s = { x: x + w / 2, y: y + h };
          points.w = { x, y: y + h / 2 };
          points.e = { x: x + w, y: y + h / 2 };
        }

        for (const [name, p] of Object.entries(points)) {
          if (Math.abs(px - p.x) <= tol && Math.abs(py - p.y) <= tol) return name;
        }

        if (px >= x && px <= x + w && py >= y && py <= y + h) return 'move';
        return null;
      }

      function onCropDown(e) {
        if (!cropState.img) return;
        e.preventDefault();
        const p = getPointer(e);
        const hit = hitTestHandle(p.x, p.y);
        if (!hit) {
          const ip = canvasToImagePoint(p);
          cropState.mode = 'new';
          cropState.handle = 'se';
          cropState.startX = p.x;
          cropState.startY = p.y;
          cropState.startBox = { ...cropState.box, startImgX: ip.x, startImgY: ip.y };
          cropState.box = { x: ip.x, y: ip.y, w: 20, h: 20 };
          clampBoxToImage();
          drawCropCanvas();
          return;
        }
        cropState.mode = hit === 'move' ? 'move' : 'resize';
        cropState.handle = hit;
        cropState.startX = p.x;
        cropState.startY = p.y;
        cropState.startBox = { ...cropState.box };
      }

      function onCropMove(e) {
        if (!cropState.img || !cropState.mode) return;
        e.preventDefault();
        const p = getPointer(e);
        const dx = (p.x - cropState.startX) / cropState.scale;
        const dy = (p.y - cropState.startY) / cropState.scale;
        const b = cropState.box;
        const s = cropState.startBox;

        if (cropState.mode === 'new') {
          const sp = {
            x: s.startImgX,
            y: s.startImgY
          };
          const ep = canvasToImagePoint(p);
          const ratio = cropState.aspectRatio;
          if (!ratio) {
            b.x = Math.min(sp.x, ep.x);
            b.y = Math.min(sp.y, ep.y);
            b.w = Math.max(20, Math.abs(ep.x - sp.x));
            b.h = Math.max(20, Math.abs(ep.y - sp.y));
          } else {
            const rawW = Math.abs(ep.x - sp.x);
            const rawH = Math.abs(ep.y - sp.y);
            const targetW = Math.max(20, Math.max(rawW, rawH * ratio));
            const targetH = targetW / ratio;
            b.w = targetW;
            b.h = targetH;
            b.x = ep.x >= sp.x ? sp.x : sp.x - targetW;
            b.y = ep.y >= sp.y ? sp.y : sp.y - targetH;
          }
        } else if (cropState.mode === 'move') {
          b.x = s.x + dx;
          b.y = s.y + dy;
        } else {
          const ratio = cropState.aspectRatio;
          if (!ratio) {
            const min = 20;
            if (cropState.handle.includes('n')) {
              b.y = s.y + dy;
              b.h = s.h - dy;
            }
            if (cropState.handle.includes('s')) {
              b.h = s.h + dy;
            }
            if (cropState.handle.includes('w')) {
              b.x = s.x + dx;
              b.w = s.w - dx;
            }
            if (cropState.handle.includes('e')) {
              b.w = s.w + dx;
            }

            if (b.w < min) {
              b.w = min;
              if (cropState.handle.includes('w')) b.x = s.x + (s.w - min);
            }
            if (b.h < min) {
              b.h = min;
              if (cropState.handle.includes('n')) b.y = s.y + (s.h - min);
            }
          } else {
            const horizontalDelta = cropState.handle.includes('e') ? dx : -dx;
            const verticalDelta = cropState.handle.includes('s') ? dy : -dy;
            const useHorizontal = Math.abs(horizontalDelta) >= Math.abs(verticalDelta * ratio);
            const nextW = useHorizontal ? s.w + horizontalDelta : s.w + verticalDelta * ratio;
            const targetW = Math.max(20, nextW);
            const targetH = targetW / ratio;

            b.w = targetW;
            b.h = targetH;
            b.x = cropState.handle.includes('w') ? s.x + (s.w - targetW) : s.x;
            b.y = cropState.handle.includes('n') ? s.y + (s.h - targetH) : s.y;
          }
        }

        clampBoxToImage();
        drawCropCanvas();
      }

      function onCropUp() {
        cropState.mode = null;
        cropState.handle = null;
      }

      cropCanvas.addEventListener('mousedown', onCropDown);
      window.addEventListener('mousemove', onCropMove);
      window.addEventListener('mouseup', onCropUp);

      cropCanvas.addEventListener('touchstart', onCropDown, { passive: false });
      window.addEventListener('touchmove', onCropMove, { passive: false });
      window.addEventListener('touchend', onCropUp, { passive: false });
      window.addEventListener('resize', () => {
        if (resizeCropCanvas()) drawCropCanvas();
      });
      window.addEventListener('orientationchange', () => {
        if (resizeCropCanvas()) drawCropCanvas();
      });
      if (window.visualViewport) {
        window.visualViewport.addEventListener('resize', () => {
          if (resizeCropCanvas()) drawCropCanvas();
        });
      }

      const cropAspectRatio = document.getElementById('cropAspectRatio');
      cropAspectRatio.addEventListener('change', () => {
        setCropAspectRatio(cropAspectRatio.value, true);
      });
      applyCropPreset(pageConfig.cropPreset);
      setCropAspectRatio(cropAspectRatio.value, false);

      cropImageInput.addEventListener('change', async () => {
        if (!cropImageInput.files || cropImageInput.files.length === 0) return;
        try {
          const img = await fileToImage(cropImageInput.files[0]);
          cropState.img = img;
          cropState.box = cropState.aspectRatio ? buildRatioBox(img, cropState.aspectRatio) : buildDefaultBox(img);
          clampBoxToImage();
          drawCropCanvas();
          setStatus(cropStatus, t('status.imageLoaded'), 'ok');
        } catch {
          setStatus(cropStatus, t('status.loadFailed'), 'error');
        }
      });

      document.getElementById('resetCropBtn').addEventListener('click', () => {
        if (!cropState.img) return;
        const img = cropState.img;
        cropState.box = cropState.aspectRatio ? buildRatioBox(img, cropState.aspectRatio) : buildDefaultBox(img);
        clampBoxToImage();
        drawCropCanvas();
        setStatus(cropStatus, t('status.cropReset'), 'ok');
      });

      const enableCropResize = document.getElementById('enableCropResize');
      const cropResizeWidthWrap = document.getElementById('cropResizeWidthWrap');
      const cropResizeHeightWrap = document.getElementById('cropResizeHeightWrap');
      enableCropResize.addEventListener('change', () => {
        const show = enableCropResize.checked;
        cropResizeWidthWrap.classList.toggle('hidden', !show);
        cropResizeHeightWrap.classList.toggle('hidden', !show);
      });
      if (pageConfig.enableCropResize) {
        enableCropResize.checked = true;
        cropResizeWidthWrap.classList.remove('hidden');
        cropResizeHeightWrap.classList.remove('hidden');
      }

      document.getElementById('confirmCropBtn').addEventListener('click', async () => {
        if (!cropState.img || !cropImageInput.files || cropImageInput.files.length === 0) {
          setStatus(cropStatus, t('status.uploadFirst'), 'error');
          return;
        }

        const format = document.getElementById('cropFormat').value;
        const mimeType = `image/${format}`;
        if (!canEncode(mimeType)) {
          setStatus(cropStatus, t('error.notSupported', { format: format.toUpperCase() }), 'error');
          return;
        }

        try {
          setStatus(cropStatus, t('status.cropProcessing'));
          const img = cropState.img;
          const b = cropState.box;
          let outW = Math.max(1, Math.round(b.w));
          let outH = Math.max(1, Math.round(b.h));

          if (enableCropResize.checked) {
            const rw = Number(document.getElementById('cropResizeWidth').value);
            const rh = Number(document.getElementById('cropResizeHeight').value);
            const hasW = Number.isFinite(rw) && rw > 0;
            const hasH = Number.isFinite(rh) && rh > 0;
            if (!hasW && !hasH) {
              throw new Error(t('error.resizeParams'));
            }
            const ratio = Math.min(hasW ? rw / outW : Infinity, hasH ? rh / outH : Infinity, 1);
            outW = Math.max(1, Math.round(outW * ratio));
            outH = Math.max(1, Math.round(outH * ratio));
          }

          const quality = toQuality(document.getElementById('cropQuality').value, 0.9);
          const blob = await renderToBlob(
            img,
            mimeType,
            quality,
            Math.round(b.x),
            Math.round(b.y),
            Math.round(b.w),
            Math.round(b.h),
            outW,
            outH
          );

          if (!blob) throw new Error('Crop failed.');
          const file = cropImageInput.files[0];
          const base = file.name.replace(/\.[^.]+$/, '') || 'image';
          const mode = await downloadBlob(blob, `${base}-crop.${extForFormat(format)}`);
          setStatus(
            cropStatus,
            mode === 'ios-preview' ? t('status.previewIos') : t('status.cropDone'),
            'ok'
          );
        } catch (err) {
          setStatus(cropStatus, err.message || t('error.cropFailed'), 'error');
        }
      });

      resizeCropCanvas(true);
      drawCropCanvas();

      // Compress tab
      document.getElementById('compressBtn').addEventListener('click', async () => {
        const fileInput = document.getElementById('compressImage');
        const statusEl = document.getElementById('compressStatus');
        if (!fileInput.files || fileInput.files.length === 0) {
          setStatus(statusEl, t('status.chooseImage'), 'error');
          return;
        }

        const file = fileInput.files[0];
        const format = document.getElementById('compressFormat').value;
        const mimeType = `image/${format}`;
        if (!canEncode(mimeType)) {
          setStatus(statusEl, t('error.notSupported', { format: format.toUpperCase() }), 'error');
          return;
        }

        setStatus(statusEl, t('status.compressing'));
        try {
          const img = await fileToImage(file);
          const quality = toQuality(document.getElementById('compressQuality').value, 0.7);
          const blob = await renderToBlob(img, mimeType, quality, 0, 0, img.width, img.height, img.width, img.height);
          if (!blob) throw new Error('Compress failed.');
          const base = file.name.replace(/\.[^.]+$/, '') || 'image';
          const mode = await downloadBlob(blob, `${base}-compressed.${extForFormat(format)}`);
          setStatus(
            statusEl,
            mode === 'ios-preview' ? t('status.previewIos') : t('status.compressDone'),
            'ok'
          );
        } catch (err) {
          setStatus(statusEl, err.message || t('error.compressFailed'), 'error');
        }
      });

      function setProgress(value, labelKey, vars) {
        const progressEl = document.getElementById('upscaleProgress');
        const labelEl = document.getElementById('upscaleProgressLabel');
        progressEl.value = Math.max(0, Math.min(100, Math.round(value)));
        labelEl.textContent = t(labelKey, vars);
      }

      function setUpscaleBusy(isBusy) {
        const wrap = document.getElementById('upscaleProgressWrap');
        if (!wrap) return;
        wrap.classList.toggle('is-busy', Boolean(isBusy));
      }

      let aiUpscaler = null;
      async function getAiUpscaler() {
        if (aiUpscaler) return aiUpscaler;
        if (!window.Upscaler || !window.ESRGANThick2x || !window.tf) {
          throw new Error('AI runtime failed to load.');
        }
        setProgress(8, 'status.aiInit');
        aiUpscaler = new window.Upscaler({
          model: window.ESRGANThick2x
        });
        setProgress(20, 'status.aiModelLoad');
        await aiUpscaler.ready;
        return aiUpscaler;
      }

      let upscaleConfirmResolver = null;
      function askUpscaleConfirm() {
        const box = document.getElementById('upscaleConfirmBox');
        const actionRow = document.getElementById('upscaleActionRow');
        const yesBtn = document.getElementById('upscaleConfirmYes');
        const noBtn = document.getElementById('upscaleConfirmNo');
        actionRow.classList.add('hidden');
        box.classList.remove('hidden');
        return new Promise((resolve) => {
          upscaleConfirmResolver = resolve;
          const resolveOnce = (value) => {
            if (!upscaleConfirmResolver) return;
            upscaleConfirmResolver = null;
            box.classList.add('hidden');
            actionRow.classList.remove('hidden');
            resolve(value);
          };
          yesBtn.onclick = () => resolveOnce(true);
          noBtn.onclick = () => resolveOnce(false);
        });
      }

      // Upscale tab
      document.getElementById('upscaleBtn').addEventListener('click', async () => {
        const fileInput = document.getElementById('upscaleImage');
        const statusEl = document.getElementById('upscaleStatus');
        const btn = document.getElementById('upscaleBtn');
        const actionRow = document.getElementById('upscaleActionRow');
        const confirmed = await askUpscaleConfirm();
        if (!confirmed) {
          setStatus(statusEl, t('status.cancelled'), 'error');
          return;
        }
        if (!fileInput.files || fileInput.files.length === 0) {
          setStatus(statusEl, t('status.chooseImage'), 'error');
          return;
        }

        const file = fileInput.files[0];
        const format = document.getElementById('upscaleFormat').value;
        const mimeType = `image/${format}`;
        if (!canEncode(mimeType)) {
          setStatus(statusEl, t('error.notSupported', { format: format.toUpperCase() }), 'error');
          return;
        }

        const scale = Number(document.getElementById('upscaleScale').value) || 2;
        const restoreMode = document.getElementById('upscaleRestoreMode').value || 'balanced';
        const targetOutputPixels = 24000000;
        const maxInputPixels = Math.floor(targetOutputPixels / (scale * scale));
        actionRow.classList.add('hidden');
        btn.disabled = true;
        setUpscaleBusy(true);
        setStatus(statusEl, '');
        setProgress(2, 'status.aiInit');
        try {
          const imgProbe = await fileToImage(file);
          if (imgProbe.width * imgProbe.height > maxInputPixels) {
            const maxMp = (maxInputPixels / 1000000).toFixed(1);
            throw new Error(t('error.upscaleTooLarge', { maxMp }));
          }

          const upscaler = await getAiUpscaler();
          const quality = toQuality(document.getElementById('upscaleQuality').value, 1);
          const passes = scale >= 4 ? 2 : 1;
          const isCoarseDevice = window.matchMedia('(pointer: coarse), (max-width: 760px)').matches;
          const aiPatchSize = isCoarseDevice ? 64 : 128;
          const aiPadding = aiPatchSize <= 64 ? 4 : 2;

          setProgress(15, 'status.aiPreprocess');
          const prepared = await preprocessForRestore(imgProbe, restoreMode, (p) => {
            const mapped = 15 + 10 * Math.max(0, Math.min(1, p));
            setProgress(mapped, 'status.aiPreprocess');
          });
          let currentImage = await canvasToImage(prepared);
          for (let i = 0; i < passes; i += 1) {
            await yieldToBrowser();
            const passNo = i + 1;
            const start = passes === 1 ? 25 : i === 0 ? 20 : 58;
            const end = passes === 1 ? 88 : i === 0 ? 54 : 90;
            const upscaledBase64 = await upscaler.upscale(currentImage, {
              output: 'base64',
              patchSize: aiPatchSize,
              padding: aiPadding,
              progress: (percent) => {
                const mapped = start + (end - start) * Math.max(0, Math.min(1, percent));
                setProgress(mapped, 'status.aiEnhancingPass', { pass: String(passNo), total: String(passes) });
              }
            });
            currentImage = await base64ToImage(upscaledBase64);
            await yieldToBrowser();
          }

          setProgress(92, 'status.aiPostprocess');
          const finalCanvas = await postprocessAfterRestore(currentImage, restoreMode, (p) => {
            const mapped = 92 + 3 * Math.max(0, Math.min(1, p));
            setProgress(mapped, 'status.aiPostprocess');
          });

          setProgress(95, 'status.aiFinalizing');
          const blob = await renderToBlob(
            finalCanvas,
            mimeType,
            quality,
            0,
            0,
            finalCanvas.width,
            finalCanvas.height,
            finalCanvas.width,
            finalCanvas.height
          );
          if (!blob) throw new Error('Upscale failed.');
          const base = file.name.replace(/\.[^.]+$/, '') || 'image';
          const mode = await downloadBlob(blob, `${base}-${finalCanvas.width}x${finalCanvas.height}.${extForFormat(format)}`);
          setProgress(100, 'status.upscaleDone');
          setStatus(
            statusEl,
            mode === 'ios-preview' ? t('status.previewIos') : t('status.upscaleDone'),
            'ok'
          );
        } catch (err) {
          setStatus(statusEl, err.message || t('error.upscaleFailed'), 'error');
          setProgress(0, 'upscale.progressIdle');
        } finally {
          btn.disabled = false;
          actionRow.classList.remove('hidden');
          setUpscaleBusy(false);
        }
      });

      // Remove tab
      const removeCanvas = document.getElementById('removeCanvas');
      const removeWorkspace = document.getElementById('removeWorkspace');
      const removeStage = document.getElementById('removeStage');
      const removeBusyOverlay = document.getElementById('removeBusyOverlay');
      const removeEmptyState = document.getElementById('removeEmptyState');
      const removeCtx = removeCanvas.getContext('2d');
      const removeStatus = document.getElementById('removeStatus');
      const removeImageInput = document.getElementById('removeImage');
      const removeBrushSize = document.getElementById('removeBrushSize');
      const removeBrushDownBtn = document.getElementById('removeBrushDownBtn');
      const removeBrushUpBtn = document.getElementById('removeBrushUpBtn');
      const removeBrushSizeValue = document.getElementById('removeBrushSizeValue');
      const removeAlgorithmInputs = Array.from(document.querySelectorAll('input[name="removeAlgorithm"]'));
      const removeDownloadBtn = document.getElementById('removeDownloadBtn');
      const removeUndoBtn = document.getElementById('removeUndoBtn');
      const removeZoomInBtn = document.getElementById('removeZoomInBtn');
      const removeZoomOutBtn = document.getElementById('removeZoomOutBtn');
      const removeZoomResetBtn = document.getElementById('removeZoomResetBtn');
      const removeZoomLabel = document.getElementById('removeZoomLabel');

      const removeState = {
        file: null,
        sourceCanvas: null,
        maskCanvas: document.createElement('canvas'),
        overlayCanvas: document.createElement('canvas'),
        fitZoom: 1,
        zoomLevel: 1,
        drawing: false,
        lastPoint: null,
        hasMask: false,
        running: false,
        resultBlob: null,
        historyStack: [],
        touchGesture: {
          active: false,
          startDistance: 0,
          startZoomLevel: 1,
          startActualZoom: 1,
          startScrollLeft: 0,
          startScrollTop: 0,
          startMidX: 0,
          startMidY: 0
        },
        hasUnsavedProgress: false
      };
      const removeMaskCtx = removeState.maskCanvas.getContext('2d');
      const removeOverlayCtx = removeState.overlayCanvas.getContext('2d');

      function setRemoveBusy(isBusy) {
        removeBusyOverlay.classList.toggle('is-busy', Boolean(isBusy));
      }

      function copyCanvas(canvas) {
        const c = document.createElement('canvas');
        c.width = canvas.width;
        c.height = canvas.height;
        c.getContext('2d').drawImage(canvas, 0, 0);
        return c;
      }

      function refreshRemoveUndoState() {
        removeUndoBtn.disabled = removeState.historyStack.length === 0 || removeState.running;
      }

      function syncRemoveBrushInputs(value) {
        const n = Math.max(4, Math.min(120, Math.round(Number(value) || 28)));
        removeBrushSize.value = String(n);
        removeBrushSizeValue.textContent = `${n} px`;
        return n;
      }

      function setRemoveUnsavedProgress(value) {
        removeState.hasUnsavedProgress = Boolean(value);
      }

      function getSelectedRemoveAlgorithm() {
        const picked = removeAlgorithmInputs.find((input) => input.checked);
        return picked ? picked.value : 'ai';
      }

      function computeRemoveFitZoom() {
        if (!removeState.sourceCanvas || !removeWorkspace) return 1;
        const bounds = removeWorkspace.getBoundingClientRect();
        const maxW = Math.max(140, (bounds.width || removeWorkspace.clientWidth || removeCanvas.width) - 18);
        const maxH = Math.max(140, (removeWorkspace.clientHeight || 520) - 18);
        const zoomByWidth = maxW / removeCanvas.width;
        const zoomByHeight = maxH / removeCanvas.height;
        return Math.max(0.08, Math.min(1, zoomByWidth, zoomByHeight));
      }

      function applyRemoveCanvasScale() {
        const zoom = Math.max(0.08, removeState.fitZoom * removeState.zoomLevel);
        removeCanvas.style.width = `${Math.max(1, Math.round(removeCanvas.width * zoom))}px`;
        removeCanvas.style.height = `${Math.max(1, Math.round(removeCanvas.height * zoom))}px`;
        removeZoomLabel.textContent = `${Math.round(zoom * 100)}%`;
      }

      function updateRemoveWorkspaceSize() {
        if (!removeWorkspace) return;
        const viewportHeight =
          (window.visualViewport && window.visualViewport.height) ||
          window.innerHeight ||
          document.documentElement.clientHeight ||
          800;
        const workspaceTop = removeWorkspace.getBoundingClientRect().top || 0;
        const isMobileViewport = window.matchMedia('(max-width: 760px)').matches;
        const reservedBottom = isMobileViewport ? 190 : 230;
        const availableByTop = Math.max(220, Math.floor(viewportHeight - workspaceTop - reservedBottom));
        const preferredByViewport = Math.floor(viewportHeight * (isMobileViewport ? 0.52 : 0.58));
        const minHeight = isMobileViewport ? 250 : 320;
        const maxHeight = Math.floor(viewportHeight * (isMobileViewport ? 0.68 : 0.74));
        const targetHeight = Math.max(minHeight, Math.min(Math.max(preferredByViewport, availableByTop), maxHeight));
        removeWorkspace.style.height = `${targetHeight}px`;
      }

      function refreshRemoveViewportLayout() {
        updateRemoveWorkspaceSize();
        if (removeState.sourceCanvas) {
          removeState.fitZoom = computeRemoveFitZoom();
          applyRemoveCanvasScale();
        }
        if (removeStage) {
          // Keep small images centered while allowing scroll for large zoom levels.
          removeStage.style.minHeight = '100%';
          removeStage.style.minWidth = '100%';
        }
      }

      function setRemoveZoomLevel(nextLevel) {
        const level = Math.max(0.5, Math.min(6, Number(nextLevel) || 1));
        removeState.zoomLevel = level;
        applyRemoveCanvasScale();
      }

      function getTouchDistance(t0, t1) {
        const dx = t1.clientX - t0.clientX;
        const dy = t1.clientY - t0.clientY;
        return Math.hypot(dx, dy);
      }

      function getTouchMidpoint(t0, t1) {
        return {
          x: (t0.clientX + t1.clientX) / 2,
          y: (t0.clientY + t1.clientY) / 2
        };
      }

      function startTouchGesture(e) {
        if (!removeState.sourceCanvas || removeState.running) return;
        if (!e.touches || e.touches.length !== 2) return;
        const t0 = e.touches[0];
        const t1 = e.touches[1];
        const distance = getTouchDistance(t0, t1);
        if (!Number.isFinite(distance) || distance <= 0) return;
        const mid = getTouchMidpoint(t0, t1);
        removeState.touchGesture.active = true;
        removeState.touchGesture.startDistance = distance;
        removeState.touchGesture.startZoomLevel = removeState.zoomLevel;
        removeState.touchGesture.startActualZoom = Math.max(0.08, removeState.fitZoom * removeState.zoomLevel);
        removeState.touchGesture.startScrollLeft = removeWorkspace.scrollLeft;
        removeState.touchGesture.startScrollTop = removeWorkspace.scrollTop;
        removeState.touchGesture.startMidX = mid.x;
        removeState.touchGesture.startMidY = mid.y;
      }

      function updateTouchGesture(e) {
        if (!removeState.touchGesture.active) return;
        if (!e.touches || e.touches.length !== 2) return;
        const t0 = e.touches[0];
        const t1 = e.touches[1];
        const currentDistance = getTouchDistance(t0, t1);
        if (!Number.isFinite(currentDistance) || currentDistance <= 0) return;
        const currentMid = getTouchMidpoint(t0, t1);
        const rect = removeWorkspace.getBoundingClientRect();
        const startActualZoom = removeState.touchGesture.startActualZoom;
        if (!Number.isFinite(startActualZoom) || startActualZoom <= 0) return;

        const scaleFactor = currentDistance / removeState.touchGesture.startDistance;
        const nextZoomLevel = removeState.touchGesture.startZoomLevel * scaleFactor;
        setRemoveZoomLevel(nextZoomLevel);
        const nextActualZoom = Math.max(0.08, removeState.fitZoom * removeState.zoomLevel);

        const startLocalX = removeState.touchGesture.startMidX - rect.left;
        const startLocalY = removeState.touchGesture.startMidY - rect.top;
        const currentLocalX = currentMid.x - rect.left;
        const currentLocalY = currentMid.y - rect.top;

        const worldX = (removeState.touchGesture.startScrollLeft + startLocalX) / startActualZoom;
        const worldY = (removeState.touchGesture.startScrollTop + startLocalY) / startActualZoom;
        removeWorkspace.scrollLeft = Math.max(0, worldX * nextActualZoom - currentLocalX);
        removeWorkspace.scrollTop = Math.max(0, worldY * nextActualZoom - currentLocalY);
      }

      function endTouchGesture() {
        removeState.touchGesture.active = false;
      }

      function resetRemoveOutputState() {
        removeState.resultBlob = null;
        removeDownloadBtn.disabled = true;
      }

      function drawRemoveCanvas() {
        removeCtx.clearRect(0, 0, removeCanvas.width, removeCanvas.height);
        removeCtx.fillStyle = '#dfe9f8';
        removeCtx.fillRect(0, 0, removeCanvas.width, removeCanvas.height);

        if (!removeState.sourceCanvas) {
          removeEmptyState.classList.remove('hidden');
          return;
        }
        removeEmptyState.classList.add('hidden');

        removeCtx.drawImage(removeState.sourceCanvas, 0, 0);

        // Build tinted overlay in an offscreen canvas, then draw it on top of image.
        removeOverlayCtx.clearRect(0, 0, removeState.overlayCanvas.width, removeState.overlayCanvas.height);
        removeOverlayCtx.globalAlpha = 1;
        removeOverlayCtx.globalCompositeOperation = 'source-over';
        removeOverlayCtx.fillStyle = '#ff2f55';
        removeOverlayCtx.fillRect(0, 0, removeState.overlayCanvas.width, removeState.overlayCanvas.height);
        removeOverlayCtx.globalCompositeOperation = 'destination-in';
        removeOverlayCtx.drawImage(removeState.maskCanvas, 0, 0);
        removeOverlayCtx.globalCompositeOperation = 'source-over';

        removeCtx.save();
        removeCtx.globalAlpha = 0.34;
        removeCtx.drawImage(removeState.overlayCanvas, 0, 0);
        removeCtx.restore();
      }

      function getRemovePointer(e) {
        const rect = removeCanvas.getBoundingClientRect();
        const touch = e.touches && e.touches[0];
        const clientX = touch ? touch.clientX : e.clientX;
        const clientY = touch ? touch.clientY : e.clientY;
        const cssX = clientX - rect.left;
        const cssY = clientY - rect.top;
        const scaleX = rect.width > 0 ? removeCanvas.width / rect.width : 1;
        const scaleY = rect.height > 0 ? removeCanvas.height / rect.height : 1;
        return {
          x: Math.max(0, Math.min(removeCanvas.width - 1, cssX * scaleX)),
          y: Math.max(0, Math.min(removeCanvas.height - 1, cssY * scaleY))
        };
      }

      function paintMaskDot(point, radius) {
        removeMaskCtx.fillStyle = '#ffffff';
        removeMaskCtx.beginPath();
        removeMaskCtx.arc(point.x, point.y, radius, 0, Math.PI * 2);
        removeMaskCtx.fill();
      }

      function paintMaskSegment(a, b, radius) {
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        const dist = Math.hypot(dx, dy);
        const step = Math.max(1, radius * 0.45);
        const count = Math.max(1, Math.ceil(dist / step));
        for (let i = 0; i <= count; i += 1) {
          const tVal = i / count;
          paintMaskDot(
            { x: a.x + dx * tVal, y: a.y + dy * tVal },
            radius
          );
        }
      }

      function dilateMaskData(maskData, width, height, radius) {
        if (!radius || radius <= 0) return maskData;
        const out = new Uint8Array(maskData.length);
        const r = Math.max(1, Math.round(radius));
        for (let y = 0; y < height; y += 1) {
          for (let x = 0; x < width; x += 1) {
            const idx = y * width + x;
            if (!maskData[idx]) continue;
            for (let ny = Math.max(0, y - r); ny <= Math.min(height - 1, y + r); ny += 1) {
              for (let nx = Math.max(0, x - r); nx <= Math.min(width - 1, x + r); nx += 1) {
                const dx = nx - x;
                const dy = ny - y;
                if (dx * dx + dy * dy > r * r) continue;
                out[ny * width + nx] = 1;
              }
            }
          }
        }
        return out;
      }

      function blurRegionFromSource(src, width, height, minX, minY, maxX, maxY) {
        const regionW = maxX - minX + 1;
        const regionH = maxY - minY + 1;
        const size = regionW * regionH;
        const blurR = new Float32Array(size);
        const blurG = new Float32Array(size);
        const blurB = new Float32Array(size);
        const kernel = [1, 2, 1, 2, 4, 2, 1, 2, 1];

        for (let y = minY; y <= maxY; y += 1) {
          for (let x = minX; x <= maxX; x += 1) {
            let rs = 0;
            let gs = 0;
            let bs = 0;
            let ws = 0;
            let k = 0;
            for (let ny = Math.max(0, y - 1); ny <= Math.min(height - 1, y + 1); ny += 1) {
              for (let nx = Math.max(0, x - 1); nx <= Math.min(width - 1, x + 1); nx += 1) {
                const w = kernel[k++];
                const base = (ny * width + nx) * 4;
                rs += src[base] * w;
                gs += src[base + 1] * w;
                bs += src[base + 2] * w;
                ws += w;
              }
            }
            const li = (y - minY) * regionW + (x - minX);
            blurR[li] = rs / ws;
            blurG[li] = gs / ws;
            blurB[li] = bs / ws;
          }
        }
        return { blurR, blurG, blurB, regionW, regionH };
      }

      function buildNearestBoundaryMap(workMask, width, height, minX, minY, maxX, maxY) {
        const regionW = maxX - minX + 1;
        const regionH = maxY - minY + 1;
        const regionSize = regionW * regionH;
        const nearest = new Int32Array(regionSize);
        nearest.fill(-1);
        const dist = new Int16Array(regionSize);
        dist.fill(-1);
        const qX = new Int32Array(regionSize);
        const qY = new Int32Array(regionSize);
        let head = 0;
        let tail = 0;

        for (let y = minY; y <= maxY; y += 1) {
          for (let x = minX; x <= maxX; x += 1) {
            const idx = y * width + x;
            if (workMask[idx]) continue;
            const li = (y - minY) * regionW + (x - minX);
            nearest[li] = li;
            dist[li] = 0;
            qX[tail] = x;
            qY[tail] = y;
            tail += 1;
          }
        }

        while (head < tail) {
          const x = qX[head];
          const y = qY[head];
          head += 1;
          const li = (y - minY) * regionW + (x - minX);
          const sourceLi = nearest[li];
          const neighbors = [
            [x - 1, y],
            [x + 1, y],
            [x, y - 1],
            [x, y + 1]
          ];
          for (const [nx, ny] of neighbors) {
            if (nx < minX || nx > maxX || ny < minY || ny > maxY) continue;
            const nLi = (ny - minY) * regionW + (nx - minX);
            if (nearest[nLi] !== -1) continue;
            nearest[nLi] = sourceLi;
            dist[nLi] = dist[li] + 1;
            qX[tail] = nx;
            qY[tail] = ny;
            tail += 1;
          }
        }

        return { nearest, dist, regionW, regionH };
      }

      function buildSeamMask(workMask, maskData, width, height, minX, minY, maxX, maxY) {
        const seam = new Uint8Array(workMask.length);
        for (let y = minY; y <= maxY; y += 1) {
          for (let x = minX; x <= maxX; x += 1) {
            const idx = y * width + x;
            if (!workMask[idx]) continue;
            if (!maskData[idx]) {
              seam[idx] = 1;
              continue;
            }
            const neighbors = [
              [x - 1, y],
              [x + 1, y],
              [x, y - 1],
              [x, y + 1]
            ];
            for (const [nx, ny] of neighbors) {
              if (nx < 0 || nx >= width || ny < 0 || ny >= height) continue;
              const nIdx = ny * width + nx;
              if (!workMask[nIdx]) {
                seam[idx] = 1;
                break;
              }
            }
          }
        }
        return seam;
      }

      async function applyTextureTransfer(out, src, workMask, width, height, minX, minY, maxX, maxY, detailGain = 0.8) {
        const { blurR, blurG, blurB, regionW, regionH } = blurRegionFromSource(src, width, height, minX, minY, maxX, maxY);
        const { nearest, dist } = buildNearestBoundaryMap(workMask, width, height, minX, minY, maxX, maxY);

        for (let y = minY; y <= maxY; y += 1) {
          for (let x = minX; x <= maxX; x += 1) {
            const idx = y * width + x;
            if (!workMask[idx]) continue;
            const li = (y - minY) * regionW + (x - minX);
            const nearestLi = nearest[li];
            if (nearestLi < 0) continue;
            const nearestX = (nearestLi % regionW) + minX;
            const nearestY = Math.floor(nearestLi / regionW) + minY;
            const nearestBase = (nearestY * width + nearestX) * 4;
            const detailR = src[nearestBase] - blurR[nearestLi];
            const detailG = src[nearestBase + 1] - blurG[nearestLi];
            const detailB = src[nearestBase + 2] - blurB[nearestLi];

            const d = Math.max(0, dist[li]);
            const adaptiveGain = detailGain * (0.95 - Math.min(0.35, d * 0.025));
            const base = idx * 4;
            out[base] = Math.max(0, Math.min(255, Math.round(out[base] + detailR * adaptiveGain)));
            out[base + 1] = Math.max(0, Math.min(255, Math.round(out[base + 1] + detailG * adaptiveGain)));
            out[base + 2] = Math.max(0, Math.min(255, Math.round(out[base + 2] + detailB * adaptiveGain)));
          }
          if (y % 24 === 0) await yieldToBrowser();
        }
      }

      async function applyAIGenerativeFill(out, src, maskData, workMask, width, height, minX, minY, maxX, maxY, strength = 0.88) {
        const { nearest, dist, regionW } = buildNearestBoundaryMap(workMask, width, height, minX, minY, maxX, maxY);

        const boundaryPool = [];
        let lumSum = 0;
        let lumSqSum = 0;
        for (let y = minY; y <= maxY; y += 1) {
          for (let x = minX; x <= maxX; x += 1) {
            const idx = y * width + x;
            if (workMask[idx]) continue;
            const neighbors = [
              [x - 1, y],
              [x + 1, y],
              [x, y - 1],
              [x, y + 1]
            ];
            let touchesMask = false;
            for (const [nx, ny] of neighbors) {
              if (nx < 0 || nx >= width || ny < 0 || ny >= height) continue;
              if (workMask[ny * width + nx]) {
                touchesMask = true;
                break;
              }
            }
            if (!touchesMask) continue;
            boundaryPool.push([x, y]);
            const b = idx * 4;
            const lum = src[b] * 0.299 + src[b + 1] * 0.587 + src[b + 2] * 0.114;
            lumSum += lum;
            lumSqSum += lum * lum;
          }
        }

        const count = Math.max(1, boundaryPool.length);
        const lumMean = lumSum / count;
        const lumVar = Math.max(0, lumSqSum / count - lumMean * lumMean);
        const noiseScale = Math.min(10, Math.sqrt(lumVar) * 0.18);

        let centerX = 0;
        let centerY = 0;
        let centerCount = 0;
        for (let y = minY; y <= maxY; y += 1) {
          for (let x = minX; x <= maxX; x += 1) {
            const idx = y * width + x;
            if (!maskData[idx]) continue;
            centerX += x;
            centerY += y;
            centerCount += 1;
          }
        }
        centerX = centerCount ? centerX / centerCount : (minX + maxX) * 0.5;
        centerY = centerCount ? centerY / centerCount : (minY + maxY) * 0.5;

        const passes = Math.max(6, Math.min(9, Math.round(3 + strength * 7)));
        for (let pass = 0; pass < passes; pass += 1) {
          for (let y = minY; y <= maxY; y += 1) {
            for (let x = minX; x <= maxX; x += 1) {
              const idx = y * width + x;
              if (!workMask[idx]) continue;
              const li = (y - minY) * regionW + (x - minX);
              const nearestLi = nearest[li];
              if (nearestLi < 0) continue;

              const nearestX = (nearestLi % regionW) + minX;
              const nearestY = Math.floor(nearestLi / regionW) + minY;
              const nBase = (nearestY * width + nearestX) * 4;

              const mirrorX = Math.max(0, Math.min(width - 1, Math.round(centerX - (x - centerX))));
              const mirrorY = Math.max(0, Math.min(height - 1, Math.round(centerY - (y - centerY))));
              const mIdx = mirrorY * width + mirrorX;
              const mBase = (!workMask[mIdx] ? mIdx : nearestY * width + nearestX) * 4;

              const [rx, ry] = boundaryPool.length
                ? boundaryPool[(x * 73 + y * 151 + pass * 977) % boundaryPool.length]
                : [nearestX, nearestY];
              const rBase = (ry * width + rx) * 4;

              const d = Math.max(0, dist[li]);
              const depthBoost = Math.min(0.38, d * 0.024);
              const alpha = Math.min(0.97, strength + depthBoost);

              const targetR = src[nBase] * 0.6 + src[mBase] * 0.15 + src[rBase] * 0.25;
              const targetG = src[nBase + 1] * 0.6 + src[mBase + 1] * 0.15 + src[rBase + 1] * 0.25;
              const targetB = src[nBase + 2] * 0.6 + src[mBase + 2] * 0.15 + src[rBase + 2] * 0.25;

              const jitter = noiseScale * (0.42 / (pass + 1));
              const j = () => (Math.random() * 2 - 1) * jitter;
              const base = idx * 4;
              out[base] = Math.max(0, Math.min(255, Math.round(out[base] * (1 - alpha) + (targetR + j()) * alpha)));
              out[base + 1] = Math.max(0, Math.min(255, Math.round(out[base + 1] * (1 - alpha) + (targetG + j()) * alpha)));
              out[base + 2] = Math.max(0, Math.min(255, Math.round(out[base + 2] * (1 - alpha) + (targetB + j()) * alpha)));
            }
            if (y % 24 === 0) await yieldToBrowser();
          }
        }
      }

      async function applyAggressiveCrispFill(out, src, maskData, workMask, width, height, minX, minY, maxX, maxY) {
        const { nearest, regionW } = buildNearestBoundaryMap(workMask, width, height, minX, minY, maxX, maxY);
        for (let y = minY; y <= maxY; y += 1) {
          for (let x = minX; x <= maxX; x += 1) {
            const idx = y * width + x;
            if (!workMask[idx]) continue;
            const li = (y - minY) * regionW + (x - minX);
            const nearestLi = nearest[li];
            if (nearestLi < 0) continue;
            const nearestX = (nearestLi % regionW) + minX;
            const nearestY = Math.floor(nearestLi / regionW) + minY;
            const srcBase = (nearestY * width + nearestX) * 4;
            const base = idx * 4;
            const alpha = maskData[idx] ? 0.96 : 0.72;
            out[base] = Math.round(out[base] * (1 - alpha) + src[srcBase] * alpha);
            out[base + 1] = Math.round(out[base + 1] * (1 - alpha) + src[srcBase + 1] * alpha);
            out[base + 2] = Math.round(out[base + 2] * (1 - alpha) + src[srcBase + 2] * alpha);
          }
          if (y % 24 === 0) await yieldToBrowser();
        }
      }

      async function smoothMaskedRegion(out, maskData, width, height, minX, minY, maxX, maxY, passes) {
        const kernel = [1, 2, 1, 2, 4, 2, 1, 2, 1];
        for (let pass = 0; pass < passes; pass += 1) {
          const src = new Uint8ClampedArray(out);
          for (let y = minY; y <= maxY; y += 1) {
            for (let x = minX; x <= maxX; x += 1) {
              const idx = y * width + x;
              if (!maskData[idx]) continue;
              let rs = 0;
              let gs = 0;
              let bs = 0;
              let ws = 0;
              let k = 0;
              for (let ny = Math.max(0, y - 1); ny <= Math.min(height - 1, y + 1); ny += 1) {
                for (let nx = Math.max(0, x - 1); nx <= Math.min(width - 1, x + 1); nx += 1) {
                  const w = kernel[k++];
                  const b = (ny * width + nx) * 4;
                  rs += src[b] * w;
                  gs += src[b + 1] * w;
                  bs += src[b + 2] * w;
                  ws += w;
                }
              }
              const base = idx * 4;
              out[base] = Math.round(rs / ws);
              out[base + 1] = Math.round(gs / ws);
              out[base + 2] = Math.round(bs / ws);
            }
            if (y % 24 === 0) await yieldToBrowser();
          }
        }
      }

      async function featherSeamTowardBoundary(out, src, workMask, width, height, minX, minY, maxX, maxY) {
        const seam = buildSeamMask(workMask, workMask, width, height, minX, minY, maxX, maxY);
        for (let y = minY; y <= maxY; y += 1) {
          for (let x = minX; x <= maxX; x += 1) {
            const idx = y * width + x;
            if (!seam[idx]) continue;
            let rs = 0;
            let gs = 0;
            let bs = 0;
            let count = 0;
            const neighbors = [
              [x - 1, y],
              [x + 1, y],
              [x, y - 1],
              [x, y + 1]
            ];
            for (const [nx, ny] of neighbors) {
              if (nx < 0 || nx >= width || ny < 0 || ny >= height) continue;
              const nIdx = ny * width + nx;
              if (workMask[nIdx]) continue;
              const nBase = nIdx * 4;
              rs += src[nBase];
              gs += src[nBase + 1];
              bs += src[nBase + 2];
              count += 1;
            }
            if (!count) continue;
            const base = idx * 4;
            const alpha = 0.38;
            const br = rs / count;
            const bg = gs / count;
            const bb = bs / count;
            out[base] = Math.round(out[base] * (1 - alpha) + br * alpha);
            out[base + 1] = Math.round(out[base + 1] * (1 - alpha) + bg * alpha);
            out[base + 2] = Math.round(out[base + 2] * (1 - alpha) + bb * alpha);
          }
          if (y % 24 === 0) await yieldToBrowser();
        }
      }

      function estimateBoundaryVariance(src, workMask, width, height, minX, minY, maxX, maxY) {
        let sum = 0;
        let sumSq = 0;
        let count = 0;
        for (let y = minY; y <= maxY; y += 1) {
          for (let x = minX; x <= maxX; x += 1) {
            const idx = y * width + x;
            if (workMask[idx]) continue;
            const neighbors = [
              [x - 1, y],
              [x + 1, y],
              [x, y - 1],
              [x, y + 1]
            ];
            let touchesMask = false;
            for (const [nx, ny] of neighbors) {
              if (nx < 0 || nx >= width || ny < 0 || ny >= height) continue;
              if (workMask[ny * width + nx]) {
                touchesMask = true;
                break;
              }
            }
            if (!touchesMask) continue;
            const base = idx * 4;
            const lum = src[base] * 0.299 + src[base + 1] * 0.587 + src[base + 2] * 0.114;
            sum += lum;
            sumSq += lum * lum;
            count += 1;
          }
        }
        if (!count) return 0;
        const mean = sum / count;
        return Math.max(0, sumSq / count - mean * mean);
      }

      async function inpaintMaskedImage(sourceImageData, maskData, options = {}) {
        const width = sourceImageData.width;
        const height = sourceImageData.height;
        const src = sourceImageData.data;
        const algorithm =
          options.algorithm === 'aggressive'
            ? 'aggressive'
            : options.algorithm === 'ai'
              ? 'ai'
            : options.algorithm === 'texture'
              ? 'texture'
              : 'natural';
        const brushSize = Number(options.brushSize) || 28;
        const onProgress = typeof options.onProgress === 'function' ? options.onProgress : null;
        const dilateRadius =
          algorithm === 'aggressive'
            ? Math.max(4, Math.min(14, Math.round(brushSize / 9)))
            : algorithm === 'ai'
              ? Math.max(4, Math.min(12, Math.round(brushSize / 10)))
            : algorithm === 'texture'
              ? Math.max(2, Math.min(8, Math.round(brushSize / 14)))
            : 0;
        const workMask = dilateRadius > 0 ? dilateMaskData(maskData, width, height, dilateRadius) : maskData;
        const out = new Uint8ClampedArray(src);
        const total = width * height;
        const known = new Uint8Array(total);

        let unknownCount = 0;
        let minX = width;
        let minY = height;
        let maxX = -1;
        let maxY = -1;

        for (let y = 0; y < height; y += 1) {
          for (let x = 0; x < width; x += 1) {
            const idx = y * width + x;
            if (workMask[idx] > 0) {
              unknownCount += 1;
              if (x < minX) minX = x;
              if (y < minY) minY = y;
              if (x > maxX) maxX = x;
              if (y > maxY) maxY = y;
            } else {
              known[idx] = 1;
            }
          }
        }

        if (unknownCount === 0) return new ImageData(out, width, height);

        const pad = 2;
        minX = Math.max(0, minX - pad);
        minY = Math.max(0, minY - pad);
        maxX = Math.min(width - 1, maxX + pad);
        maxY = Math.min(height - 1, maxY + pad);
        const regionW = maxX - minX + 1;
        const regionH = maxY - minY + 1;

        const rA = new Float32Array(total);
        const gA = new Float32Array(total);
        const bA = new Float32Array(total);
        const rB = new Float32Array(total);
        const gB = new Float32Array(total);
        const bB = new Float32Array(total);

        for (let i = 0; i < total; i += 1) {
          const base = i * 4;
          rA[i] = src[base];
          gA[i] = src[base + 1];
          bA[i] = src[base + 2];
        }

        // Seed unknown pixels with local boundary averages to avoid hard directional artifacts.
        const seedPasses =
          algorithm === 'aggressive' ? 16 : algorithm === 'ai' ? 18 : algorithm === 'texture' ? 12 : 10;
        for (let pass = 0; pass < seedPasses; pass += 1) {
          for (let y = minY; y <= maxY; y += 1) {
            for (let x = minX; x <= maxX; x += 1) {
              const idx = y * width + x;
              if (known[idx]) continue;
              let rs = 0;
              let gs = 0;
              let bs = 0;
              let count = 0;
              for (let ny = Math.max(0, y - 1); ny <= Math.min(height - 1, y + 1); ny += 1) {
                for (let nx = Math.max(0, x - 1); nx <= Math.min(width - 1, x + 1); nx += 1) {
                  const nIdx = ny * width + nx;
                  if (!known[nIdx]) continue;
                  rs += rA[nIdx];
                  gs += gA[nIdx];
                  bs += bA[nIdx];
                  count += 1;
                }
              }
              if (count > 0) {
                rB[idx] = rs / count;
                gB[idx] = gs / count;
                bB[idx] = bs / count;
              } else {
                rB[idx] = rA[idx];
                gB[idx] = gA[idx];
                bB[idx] = bA[idx];
              }
            }
          }
          for (let y = minY; y <= maxY; y += 1) {
            for (let x = minX; x <= maxX; x += 1) {
              const idx = y * width + x;
              if (known[idx]) continue;
              rA[idx] = rB[idx];
              gA[idx] = gB[idx];
              bA[idx] = bB[idx];
            }
          }
          await yieldToBrowser();
        }

        // Harmonic inpainting (Jacobi) gives isotropic fills and avoids diagonal/star streak artifacts.
        const iterations =
          algorithm === 'aggressive'
            ? Math.max(80, Math.min(420, Math.round(Math.max(regionW, regionH) * 1.1)))
            : algorithm === 'ai'
              ? Math.max(120, Math.min(560, Math.round(Math.max(regionW, regionH) * 1.25)))
            : algorithm === 'texture'
              ? Math.max(70, Math.min(320, Math.round(Math.max(regionW, regionH) * 0.9)))
            : Math.max(50, Math.min(260, Math.round(Math.max(regionW, regionH) * 0.75)));
        for (let iter = 0; iter < iterations; iter += 1) {
          for (let y = minY; y <= maxY; y += 1) {
            for (let x = minX; x <= maxX; x += 1) {
              const idx = y * width + x;
              if (known[idx]) {
                rB[idx] = rA[idx];
                gB[idx] = gA[idx];
                bB[idx] = bA[idx];
                continue;
              }

              const l = y * width + Math.max(0, x - 1);
              const r = y * width + Math.min(width - 1, x + 1);
              const u = Math.max(0, y - 1) * width + x;
              const d = Math.min(height - 1, y + 1) * width + x;

              rB[idx] = (rA[l] + rA[r] + rA[u] + rA[d]) * 0.25;
              gB[idx] = (gA[l] + gA[r] + gA[u] + gA[d]) * 0.25;
              bB[idx] = (bA[l] + bA[r] + bA[u] + bA[d]) * 0.25;
            }
          }

          for (let y = minY; y <= maxY; y += 1) {
            for (let x = minX; x <= maxX; x += 1) {
              const idx = y * width + x;
              if (known[idx]) continue;
              rA[idx] = rB[idx];
              gA[idx] = gB[idx];
              bA[idx] = bB[idx];
            }
          }

          if (typeof onProgress === 'function') {
            onProgress((iter + 1) / iterations);
          }
          if (iter % 6 === 0) {
            await yieldToBrowser();
          }
        }

        for (let y = minY; y <= maxY; y += 1) {
          for (let x = minX; x <= maxX; x += 1) {
            const idx = y * width + x;
            if (known[idx]) continue;
            const base = idx * 4;
            out[base] = Math.max(0, Math.min(255, Math.round(rA[idx])));
            out[base + 1] = Math.max(0, Math.min(255, Math.round(gA[idx])));
            out[base + 2] = Math.max(0, Math.min(255, Math.round(bA[idx])));
          }
        }

        if (algorithm === 'aggressive') {
          await applyAggressiveCrispFill(out, src, maskData, workMask, width, height, minX, minY, maxX, maxY);
          const seamMask = buildSeamMask(workMask, maskData, width, height, minX, minY, maxX, maxY);
          await smoothMaskedRegion(out, seamMask, width, height, minX, minY, maxX, maxY, 1);
        } else if (algorithm === 'ai') {
          await applyAIGenerativeFill(out, src, maskData, workMask, width, height, minX, minY, maxX, maxY, 0.88);
          await applyAIGenerativeFill(out, src, maskData, workMask, width, height, minX, minY, maxX, maxY, 0.58);
          const boundaryVar = estimateBoundaryVariance(src, workMask, width, height, minX, minY, maxX, maxY);
          if (boundaryVar < 260) {
            // Smooth backgrounds (dark walls, skies, gradients): avoid synthetic streak/noise artifacts.
            await smoothMaskedRegion(out, maskData, width, height, minX, minY, maxX, maxY, 3);
            const seamMaskSoft = buildSeamMask(workMask, maskData, width, height, minX, minY, maxX, maxY);
            await smoothMaskedRegion(out, seamMaskSoft, width, height, minX, minY, maxX, maxY, 2);
          } else {
            await applyTextureTransfer(out, src, workMask, width, height, minX, minY, maxX, maxY, 0.68);
            await applyTextureTransfer(out, src, workMask, width, height, minX, minY, maxX, maxY, 0.44);
            await applyTextureTransfer(out, src, workMask, width, height, minX, minY, maxX, maxY, 0.24);
          }
          const seamMask = buildSeamMask(workMask, maskData, width, height, minX, minY, maxX, maxY);
          await smoothMaskedRegion(out, seamMask, width, height, minX, minY, maxX, maxY, 2);
          await featherSeamTowardBoundary(out, src, workMask, width, height, minX, minY, maxX, maxY);
          await featherSeamTowardBoundary(out, src, workMask, width, height, minX, minY, maxX, maxY);
        } else if (algorithm === 'texture') {
          await applyTextureTransfer(out, src, workMask, width, height, minX, minY, maxX, maxY, 0.72);
          await applyTextureTransfer(out, src, workMask, width, height, minX, minY, maxX, maxY, 0.42);
          const seamMask = buildSeamMask(workMask, maskData, width, height, minX, minY, maxX, maxY);
          await smoothMaskedRegion(out, seamMask, width, height, minX, minY, maxX, maxY, 1);
        } else {
          // Natural mode: smooth masked interior and softly feather boundaries into surrounding gradients.
          await smoothMaskedRegion(out, maskData, width, height, minX, minY, maxX, maxY, 2);
          await featherSeamTowardBoundary(out, src, workMask, width, height, minX, minY, maxX, maxY);
        }

        if (typeof onProgress === 'function') onProgress(1);
        return new ImageData(out, width, height);
      }

      async function loadRemoveImage(file) {
        const img = await fileToImage(file);
        const maxDimension = 1700;
        const fit = Math.min(1, maxDimension / Math.max(img.width, img.height));
        const targetW = Math.max(1, Math.round(img.width * fit));
        const targetH = Math.max(1, Math.round(img.height * fit));

        const baseCanvas = document.createElement('canvas');
        baseCanvas.width = targetW;
        baseCanvas.height = targetH;
        const baseCtx = baseCanvas.getContext('2d');
        baseCtx.imageSmoothingEnabled = true;
        baseCtx.imageSmoothingQuality = 'high';
        baseCtx.drawImage(img, 0, 0, targetW, targetH);

        removeState.sourceCanvas = baseCanvas;
        removeCanvas.width = targetW;
        removeCanvas.height = targetH;
        removeState.maskCanvas.width = targetW;
        removeState.maskCanvas.height = targetH;
        removeState.overlayCanvas.width = targetW;
        removeState.overlayCanvas.height = targetH;
        removeMaskCtx.clearRect(0, 0, targetW, targetH);
        removeOverlayCtx.clearRect(0, 0, targetW, targetH);
        removeState.hasMask = false;
        removeState.file = file;
        removeState.historyStack = [];
        refreshRemoveUndoState();
        refreshRemoveViewportLayout();
        setRemoveZoomLevel(1);
        resetRemoveOutputState();
        setRemoveUnsavedProgress(false);
        drawRemoveCanvas();
      }

      removeImageInput.addEventListener('change', async () => {
        if (!removeImageInput.files || removeImageInput.files.length === 0) return;
        try {
          await loadRemoveImage(removeImageInput.files[0]);
          setStatus(removeStatus, t('status.removeImageLoaded'), 'ok');
        } catch {
          setStatus(removeStatus, t('status.loadFailed'), 'error');
        }
      });

      function onRemoveDrawStart(e) {
        if (!removeState.sourceCanvas || removeState.running) return;
        if (e.touches && e.touches.length !== 1) return;
        e.preventDefault();
        removeState.drawing = true;
        const p = getRemovePointer(e);
        removeState.lastPoint = p;
        const radius = syncRemoveBrushInputs(removeBrushSize.value) / 2;
        paintMaskDot(p, radius);
        removeState.hasMask = true;
        setRemoveUnsavedProgress(true);
        resetRemoveOutputState();
        drawRemoveCanvas();
      }

      function onRemoveDrawMove(e) {
        if (!removeState.drawing || removeState.running) return;
        if (e.touches && e.touches.length !== 1) return;
        e.preventDefault();
        const p = getRemovePointer(e);
        const radius = syncRemoveBrushInputs(removeBrushSize.value) / 2;
        paintMaskSegment(removeState.lastPoint, p, radius);
        removeState.lastPoint = p;
        removeState.hasMask = true;
        setRemoveUnsavedProgress(true);
        resetRemoveOutputState();
        drawRemoveCanvas();
      }

      function onRemoveDrawEnd() {
        const shouldRun = removeState.drawing && removeState.hasMask && !removeState.running;
        removeState.drawing = false;
        removeState.lastPoint = null;
        if (shouldRun) {
          runRemoveFromMask();
        }
      }

      removeCanvas.addEventListener('mousedown', onRemoveDrawStart);
      window.addEventListener('mousemove', onRemoveDrawMove);
      window.addEventListener('mouseup', onRemoveDrawEnd);
      removeCanvas.addEventListener('touchstart', onRemoveDrawStart, { passive: false });
      window.addEventListener('touchmove', onRemoveDrawMove, { passive: false });
      window.addEventListener('touchend', onRemoveDrawEnd, { passive: false });
      removeWorkspace.addEventListener('touchstart', (e) => {
        if (e.touches && e.touches.length === 2) {
          removeState.drawing = false;
          removeState.lastPoint = null;
          startTouchGesture(e);
          e.preventDefault();
        }
      }, { passive: false });
      removeWorkspace.addEventListener('touchmove', (e) => {
        if (!removeState.touchGesture.active) return;
        updateTouchGesture(e);
        e.preventDefault();
      }, { passive: false });
      removeWorkspace.addEventListener('touchend', (e) => {
        if (!e.touches || e.touches.length < 2) {
          endTouchGesture();
        }
      }, { passive: false });
      removeWorkspace.addEventListener('touchcancel', () => {
        endTouchGesture();
      }, { passive: false });

      removeBrushSize.addEventListener('input', () => {
        syncRemoveBrushInputs(removeBrushSize.value);
      });
      removeBrushDownBtn.addEventListener('click', () => {
        const current = syncRemoveBrushInputs(removeBrushSize.value);
        syncRemoveBrushInputs(current - 4);
      });
      removeBrushUpBtn.addEventListener('click', () => {
        const current = syncRemoveBrushInputs(removeBrushSize.value);
        syncRemoveBrushInputs(current + 4);
      });
      syncRemoveBrushInputs(removeBrushSize.value);
      refreshRemoveUndoState();

      removeZoomInBtn.addEventListener('click', () => setRemoveZoomLevel(removeState.zoomLevel + 0.25));
      removeZoomOutBtn.addEventListener('click', () => setRemoveZoomLevel(removeState.zoomLevel - 0.25));
      removeZoomResetBtn.addEventListener('click', () => setRemoveZoomLevel(1));
      setRemoveZoomLevel(1);
      refreshRemoveViewportLayout();

      window.addEventListener('resize', () => {
        refreshRemoveViewportLayout();
      });
      window.addEventListener('orientationchange', () => {
        refreshRemoveViewportLayout();
      });
      if (window.visualViewport) {
        window.visualViewport.addEventListener('resize', () => {
          refreshRemoveViewportLayout();
        });
      }

      removeUndoBtn.addEventListener('click', () => {
        if (!removeState.sourceCanvas || removeState.historyStack.length === 0 || removeState.running) return;
        const previousCanvas = removeState.historyStack.pop();
        const sourceCtx = removeState.sourceCanvas.getContext('2d');
        sourceCtx.clearRect(0, 0, removeState.sourceCanvas.width, removeState.sourceCanvas.height);
        sourceCtx.drawImage(previousCanvas, 0, 0);
        refreshRemoveUndoState();
        removeMaskCtx.clearRect(0, 0, removeState.maskCanvas.width, removeState.maskCanvas.height);
        removeState.hasMask = false;
        resetRemoveOutputState();
        setRemoveUnsavedProgress(true);
        drawRemoveCanvas();
        setStatus(removeStatus, t('status.removeUndoDone'), 'ok');
      });

      async function runRemoveFromMask() {
        if (!removeState.sourceCanvas) {
          setStatus(removeStatus, t('status.uploadFirst'), 'error');
          return;
        }
        if (!removeState.hasMask) {
          setStatus(removeStatus, t('status.removeMaskEmpty'), 'error');
          return;
        }
        if (removeState.running) return;

        removeState.running = true;
        setRemoveBusy(true);
        removeDownloadBtn.disabled = true;
        refreshRemoveUndoState();
        setStatus(removeStatus, '');

        const historyLimit = 20;
        let stagedSnapshot = null;
        try {
          const width = removeState.sourceCanvas.width;
          const height = removeState.sourceCanvas.height;
          stagedSnapshot = copyCanvas(removeState.sourceCanvas);
          const sourceCtx = removeState.sourceCanvas.getContext('2d');
          const sourceImageData = sourceCtx.getImageData(0, 0, width, height);
          const maskPixels = removeMaskCtx.getImageData(0, 0, width, height).data;
          const maskData = new Uint8Array(width * height);
          let maskedCount = 0;
          for (let i = 0; i < maskData.length; i += 1) {
            const marked = maskPixels[i * 4 + 3] > 20;
            maskData[i] = marked ? 1 : 0;
            if (marked) maskedCount += 1;
          }
          if (maskedCount === 0) {
            throw new Error(t('status.removeMaskEmpty'));
          }

          const resultImageData = await inpaintMaskedImage(sourceImageData, maskData, {
            algorithm: getSelectedRemoveAlgorithm(),
            brushSize: syncRemoveBrushInputs(removeBrushSize.value)
          });

          sourceCtx.putImageData(resultImageData, 0, 0);
          removeMaskCtx.clearRect(0, 0, width, height);
          removeState.hasMask = false;
          drawRemoveCanvas();

          removeState.resultBlob = await new Promise((resolve) =>
            removeState.sourceCanvas.toBlob(resolve, 'image/png')
          );
          if (!removeState.resultBlob) {
            throw new Error('Remove failed.');
          }
          removeState.historyStack.push(stagedSnapshot);
          if (removeState.historyStack.length > historyLimit) {
            removeState.historyStack.shift();
          }
          removeDownloadBtn.disabled = false;
          refreshRemoveUndoState();
          setRemoveUnsavedProgress(true);
          setStatus(removeStatus, '', 'ok');
        } catch (err) {
          refreshRemoveUndoState();
          setStatus(removeStatus, err.message || t('error.removeFailed'), 'error');
        } finally {
          removeState.running = false;
          refreshRemoveUndoState();
          setRemoveBusy(false);
        }
      }

      removeDownloadBtn.addEventListener('click', async () => {
        if (!removeState.resultBlob || !removeState.file) return;
        const base = removeState.file.name.replace(/\.[^.]+$/, '') || 'image';
        const mode = await downloadBlob(removeState.resultBlob, `${base}-removed.png`);
        setRemoveUnsavedProgress(false);
        setStatus(
          removeStatus,
          mode === 'ios-preview' ? t('status.previewIos') : t('status.doneDownload'),
          'ok'
        );
      });

      window.addEventListener('beforeunload', (e) => {
        if (!removeState.hasUnsavedProgress) return;
        e.preventDefault();
        e.returnValue = '';
      });

      drawRemoveCanvas();
    </script>
  </body>
</html>
